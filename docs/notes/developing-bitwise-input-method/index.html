<html>
<head>
    <title>Developing a bitwise keyboard input method Â· leanrada.com</title>
    <script defer="" async="" src="https://unpkg.com/perlin-noise-3d@0.5.4/dist/perlin-noise-3d.min.js"></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script async="" src="https://cdn.jsdelivr.net/gh/Kalabasa/analytics/analytics.js"></script>
    <style>
        @font-face {
            font-family: "Space Mono";
            src: url("/fonts/SpaceMono-Regular.ttf") format("truetype");
        }

        @font-face {
            font-family: "Space Mono";
            font-style: italic;
            src: url("/fonts/SpaceMono-Italic.ttf") format("truetype");
        }

        @font-face {
            font-family: "Miriam Libre";
            src: url("/fonts/MiriamLibre-Regular.ttf") format("truetype");
        }

        @font-face {
            font-family: "Miriam Libre";
            font-weight: bold;
            src: url("/fonts/MiriamLibre-Bold.ttf") format("truetype");
        }

        :root {
            --default-font: "Space Mono", monaco, Consolas, Lucida Console, monospace;
            --reading-font: "Miriam Libre", Futura, "Trebuchet MS", Arial, sans-serif;

            --bg-clr: #111;
            --card-clr: #222;
            --clr0-light: #54f8c1;
            --clr0: #0ad591;
            --clr0-dark: #018b5d;
            --clr1: #df2063;

            --text-clr: #fff;
            --text2-clr: #999;

            --ease: cubic-bezier(0.8, 0, 1, 1);
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: var(--default-font, monospace);
            background-color: var(--bg-clr, #111);
            color: var(--text-clr, #fff);
            overflow-x: hidden;
        }

        .page-wrapper {
            display: flex;
            flex-direction: column;
            min-height: 100%;
        }

        .page-wrapper-content {
            flex: 1 1 auto;
        }
    </style>
    <style>
        nebula-client>canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <style>
        .home-link {
            text-decoration: none;
        }

        .home-link-icon {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
        }

        .home-link-icon:hover {
            filter: invert(1);
        }
    </style>
    <style>
        .main-footer {
            position: relative;
            display: flex;
            justify-content: space-between;
            gap: 60px;
            padding: 60px calc(max(60px, 50vw - 600px)) 60px;
            font-size: 18px;
            font-weight: bold;
            background: var(--clr0);
            color: #000;
            overflow: hidden;
            content-visibility: auto;
            contain-intrinsic-height: 220x;
        }

        .main-footer-links-heading {
            margin: 0 0 18px;
            font-size: inherit;
        }

        .main-footer-line {
            margin: 0 0 18px;
        }

        .main-footer-nav {
            color: #000;
        }

        .main-footer-nav:hover {
            color: #fff;
        }

        .main-footer-content-part {
            z-index: 1;
        }

        .main-footer-nebula {
            position: absolute;
            left: -30%;
            top: -30%;
            width: 160%;
            height: 160%;
            z-index: 0;
        }

        .main-footer-top-btn {
            z-index: 2;
            position: absolute;
            right: 0;
            top: 0;
            width: 72px;
            height: 36px;
            padding-right: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: none;
            border-bottom-left-radius: 18px;
            background: var(--bg-clr);
            color: var(--clr0-light);
            font: inherit;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
        }

        .main-footer-top-btn:hover {
            color: var(--clr1);
        }

        .main-footer-top-btn::before {
            content: "";
            position: absolute;
            right: 0;
            top: 0;
            width: 36px;
            height: 18px;
            border-top-right-radius: 18px;
            transform: translateX(-72px);
            box-shadow: 18px 0 0 var(--bg-clr);
        }

        @media (max-width: 700px) {
            .main-footer {
                flex-direction: column-reverse;
            }
        }
    </style>
    <style>
        .main-header {
            position: sticky;
            top: 0;
            width: 100%;
            height: 60px;
            padding: 0 calc(25% - 150px);
            z-index: 100;
            box-sizing: border-box;
            pointer-events: none;
        }

        .main-header.float {
            position: fixed;
        }

        .main-header-bar {
            position: relative;
            display: flex;
            justify-content: space-evenly;
            align-items: flex-end;
            height: 100%;
        }

        .main-header-item {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 6ch;
            height: 36px;
            padding: 0 18px;
            border-radius: 18px;
            font-size: 15px;
            font-weight: bold;
            letter-spacing: 1px;
            text-decoration: none;
            text-transform: uppercase;
            color: #fff;
            backdrop-filter: blur(8px);
            background-image: linear-gradient(60deg, #fff2 60%, transparent 60%);
            background-repeat: no-repeat;
            background-size: 220% 100%;
            background-position: 115%;
            pointer-events: all;
            transition: background-position 0.2s var(--ease);
        }

        .main-header-item:hover {
            background-image: linear-gradient(60deg,
                    #fff2 50%,
                    #fff 50%,
                    #fff 60%,
                    transparent 60%);
            background-position: 0%;
        }

        .main-header-item.select {
            background: #fff2;
        }

        .main-header-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            image-rendering: pixelated;
            object-fit: cover;
            object-position: 0 0;
            filter: invert(1);
            backdrop-filter: blur(8px) invert(1);
            pointer-events: all;
        }

        .main-header-icon:hover {
            object-position: 100% 0;
        }

        @media (max-width: 450px) {
            .main-header-icon {
                display: none;
            }
        }

        .main-header-indicator {
            position: absolute;
            width: 6px;
            height: 6px;
            left: 50%;
            top: calc(100% + 12px);
            transform: translate(-50%, -50%);
            /* border acts as extended touch area */
            border: solid 6mm transparent;
            border-left-width: 45vw;
            border-right-width: 45vw;
            border-radius: 50%;
            background: #fff;
            background-clip: padding-box;
            opacity: 0;
            transition: opacity 50ms;
        }

        .main-header.hidden .main-header-indicator {
            opacity: 0.8;
            pointer-events: all;
        }
    </style>
    <style>
        .blog-page {
            display: flex;
            justify-content: center;
            overflow: hidden;
        }

        .content {
            padding: 60px 18px;
            width: 100%;
            max-width: 700px;
            font-family: var(--reading-font, sans-serif);
            font-size: 18px;
            line-height: 2.2;
            letter-spacing: 0.02em;
            color: #ddd;
            box-sizing: border-box;
        }

        .markdown>h1,
        .markdown>h2,
        .markdown>h3,
        .markdown>h4,
        .markdown>h5,
        .markdown>h6 {
            font-family: var(--default-font, monospace);
            font-weight: lighter;
            font-style: italic;
            line-height: 1.6;
            letter-spacing: 0.04em;
            margin: 48px 0 36px;
        }

        .markdown>h1 {
            text-align: center;
            font-size: 200%;
        }

        .markdown>h2 {
            font-size: 150%;
        }

        .markdown>h3,
        .markdown>h4,
        .markdown>h5,
        .markdown>h6 {
            font-size: 120%;
            font-weight: bold;
        }

        .markdown>p {
            margin: 36px 0;
        }

        .markdown>hr {
            width: 36px;
            margin: 90px auto;
            border: solid 1.5px #ccc;
            background: #ccc;
            border-radius: 3px;
        }

        .markdown code:not([class]):not([class]) {
            display: inline-block;
            padding: 0 6px;
            border-radius: 6px;
            font-family: var(--default-font, monospace);
            font-size: 15px;
            background: var(--card-clr);
        }

        .markdown>pre:not([class])>code:not([class]) {
            display: block;
            padding: 18px;
            border-radius: 18px;
            line-height: 1.6;
            font-size: 15px;
            overflow-x: auto;
        }

        .markdown>blockquote {
            position: relative;
            margin: 0;
            padding: 18px 24px;
            border-radius: 18px;
            border: solid 1px var(--clr0);
            font-size: 21px;
        }

        .markdown>blockquote::before {
            content: "";
            position: absolute;
            right: 100%;
            top: 0;
            height: 24px;
            width: 24px;
            border-bottom: solid 1px var(--clr0);
            box-sizing: border-box;
        }

        .markdown>blockquote::after {
            content: "";
            position: absolute;
            right: 100%;
            top: 24px;
            bottom: 18px;
            width: 24px;
            border-top-right-radius: 24px;
            border: solid var(--clr0);
            border-width: 1px 1px 0 0;
            box-shadow: 9px 0 0 var(--bg-clr), 18px 0 0 var(--bg-clr);
            box-sizing: border-box;
        }

        .markdown>blockquote> :first-child {
            margin-top: 0;
        }

        .markdown>blockquote> :last-child {
            margin-bottom: 0;
        }

        .markdown>blockquote cite {
            display: block;
            margin-top: 12px;
            font-size: 15px;
            font-style: inherit;
        }

        .markdown>blockquote cite::before {
            content: "â";
        }

        .markdown>iframe,
        .markdown>p>iframe {
            max-width: calc(100vw - 18px);
            border: none;
            border-radius: 18px;
            background: #fff;
        }

        .markdown .center {
            text-align: center;
        }

        .markdown .center-flex {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* todo? convert to component <blog-bleed>, reuse across <blog-media> */
        .markdown .bleed {
            position: relative;
            left: 50%;
            width: 100vh;
            max-width: max(min(100vw, 800px), 80vw);
            transform: translateX(-50%);
        }

        /* todo: convert to component <caption>, reuse across <blog-media> */
        .markdown .caption {
            display: block;
            font-size: 15px;
        }
    </style>
    <style>
        .text-link {
            color: var(--clr0-light, #fff);
        }

        .text-link:visited {
            color: var(--clr0, #fff);
        }
    </style>
    <style>
        /**
 * Modified by Kalabasa.
 * Based on:
 * a11y-dark theme for JavaScript, CSS, and HTML
 * Based on the okaidia theme: https://github.com/PrismJS/prism/blob/gh-pages/themes/prism-okaidia.css
 * @author ericwbailey
 */

        .code-block .token.comment,
        .code-block .token.prolog,
        .code-block .token.doctype,
        .code-block .token.cdata {
            color: #628b9e;
            font-style: italic;
        }

        .code-block .token.punctuation {
            color: #fefefe;
        }

        .code-block .token.property,
        .code-block .token.tag,
        .code-block .token.constant,
        .code-block .token.symbol,
        .code-block .token.deleted {
            color: #ffa07a;
        }

        .code-block .token.boolean,
        .code-block .token.number {
            color: #00e0e0;
        }

        .code-block .token.selector,
        .code-block .token.attr-name,
        .code-block .token.string,
        .code-block .token.char,
        .code-block .token.builtin,
        .code-block .token.inserted {
            color: #abe338;
        }

        .code-block .token.operator,
        .code-block .token.entity,
        .code-block .token.url,
        .code-block .token.variable {
            color: #00e0e0;
        }

        .code-block .token.atrule,
        .code-block .token.attr-value,
        .code-block .token.function {
            color: #ffd700;
        }

        .code-block .token.keyword {
            color: #00e0e0;
        }

        .code-block .token.regex,
        .code-block .token.important {
            color: #ffd700;
        }

        .code-block .token.important,
        .code-block .token.bold {
            font-weight: bold;
        }

        .code-block .token.italic {
            font-style: italic;
        }

        .code-block .token.entity {
            cursor: help;
        }

        @media screen and (-ms-high-contrast: active) {
            .code-block .token.important {
                background: highlight;
                color: window;
                font-weight: normal;
            }

            .code-block .token.atrule,
            .code-block .token.attr-value,
            .code-block .token.function,
            .code-block .token.keyword,
            .code-block .token.operator,
            .code-block .token.selector {
                font-weight: bold;
            }

            .code-block .token.attr-value,
            .code-block .token.comment,
            .code-block .token.doctype,
            .code-block .token.function,
            .code-block .token.keyword,
            .code-block .token.operator,
            .code-block .token.property,
            .code-block .token.string {
                color: highlight;
            }

            .code-block .token.attr-value,
            .code-block .token.url {
                font-weight: normal;
            }
        }
    </style>
    <style>
        .code-block-code {
            display: block;
            padding: 18px;
            border-radius: 18px;
            font-family: var(--default-font, monospace);
            font-size: 15px;
            line-height: 1.6;
            background: var(--card-clr);
            white-space: pre;
            overflow-x: auto;
        }
    </style>
    <style>
        .box-note {
            display: block;
            padding: 12px 18px;
            border-radius: 12px;
            border: solid 2px var(--clr0-dark);
            box-sizing: border-box;
        }
    </style>
    <style>
        .bitwise-key-demo {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: min(16px, 0.5em);
            padding: 32px 16px;
            border: solid 1px #466;
            border-radius: 24px;
            background: #233;
            font-family: sans-serif;
            font-size: min(22px, 4vmin);
        }

        .bitwise-key-demo-digit {
            background: none;
            border: none;
            padding: 0;
            font: inherit;
            color: inherit;
        }

        .bitwise-key-demo-bit {
            text-align: center;
            font-family: monospace;
            font-weight: bold;
            height: 2em;
        }

        .bitwise-key-demo-key {
            position: relative;
            display: flex;
            justify-content: flex-start;
            align-items: flex-end;
            width: 3em;
            height: 3em;
            padding: 0em 0.5em;
            margin-bottom: 16px;
            border-radius: 8px;
            background: #fff;
            color: #444;
            box-shadow: 0 16px 0 #ddd;
            cursor: pointer;
            box-sizing: border-box;
        }

        .bitwise-key-demo-digit-active .bitwise-key-demo-key,
        .bitwise-key-demo-digit:active .bitwise-key-demo-key {
            top: 8px;
            box-shadow: 0 8px 0 #ddd;
        }

        .bitwise-key-demo-digit-set .bitwise-key-demo-key {
            background: #f88;
            color: #422;
            box-shadow: 0 16px 0 #c77;
        }

        .bitwise-key-demo-digit-set.bitwise-key-demo-digit-active .bitwise-key-demo-key,
        .bitwise-key-demo-digit-set:active .bitwise-key-demo-key {
            top: 8px;
            box-shadow: 0 8px 0 #c77;
        }

        .bitwise-key-demo-result {
            width: 4em;
            height: 2em;
            text-align: right;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
    <style>
        .blog-media {
            position: relative;
            text-align: center;
            /* external margin because itâs expected to be in an article */
            margin: 36px 0;
        }

        .blog-media-bleed {
            margin: 90px 0;
            max-height: 80vh;
        }

        .blog-media-element {
            display: inline-block;
            max-width: 100%;
            max-height: 80vh;
            border-radius: 18px;
            box-sizing: border-box;
        }

        .blog-media-bleed .blog-media-element {
            position: relative;
            left: 50%;
            max-width: max(min(100vw, 800px), 80vw);
            transform: translateX(-50%);
        }

        .blog-media-windowed .blog-media-element {
            border-radius: 0;
        }

        .blog-media-caption {
            display: block;
            font-size: 15px;
        }
    </style>
    <style>
        .blog-post-info {
            margin: 24px 0 0;
            font-family: var(--default-font);
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            color: var(--text2-clr);
        }
    </style>
    <style>
        .text-with-bg-span {
            display: inline;
            margin: 0;
            padding: 0.7em;
            padding: 0.35lh;
            border-radius: 18px;
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
            font: inherit;
            background: var(--text-with-bg-color);
        }
    </style>
    <style>
        .blog-header {
            isolation: isolate;
            margin-top: 60px;
            position: relative;
            left: 50%;
            height: 600px;
            width: max(800px, 60vw);
            transform: translateX(-50%);
            box-sizing: border-box;
        }

        .blog-header-title {
            position: relative;
            max-width: 800px;
            font-family: var(--default-font);
            font-size: 36px;
            font-weight: bold;
            font-style: italic;
            text-align: left;
            z-index: 2;
        }

        .blog-header-title-inner {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        /* Wrap lines in an angle */
        .blog-header-title::before {
            content: "";
            width: 50%;
            height: 600px;
            float: right;
            shape-outside: polygon(80% 0%, 100% 0%, 100% 100%, 0% 100%);
        }

        .blog-header-hero {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 18px;
            background: cyan;
            z-index: -1;
        }

        .blog-header-decor {
            position: absolute;
            inset: 0;
            pointer-events: none;
            fill: var(--bg-clr);
            z-index: 1;
        }

        @media (max-width: 800px) {
            .blog-header {
                width: 100vw;
                width: 100svw;
                height: 400px;
                padding-right: 36px;
            }

            .blog-header-title {
                font-size: clamp(24px, 20px + 2vw, 36px);
            }

            .blog-header-title::before {
                content: none;
            }
        }
    </style>
    <script>
        (() => {
            globalThis.BaseElement = createBaseElement(HTMLElement);

            const lifecycleListeners = Symbol("lifecycleListeners");

            function createBaseElement(superClass) {
                return class BaseElement extends superClass {
                    constructor() {
                        super();
                        this[lifecycleListeners] = [];
                    }
                    connectedCallback() {
                        this[lifecycleListeners].forEach((it) => it.connect());
                    }
                    disconnectedCallback() {
                        this[lifecycleListeners].forEach((it) => it.disconnect());
                    }

                    /**
                     * @param factory {() => () => void}
                     */
                    addLifecycleListener(factory) {
                        let cleanup = () => {};
                        const connect = () => (cleanup = factory());
                        const disconnect = () => cleanup();

                        this[lifecycleListeners].push({
                            connect,
                            disconnect
                        });

                        if (this.isConnected) {
                            connect();
                        }
                    }

                    /**
                     * @param selector {string}
                     */
                    asyncQuerySelector(selector) {
                        const obj = {
                            exists: false,
                            element: null,
                        };

                        obj.promise = new Promise((resolve) => {
                            const observer = new MutationObserver(() => {
                                obj.element = this.querySelector(selector);
                                if (obj.element) {
                                    resolve(obj.element);
                                    obj.exists = true;
                                    observer.disconnect();
                                }
                            });

                            this.addLifecycleListener(() => {
                                observer.observe(this, {
                                    childList: true,
                                    subtree: true
                                });
                                return () => observer.disconnect();
                            });
                        });

                        return obj;
                    }

                    /**
                     * @param target {Element}
                     * @param event {string}
                     * @param callback {Function}
                     */
                    aliveListener(target, event, callback) {
                        this.addLifecycleListener(() => {
                            target.addEventListener(event, callback);
                            return () => target.removeEventListener(event, callback);
                        });
                    }

                    /**
                     * @param callbacks {object}
                     * @param callbacks.show {Function}
                     * @param callbacks.hide {Function}
                     */
                    visibilityListener({
                        show,
                        hide
                    }) {
                        let isShowing = false;

                        const observer = new IntersectionObserver((entries) => {
                            for (const entry of entries) {
                                if (entry.target !== this) continue;
                                if (isShowing !== entry.isIntersecting) {
                                    isShowing = entry.isIntersecting;
                                    if (isShowing) {
                                        show();
                                    } else {
                                        hide();
                                    }
                                }
                            }
                        });

                        this.addLifecycleListener(() => {
                            isShowing = isInViewport(this);
                            if (isShowing) show();
                            observer.observe(this);
                            return () => {
                                observer.disconnect();
                                if (isShowing) hide();
                                isShowing = false;
                            };
                        });
                    }
                };
            }

            window.mousePosition = {
                x: 0,
                y: 0
            };
            document.addEventListener(
                "DOMContentLoaded",
                () => {
                    document.body.addEventListener("mousemove", (event) => {
                        window.mousePosition.x = event.clientX;
                        window.mousePosition.y = event.clientY;
                    });
                }, {
                    once: true
                }
            );
        })();

        function isInViewport(element) {
            const rect = element.getBoundingClientRect();
            return (
                rect.right > 0 &&
                rect.bottom > 0 &&
                rect.left < window.innerWidth &&
                rect.top < window.innerHeight
            );
        }
    </script>
    <script>
        (() => {
            customElements.define(
                "nebula-client",
                class Nebula extends BaseElement {
                    constructor() {
                        super();

                        this.asyncCanvas = this.asyncQuerySelector("canvas");
                        this.context = null;
                        this.noise = null;

                        this.gridWidth = 30;
                        this.gridHeight = 30;
                        this.palette = ["#ffffff"];

                        this.cellWidth = 1; // placeholder
                        this.cellHeight = 1; // placeholder

                        this.useMouse = false;
                        this.mouseCell = null;

                        this.lastT = 0;
                        this.startT = 0;
                        this.loopStartT = 0;

                        this.isVisible = false;
                        this.visibilityListener({
                            show: () => {
                                this.isVisible = true;
                                this.startLoop();
                            },
                            hide: () => (this.isVisible = false),
                        });
                    }

                    connectedCallback() {
                        super.connectedCallback();

                        this.useMouse = this.getAttribute("mouse") != null;

                        const gridWidth = this.getAttribute("width");
                        if (gridWidth) {
                            this.gridWidth = Number.parseInt(gridWidth);
                        }

                        const gridHeight = this.getAttribute("height");
                        if (gridHeight) {
                            this.gridHeight = Number.parseInt(gridHeight);
                        }

                        const paletteAttr = this.getAttribute("palette");
                        if (paletteAttr) {
                            this.palette = paletteAttr.split(" ");
                        }
                    }

                    startLoop() {
                        this.loopStartT = this.lastT = this.getT();
                        this.loop();
                    }

                    async loop() {
                        if (!this.isVisible) {
                            return;
                        }

                        if (typeof perlinNoise3d === "undefined") {
                            setTimeout(() => this.loop(), 200);
                            return;
                        } else if (!this.noise) {
                            this.noise = initNoise();
                            this.startT = this.getT();
                        }

                        const canvas =
                            this.asyncCanvas.value ?? (await this.asyncCanvas.promise);

                        // initialize
                        if (!this.context) {
                            this.cellWidth = Math.ceil(canvas.offsetWidth / this.gridWidth);
                            this.cellHeight = Math.ceil(canvas.offsetHeight / this.gridHeight);
                            canvas.width = this.gridWidth;
                            canvas.height = this.gridHeight;
                            canvas.style.filter += ` blur(${
              Math.min(this.cellWidth, this.cellHeight) * 1.25
            }px)`;
                            this.context = canvas.getContext("2d");
                        }

                        this.draw(canvas, this.context);

                        requestAnimationFrame(() => this.loop());
                    }

                    /**
                     * @param canvas {HTMLCanvasElement}
                     * @param context {CanvasRenderingContext2D}
                     */
                    draw(canvas, context) {
                        const t = this.getT();
                        if (t <= this.lastT) return;

                        const alpha = 1 - Math.pow(1 - 0.016, t - this.lastT);
                        this.lastT = t;

                        const {
                            noise,
                            gridWidth,
                            gridHeight,
                            palette,
                            cellWidth,
                            cellHeight,
                        } = this;
                        const halfGridWidth = gridWidth / 2;
                        const halfGridHeight = gridHeight / 2;

                        this.mouseCell = null;
                        // mousePosition from lib/common
                        if (this.useMouse && window.mousePosition) {
                            const {
                                x,
                                y
                            } = window.mousePosition;
                            const bounds = canvas.getBoundingClientRect();
                            if (
                                bounds.left < x &&
                                x < bounds.right &&
                                bounds.top < y &&
                                y < bounds.bottom
                            ) {
                                this.mouseCell = {
                                    x: (x - bounds.x) / cellWidth,
                                    y: (y - bounds.y) / cellHeight,
                                };
                            }
                        }

                        const paletteLength = palette.length;
                        const xScale = 0.14 + Math.sin(t * 0.03) * 0.06;
                        const yScale = 0.14 + Math.cos(t * 0.05) * 0.06;

                        for (let i = 0; i < gridWidth; i++) {
                            for (let j = 0; j < gridHeight; j++) {
                                const mouseProximity =
                                    this.mouseCell == null ?
                                    0 :
                                    1 -
                                    sigmoid(
                                        Math.hypot(i - this.mouseCell.x, j - this.mouseCell.y) - 3
                                    );

                                const xy = [
                                    1000 + (i - halfGridWidth) * xScale + Math.sin(t * 0.01) * 2,
                                    1000 +
                                    (j - halfGridHeight) * yScale +
                                    Math.cos(t * 0.007) * 2 +
                                    -mouseProximity,
                                ];
                                const p1 = noise.get(...xy, t * 0.03);
                                const p2 = noise.get(...xy, t * 0.03 + 0.5);
                                // for some reason, this library's output range is [0,0.5], so this averages to [0,1]
                                const p = p1 + p2;

                                const paletteIndex = Math.floor(paletteLength * p);

                                const rgb = palette[paletteIndex];
                                const a = Math.floor(Math.max(alpha, mouseProximity) * 255)
                                    .toString(16)
                                    .padStart(2, "0");

                                context.fillStyle = `${rgb}${a}`;
                                context.fillRect(i, j, 1, 1);
                            }
                        }
                    }

                    getT() {
                        const t = (Date.now() * 30) / 1000;
                        // make it smoother while interacting
                        return this.mouseCell ? t : Math.floor(t);
                    }
                }
            );

            function initNoise() {
                const noise = new perlinNoise3d();
                noise.perlin_octaves = 1; // ?? defaults
                noise.perlin_amp_falloff = 1;
                return noise;
            }

            function sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
        })();
    </script>
</head>


<body>

    <div class="page-wrapper">
        <header class="main-header">
            <div class="main-header-bar">
                <a href="/" class="main-header-item ">Home</a>
                <a href="/wares/" class="main-header-item ">Wares</a>
                <img class="main-header-icon" src="/icons/yay_sheet.png">
                <a href="/art/" class="main-header-item ">Art</a>
                <a href="/notes/" class="main-header-item ">Notes</a>
                <div class="main-header-indicator"></div>
            </div>
        </header>
        <div class="page-wrapper-content">

            <div class="blog-page">
                <div class="content">

                    <!-- prettier-ignore -->
                    <div class="markdown">
                        <div class="blog-header">
                            <div class="text-with-bg blog-header-title" style="--text-with-bg-color: var(--bg-clr)">
                                <h1 class="text-with-bg-span blog-header-title-inner">
                                    Developing a bitwise keyboard input method
                                </h1>
                            </div>
                            <img srcset="/notes/developing-bitwise-input-method/hero_800.generated.jpg 800w,/notes/developing-bitwise-input-method/hero_1020.generated.jpg 1020w,/notes/developing-bitwise-input-method/hero_1400.generated.jpg 1400w" sizes="not (min-width:800px) 800px,(max-width:1275px) 1020px, 1400px" class="blog-header-hero" src="/notes/developing-bitwise-input-method/hero.jpg" spec="100% [800) 80%">
                            <svg xmlns="http://www.w3.org/2000/svg" class="blog-header-decor">
                                <path></path>
                            </svg>
                        </div>

                        <div class="blog-post-info">
                            16 Mar 2023 Â· 4 min read
                        </div>

                        <p>This post is about how I achieved the power of 15 keys using just 4 keys on the keyboard. I go over the motivation, the design, and the implementation. At the end, I wrap the solution into a small library. Maybe youâll find it useful!</p>
                        <h2 id="rationale">Rationale</h2>
                        <p>I use a compact keyboard called the <strong>Lily58</strong> as my main keyboard. Itâs a column-staggered split keyboard.</p>
                        <div class="blog-media blog-media-default">
                            <img srcset="/notes/developing-bitwise-input-method/lily58_664.generated.jpg 664w" sizes=" 664px" class="blog-media-element" alt="Photo of a Lily58 keyboard" src="/notes/developing-bitwise-input-method/lily58.jpg" spec="100% [664) 664" loading="lazy" width="100%" height="" style="aspect-ratio: 1.4994780793319415; background: #e8f8f8"><span class="blog-media-caption">The Lily58 keyboard. Photo from github.com/kata0510/Lily58</span>
                        </div>

                        <p>As the name implies, it has only 58 buttons instead of the normal 80+ buttons. Space was limited and it was hard to fit all the letters, numbers, symbols, and other unique keys that I need.</p>
                        <p>The function keys (F1, F2, F3, etc) were particularly cumbersome. I donât use them very often, yet they take a lot of space. You can see with my previous function key layout that theyâre not very space-efficient:</p>
                        <div class="blog-media blog-media-default">
                            <img srcset="/notes/developing-bitwise-input-method/prevlayout_656.generated.png 656w,/notes/developing-bitwise-input-method/prevlayout_664.generated.png 664w" sizes="not (min-width:664px) 656px, 664px" class="blog-media-element" alt="" src="/notes/developing-bitwise-input-method/prevlayout.png" spec="100% [664) 664" loading="lazy" width="100%" height="" style="aspect-ratio: 1.1672597864768683; background: #f8f8f8"><span class="blog-media-caption">My previous layout with function keys on the right half of the keyboard. Itâs on a layer that I call the âfunction layerâ.</span>
                        </div>

                        <p>Luckily, the Lily58 is <strong>programmable</strong>! Using the framework slash firmware called <a target="_blank" class="text-link " href="https://qmk.fm/">QMK</a>, I can program the keyboard to add whatever functionality I wanted. And thatâs exactly how I optimized the function keysâ space usage.</p>
                        <h2 id="the-scheme">The scheme</h2>
                        <!--  textlint-disable  -->

                        <p>To make space for other keys, I devised a different way to input function keys, a <strong>bitwise input scheme</strong>. In this scheme, you input in terms of bits; there is one key for each bit. For example, take four keys; if we assign them to bits 1, 2, 4, and 8, we can represent any number from 0 to 15 by pressing a combination of those keys.</p>
                        <!--  textlint-enable  -->

                        <div class="bitwise-key-demo" tabindex="0">
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <div class="bitwise-key-demo-result"></div>
                        </div>
                        <div class="caption center">Interactive diagram! Click the buttons to toggle the corresponding bits.</div>

                        <p>With 15 different combinations, we have more than enough inputs to cover the function keys! Each decimal number is directly mapped to a function key in a 1-to-1 correspondence. For example, pressing the bit combination for decimal 1 will input F1, pressing the combination for decimal 2 will input F2, and so on.</p>
                        <span class="box-note ">
                            <p>Did you know that there are 24 function keys in total?</p>
                            <p>These are the F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F18, F19, F20, F21, F22, F23, and F24 keys.</p>
                            <p>Bit wise, weâd need just 5 bits - 5 keys to cover all 24 function keys.</p>
                        </span>

                        <h2 id="implementation">Implementation</h2>
                        <p>So how does it work? Letâs dive into the practical details.</p>
                        <p>First of all, the implementation doesnât care about timing, so you can press the buttons as sloppily as you want. The key thing is that the algorithm waits for you to release all the buttons before committing the resulting combination.</p>
                        <p>To do any of this, we need a way to keep track of the state of the bits. Letâs use an unsigned integer variable to store it.</p>
                        <p>When a button is pressed, its corresponding bit is set to 1. But when released, we do not necessarily clear the bit back to 0. There will be a separate mechanism for flushing the accumulated bits.</p>
                        <p>Letâs call the variable <code>accumulator</code>.</p>
                        <pre class="code-block"><code class="code-block-code">static uint8_t accumulator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

void <span class="token function">on_press</span><span class="token punctuation">(</span>uint16_t keycode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  int index <span class="token operator">=</span> <span class="token function">get_bit_index</span><span class="token punctuation">(</span>keycode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  accumulator <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

                        <p>Now, the accumulated bits will only be evaluated when all of the buttons have been released. A quick way of knowing when that happens is to watch for the last button to be released. To do this, another integer variable tracks how many buttons are currently being pressed.</p>
                        <pre class="code-block"><code class="code-block-code"><span class="token comment">// Keep count of keys being pressed</span>
static int8_t pressed_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
static uint8_t accumulator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

void <span class="token function">on_press</span><span class="token punctuation">(</span>uint16_t keycode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  int index <span class="token operator">=</span> <span class="token function">get_bit_index</span><span class="token punctuation">(</span>keycode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">// Count key being pressed</span>
  pressed_keys<span class="token operator">++</span><span class="token punctuation">;</span>

  accumulator <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

void <span class="token function">on_release</span><span class="token punctuation">(</span>uint16_t keycode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  int index <span class="token operator">=</span> <span class="token function">get_bit_index</span><span class="token punctuation">(</span>keycode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">// Count key being released</span>
  pressed_keys<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

                        <p>Once the last button is released, it is time to flush the input. The resulting decimal number is mapped to a function key that will finally be sent to the computer.</p>
                        <pre class="code-block"><code class="code-block-code">void <span class="token function">on_release</span><span class="token punctuation">(</span>uint16_t keycode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  int index <span class="token operator">=</span> <span class="token function">get_bit_index</span><span class="token punctuation">(</span>keycode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  pressed_keys<span class="token operator">--</span><span class="token punctuation">;</span>

  <span class="token comment">// When all keys have been released, flush the input</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pressed_keys <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Map accumulated value to the corresponding F-key code</span>
    <span class="token function">send_to_computer</span><span class="token punctuation">(</span>FUNCTION_KEYS<span class="token punctuation">[</span>accumulator<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Reset state for next round</span>
    pressed_keys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    accumulator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

                        <p>And thatâs about it! This is how I got more space on my keyboard. As a bonus, it forces me to practice converting decimal to binary! ð</p>
                        <p>Of course, the code shown here skips some details and totally lacks integration with the QMK framework, but you get the gist.</p>
                        <p>Thereâs one limitation to this approach though: you cannot hold down a function key. It will only send the function key at the end when the last button has been released. I havenât found a need to hold down function keys so itâs not a problem for me right now.</p>
                        <p>I recreated the algorithm in JavaScript/Web as a live demo here! Try it out!</p>
                        <div class="bitwise-key-demo" data-mode="full" tabindex="0">
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <button class="bitwise-key-demo-digit">
                                <div class="bitwise-key-demo-bit"></div>
                                <div class="bitwise-key-demo-key"></div>
                            </button>
                            <div class="bitwise-key-demo-result"></div>
                        </div>
                        <div class="caption center">Demo! You need to use a keyboard for this. Put your input focus on this box and start pressing combinations!</div>

                        <h2 id="how-to-get-it">How to get it</h2>
                        <p>If you use QMK you can easily integrate this with your own keymap. Hereâs a step-by-step on how you may use this utility:</p>
                        <h3 id="step-1-define-the-bit-keys">Step 1: Define the bit keys.</h3>
                        <p>First, define the keys you want to use as bit input in an array called <code>bitwise_f_keys</code>.</p>
                        <!--  textlint-disable  -->

                        <p>For example, if you wanted to repurpose F1, F2, F3, and F4 to represent the four bits, write the following in your <code>keymap.c</code>:</p>
                        <!--  textlint-enable  -->

                        <pre class="code-block"><code class="code-block-code">const uint16_t bitwise_f_keys<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> KC_F1<span class="token punctuation">,</span> KC_F2<span class="token punctuation">,</span> KC_F3<span class="token punctuation">,</span> KC_F4 <span class="token punctuation">}</span><span class="token punctuation">;</span>
uint8_t NUM_BITWISE_F_KEYS <span class="token operator">=</span>
    <span class="token function">sizeof</span><span class="token punctuation">(</span>bitwise_f_keys<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

                        <p>Note: <code>NUM_BITWISE_F_KEYS</code> is also required.</p>
                        <h3 id="step-2-hook-up-the-library">Step 2: Hook up the library.</h3>
                        <p>Hook it up by calling <code>process_bitwise_f()</code> at the top of your <code>process_record_user()</code>.</p>
                        <pre class="code-block"><code class="code-block-code">bool <span class="token function">process_record_user</span><span class="token punctuation">(</span>uint16_t keycode<span class="token punctuation">,</span> keyrecord_t <span class="token operator">*</span>record<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">process_bitwise_f</span><span class="token punctuation">(</span>keycode<span class="token punctuation">,</span> record<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token comment">/* ... */</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

                        <h3 id="step-3-include-the-library-in-your-project">Step 3: Include the library in your project.</h3>
                        <p>Finally, copy <a target="_blank" class="text-link " href="https://raw.githubusercontent.com/Kalabasa/qmk_firmware/2d1608287bb8b52669255266472975875f7c2423/keyboards/lily58/keymaps/Kalabasa/features/bitwise_f.h"><code>bitwise_f.h</code></a> and <a target="_blank" class="text-link " href="https://raw.githubusercontent.com/Kalabasa/qmk_firmware/2d1608287bb8b52669255266472975875f7c2423/keyboards/lily58/keymaps/Kalabasa/features/bitwise_f.c"><code>bitwise_f.c</code></a> into your keymap directory, and include <code>bitwise_f.c</code> in your <code>rules.mk</code> build file.</p>
                        <p>Donât forget to <code>#include "dir/where/you/copied/bitwise_f.h"</code> in your <code>keymap.c</code>!</p>
                        <p><span class="box-note ">Props to reddit user hakbraley for helping improve the code!</span>
                        </p>

                    </div>

                </div>
            </div>

        </div>
        <footer class="main-footer">
            <div class="main-footer-content-part">
                <p class="main-footer-line">
                    <a target="_self" class="main-footer-nav" href="/">Home</a> Â·
                    <a target="_self" class="main-footer-nav" href="/wares/">Software</a> Â·
                    <a target="_self" class="main-footer-nav" href="/art/">Art</a> Â·
                    <a target="_self" class="main-footer-nav" href="/notes/">Notes</a>
                </p>
                <p class="main-footer-line">(C) 2023 Lean Rada</p>
            </div>
            <div class="main-footer-content-part">
                <h2 class="main-footer-links-heading">On the web</h2>
                <a target="_blank" class="home-link" href="https://www.linkedin.com/in/leanrada/">
                    <img class="home-link-icon" src="/icons/linkedin.png">
                </a>
                <a target="_blank" class="home-link" href="https://codepen.io/kalabasa">
                    <img class="home-link-icon" src="/icons/codepen.png">
                </a>
                <a target="_blank" class="home-link" href="https://stackoverflow.com/users/3144156/kalabasa">
                    <img class="home-link-icon" src="/icons/stackoverflow.png">
                </a>
                <a target="_blank" class="home-link" href="https://github.com/Kalabasa">
                    <img class="home-link-icon" src="/icons/github.png">
                </a>
            </div>


            <nebula-client class="main-footer-nebula" palette="#0ad591 #ff2b75 #ffb833 #0ad591 #0ad591 #4d4aff #0ad591" width="40" height="10">
                <canvas style="filter: contrast(1.5)">
                </canvas></nebula-client>
            <button class="main-footer-top-btn" aria-label="Back to top">^</button>
        </footer>
    </div>
    <script>
        (() => {
            const topBtn = document.querySelector(".main-footer-top-btn");
            topBtn.addEventListener("click", () => {
                window.scrollTo(0, 0);
            });
        })();
    </script>
    <script>
        (() => {
            const mainHeader = document.querySelector(".main-header");
            const indicator = document.querySelector(".main-header-indicator");

            let currentY = 0;
            let currentYTarget = 0;

            let mouseHovering = false;

            let isTouch = false;
            let lastScrollY = window.scrollY;
            let lastCursorY = 0;
            window.addEventListener("scroll", debounce(onScroll));
            window.addEventListener("mousemove", debounce(onMouseMove, 100));
            window.addEventListener("touchstart", onWindowTouchStart);
            window.addEventListener("touchmove", onWindowTouchMove);
            mainHeader.addEventListener("touchstart", onTouchStart);

            function onScroll(event) {
                const dy = window.scrollY - lastScrollY;

                // move with the page
                currentY -= dy;
                if (currentY > 0) {
                    currentY = 0;
                } else if (currentY < -mainHeader.offsetHeight) {
                    currentY = -mainHeader.offsetHeight;
                }

                currentYTarget = currentY;
                updateDOM();

                lastScrollY = window.scrollY;
            }

            function onMouseMove(event) {
                if (isTouch) return;

                const dy = event.clientY - lastCursorY;

                // show when mouse goes near the top
                const scaledDy = Math.sign(dy) * Math.log1p(Math.abs(dy)) * 20;
                if (dy < 0 && event.clientY + scaledDy < mainHeader.offsetHeight) {
                    currentYTarget = 0;
                    mouseHovering = true;
                } else if (
                    mouseHovering &&
                    dy > 0 &&
                    event.clientY > mainHeader.offsetHeight * 4
                ) {
                    currentYTarget = Math.max(-window.scrollY, -mainHeader.offsetHeight);
                    mouseHovering = false;
                }

                updateDOM();
                lastCursorY = event.clientY;
            }

            function onWindowTouchStart(event) {
                isTouch = true;
                lastCursorY = event.touches[0].clientY;
            }

            function onWindowTouchMove(event) {
                const dy = event.touches[0].clientY - lastCursorY;

                // move with touch but only if at edge
                if (window.scrollY <= 0 && dy > 0) {
                    currentY += dy;
                    if (currentY >= 0) {
                        currentY = 0;
                        document.body.style.overscrollBehaviorY = null;
                    } else if (currentY < 0) {
                        document.body.style.overscrollBehaviorY = "none";
                    }

                    currentYTarget = currentY;
                    updateDOM();
                }

                lastCursorY = event.touches[0].clientY;
            }

            function onTouchStart(event) {
                currentYTarget = 0;
                updateDOM();
                console.log("onTouchStart");
            }

            const updateDOM = debounce(() => {
                mainHeader.style.transform = `translateY(${currentY.toFixed(2)}px)`;

                const isHidden = currentY < -mainHeader.offsetHeight * 0.8;
                mainHeader.classList.toggle("hidden", isHidden);

                if (Math.abs(currentY - currentYTarget) > 1) {
                    currentY += (currentYTarget - currentY) * 0.2;
                    requestAnimationFrame(updateDOM);
                } else {
                    currentY = currentYTarget;
                }
            });

            if (mainHeader.classList.contains("prehide")) {
                document.body.style.overscrollBehaviorY = "none";
                currentY = currentYTarget = -mainHeader.offsetHeight;
                updateDOM();
            }

            function debounce(fn, ms = 0) {
                let recentlyFired = false;
                return (...args) => {
                    if (recentlyFired) return;
                    recentlyFired = true;
                    if (ms === 0) {
                        requestAnimationFrame(() => (recentlyFired = false));
                    } else {
                        setTimeout(() => (recentlyFired = false), ms);
                    }
                    return fn(...args);
                };
            }
        })();
    </script>
    <script>
        (() => {
            const demos = document.querySelectorAll(".bitwise-key-demo");
            for (const demo of demos) {
                initDemo(demo);
            }

            function initDemo(demo) {
                const full = demo.dataset.mode === "full";

                const digits = demo.querySelectorAll(".bitwise-key-demo-digit");
                const bits = demo.querySelectorAll(".bitwise-key-demo-bit");
                const keys = demo.querySelectorAll(".bitwise-key-demo-key");

                const result = demo.querySelector(".bitwise-key-demo-result");
                let resultNum = 0;

                const numDigits = digits.length;
                if (bits.length !== numDigits || keys.length !== numDigits) {
                    throw new Error("Invalid DOM structure!");
                }

                const hotkeys = full ? "QWER" : "abcd";
                for (let i = 0; i < numDigits; i++) {
                    keys[i].textContent = hotkeys[i];
                }

                const state = full ? [0, 0, 0, 0] : [0, 1, 1, 0];
                const down = [0, 0, 0, 0];
                resultNum = full ? 0 : 6;
                renderState();

                if (full) {
                    for (let i = 0; i < numDigits; i++) {
                        digits[i].style.pointerEvents = "none";
                    }

                    demo.addEventListener("keydown", (event) => {
                        event.preventDefault();
                        const index = hotkeys.indexOf(event.key.toUpperCase());

                        if (index < 0) return;

                        if (down[index] !== 0) return;
                        down[index] = 1;

                        state[index] = 1;
                        resultNum = 0;
                        renderState();
                        digits[index].classList.add("bitwise-key-demo-digit-active");
                    });

                    demo.addEventListener("keyup", (event) => {
                        event.preventDefault();
                        const index = hotkeys.indexOf(event.key.toUpperCase());

                        if (index < 0) return;

                        if (down[index] === 0) return;
                        down[index] = 0;

                        if (down.reduce((sum, b) => sum + b) === 0) {
                            resultNum = Number.parseInt(state.slice().reverse().join(""), 2);
                            state.forEach((_, i) => (state[i] = 0));
                        }

                        renderState();
                        digits[index].classList.remove("bitwise-key-demo-digit-active");
                    });
                } else {
                    demo.addEventListener("click", (event) => {
                        let index = -1;
                        for (let i = 0; i < numDigits; i++) {
                            if (digits[i].contains(event.target)) {
                                index = i;
                                break;
                            }
                        }

                        if (index < 0) {
                            demo.focus();
                            return;
                        }

                        state[index] = 1 - state[index];
                        resultNum = Number.parseInt(state.slice().reverse().join(""), 2);
                        renderState();
                    });
                }

                function renderState() {
                    for (let i = 0; i < numDigits; i++) {
                        digits[i].classList.toggle(
                            "bitwise-key-demo-digit-set",
                            state[i] !== 0
                        );

                        const label =
                            full && !state.some((b) => b) ?
                            `\u00A0Ã${2 ** i}` :
                            `${state[i]}Ã${2 ** i}`;
                        bits[i].textContent = label;
                    }

                    if (full) {
                        result.textContent = resultNum ? `â¡ F${resultNum}` : "";
                    } else {
                        result.textContent = `= ${resultNum}`;
                    }
                }
            }
        })();
    </script>
    <script>
        (() => {
            const blogMediaElementImages = document.querySelectorAll(
                "img.blog-media-element"
            );

            for (const img of blogMediaElementImages) {
                if (watchImage(img)) {
                    const intervalID = setInterval(() => watchImage(img, intervalID), 200);
                }
                img.addEventListener("load", onLoadImage);
            }

            function watchImage(img, intervalID) {
                if (img.naturalWidth > 0 || img.naturalHeight) {
                    img.style.objectPosition = null;
                    img.removeAttribute("width");
                    img.removeAttribute("height");

                    if (intervalID != undefined) clearInterval(intervalID);
                    return false;
                } else {
                    if (!img.style.objectPosition) {
                        img.style.objectPosition = "100vw";
                    }
                    return true;
                }
            }

            function onLoadImage(event) {
                event.currentTarget.style.background = null;
            }
        })();
    </script>
    <script>
        (() => {
            const header = document.querySelector(".blog-header");
            const hero = document.querySelector(".blog-header-hero");
            const title = header.querySelector(".blog-header-title");
            const titleInner = title.querySelector(".blog-header-title-inner");
            const decor = header.querySelector(".blog-header-decor");
            const decorPath = decor.querySelector("path");

            updateDecorations();
            const observer = new ResizeObserver(() =>
                // Wait for layout
                requestAnimationFrame(() =>
                    requestAnimationFrame(() => updateDecorations())
                )
            );
            observer.observe(header);

            // Add inner corner radius decorations using SVG
            function updateDecorations() {
                const radius = 18;

                const parent = header.getBoundingClientRect();
                const heroRect = hero.getBoundingClientRect();

                const range = document.createRange();
                range.selectNode(titleInner);
                const rects = [...range.getClientRects()];

                const offsetLeft = -parent.left;
                const offsetTop = -parent.top;
                decor.setAttribute("width", Math.floor(heroRect.width));
                decor.setAttribute("height", Math.floor(heroRect.height));

                const pathCommands = [];
                // Find intersections between title rects, find and decorate the corners
                // O(n^2), but n is ~3, so total of ~9 iterations, is fine
                for (let i = 0; i < rects.length; i++) {
                    const r1 = rects[i];
                    for (let j = i + 1; j < rects.length; j++) {
                        const r2 = rects[j];
                        if (!rectsIntersect(r1, r2)) continue;

                        // Technically there are four potential inner corners
                        // But for this specific design, top-left & bottom-left won't be possible

                        // Top right corner
                        if (r1.top < r2.top - radius && r1.right < r2.right - radius) {
                            pathCommands.push(
                                drawInnerCorner(
                                    offsetLeft + r1.right - 1,
                                    offsetTop + r2.top + 1,
                                    offsetLeft + Math.min(r1.right + radius, r2.right - radius),
                                    offsetTop + Math.max(r2.top - radius, r1.top + radius)
                                )
                            );
                        } else if (r1.top > r2.top + radius && r1.right > r2.right + radius) {
                            pathCommands.push(
                                drawInnerCorner(
                                    offsetLeft + r2.right - 1,
                                    offsetTop + r1.top + 1,
                                    offsetLeft + Math.min(r2.right + radius, r1.right - radius),
                                    offsetTop + Math.max(r1.top - radius, r2.top + radius)
                                )
                            );
                        }

                        // Bottom right corner
                        if (r1.bottom > r2.bottom + radius && r1.right < r2.right - radius) {
                            pathCommands.push(
                                drawInnerCorner(
                                    offsetLeft + r1.right - 1,
                                    offsetTop + r2.bottom - 1,
                                    offsetLeft + Math.min(r1.right + radius, r2.right - radius),
                                    offsetTop + Math.min(r2.bottom + radius, r1.bottom - radius)
                                )
                            );
                        } else if (
                            r1.bottom < r2.bottom - radius &&
                            r1.right > r2.right + radius
                        ) {
                            pathCommands.push(
                                drawInnerCorner(
                                    offsetLeft + r2.right - 1,
                                    offsetTop + r1.bottom - 1,
                                    offsetLeft + Math.min(r2.right + radius, r1.right - radius),
                                    offsetTop + Math.min(r1.bottom + radius, r2.bottom - radius)
                                )
                            );
                        }
                    }

                    // Special corners for the hero background
                    // Top edge
                    if (r1.top <= heroRect.top && r1.bottom > heroRect.top) {
                        pathCommands.push(
                            drawInnerCorner(
                                offsetLeft + r1.right - 1,
                                offsetTop + heroRect.top - 1,
                                offsetLeft + r1.right + radius,
                                offsetTop + heroRect.top + radius
                            )
                        );
                    }
                    // Left edge
                    if (r1.left <= heroRect.left && r1.right > heroRect.left) {
                        pathCommands.push(
                            drawInnerCorner(
                                offsetLeft + heroRect.left - 1,
                                offsetTop + r1.bottom - 1,
                                offsetLeft + heroRect.left + radius,
                                offsetTop + r1.bottom + radius
                            )
                        );
                    }
                }

                decorPath.setAttribute("d", pathCommands.join(" "));
            }

            function rectsIntersect(r1, r2) {
                return (
                    r1.right > r2.left &&
                    r1.left < r2.right &&
                    r1.bottom > r2.top &&
                    r1.top < r2.bottom
                );
            }

            function drawInnerCorner(x, y, pointX, pointY) {
                const radiusX = Math.abs(x - pointX);
                const radiusY = Math.abs(y - pointY);
                const dir = (Math.sign((x - pointX) * (y - pointY)) + 1) / 2;
                return (
                    `M ${x} ${y} ` +
                    `L ${x} ${pointY} ` +
                    `A ${radiusX},${radiusY} 0 0 ${dir} ${pointX} ${y} ` +
                    `L ${x} ${y}`
                );
            }
        })();
    </script>
</body>
</html>