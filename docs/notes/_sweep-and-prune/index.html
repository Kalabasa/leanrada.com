<!DOCTYPE html>
<html lang="en">
<head>
  <title>Sort, sweep, and prune: a collision detection algorithm ¬∑ leanrada.com</title>
  <script async="" src="/lib/vendor/perlin-noise-3d.min.js"></script>
  <script type="module" client="" defer="">
    import {
      waitFor
    } from "/lib/wait_for.mjs";
    import {
      BaseElement
    } from "/lib/base_element.mjs";
    import {
      mousePosition
    } from "/lib/mouse_position.mjs";

    customElements.define(
      "nebula-client",
      class Nebula extends BaseElement {
        constructor() {
          super();

          this.asyncCanvas = this.asyncQuerySelector("canvas");
          this.context = null;
          this.noise = null;

          this.gridWidth = 30;
          this.gridHeight = 30;
          this.palette = ["#ffffff"];

          this.cellWidth = 1; // placeholder
          this.cellHeight = 1; // placeholder

          this.useMouse = false;
          this.mouseCell = null;

          this.lastT = 0;
          this.startT = 0;
          this.loopStartT = 0;

          this.isVisible = false;
          this.visibilityListener({
            show: () => {
              this.isVisible = true;
              this.startLoop();
            },
            hide: () => (this.isVisible = false),
          });
        }

        connectedCallback() {
          super.connectedCallback();

          this.useMouse = this.getAttribute("mouse") != null;

          const gridWidth = this.getAttribute("width");
          if (gridWidth) {
            this.gridWidth = Number.parseInt(gridWidth);
          }

          const gridHeight = this.getAttribute("height");
          if (gridHeight) {
            this.gridHeight = Number.parseInt(gridHeight);
          }

          const paletteAttr = this.getAttribute("palette");
          if (paletteAttr) {
            this.palette = paletteAttr.split(" ");
          }
        }

        startLoop() {
          this.loopStartT = this.lastT = this.getT();
          this.loop();
        }

        async loop() {
          if (!this.isVisible) {
            return;
          }

          if (typeof perlinNoise3d === "undefined") {
            await waitFor(() => typeof perlinNoise3d !== "undefined");
          }

          if (!this.noise) {
            this.noise = initNoise();
            this.startT = this.getT();
          }

          const canvas = await this.asyncCanvas.promise;

          // initialize
          if (!this.context) {
            this.cellWidth = Math.ceil(canvas.offsetWidth / this.gridWidth);
            this.cellHeight = Math.ceil(canvas.offsetHeight / this.gridHeight);
            canvas.width = this.gridWidth;
            canvas.height = this.gridHeight;
            canvas.style.filter += ` blur(${
            Math.min(this.cellWidth, this.cellHeight) * 1.25
          }px)`;
            this.context = canvas.getContext("2d");
          }

          this.draw(canvas, this.context);

          requestAnimationFrame(() => this.loop());
        }

        /**
         * @param canvas {HTMLCanvasElement}
         * @param context {CanvasRenderingContext2D}
         */
        draw(canvas, context) {
          const t = this.getT();
          if (t <= this.lastT) return;

          const alpha = 1 - Math.pow(1 - 0.016, t - this.lastT);
          this.lastT = t;

          const {
            noise,
            gridWidth,
            gridHeight,
            palette,
            cellWidth,
            cellHeight
          } =
          this;
          const halfGridWidth = gridWidth / 2;
          const halfGridHeight = gridHeight / 2;

          this.mouseCell = null;
          if (this.useMouse) {
            const {
              x,
              y
            } = mousePosition;
            const bounds = canvas.getBoundingClientRect();
            if (
              bounds.left < x &&
              x < bounds.right &&
              bounds.top < y &&
              y < bounds.bottom
            ) {
              this.mouseCell = {
                x: (x - bounds.x) / cellWidth,
                y: (y - bounds.y) / cellHeight,
              };
            }
          }

          const paletteLength = palette.length;
          const xScale = 0.14 + Math.sin(t * 0.03) * 0.06;
          const yScale = 0.14 + Math.cos(t * 0.05) * 0.06;

          for (let i = 0; i < gridWidth; i++) {
            for (let j = 0; j < gridHeight; j++) {
              const mouseProximity =
                this.mouseCell == null ?
                0 :
                1 -
                sigmoid(
                  Math.hypot(i - this.mouseCell.x, j - this.mouseCell.y) - 3
                );

              const xy = [
                1000 + (i - halfGridWidth) * xScale + Math.sin(t * 0.01) * 2,
                1000 +
                (j - halfGridHeight) * yScale +
                Math.cos(t * 0.007) * 2 +
                -mouseProximity,
              ];
              const p1 = noise.get(...xy, t * 0.03);
              const p2 = noise.get(...xy, t * 0.03 + 0.5);
              // for some reason, this library's output range is [0,0.5], so this averages to [0,1]
              const p = p1 + p2;

              const paletteIndex = Math.floor(paletteLength * p);

              const rgb = palette[paletteIndex];
              const a = Math.floor(Math.max(alpha, mouseProximity) * 255)
                .toString(16)
                .padStart(2, "0");

              context.fillStyle = `${rgb}${a}`;
              context.fillRect(i, j, 1, 1);
            }
          }
        }

        getT() {
          const t = (Date.now() * 24) / 1000;
          // make it smoother while interacting
          return this.mouseCell ? t : Math.floor(t);
        }
      }
    );

    function initNoise() {
      const noise = new perlinNoise3d();
      noise.perlin_octaves = 1; // ?? defaults
      noise.perlin_amp_falloff = 1;
      return noise;
    }

    function sigmoid(x) {
      return 1 / (1 + Math.exp(-x));
    }
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="/favicon.png">
  <script type="module" client="" defer="">
    import {
      BaseElement
    } from "/lib/base_element.mjs";
    // Warn: Module paths are relative to the page, not the component
    import {
      BallSim
    } from "./ball-sim/ball-sim.mjs";
    import {
      Runner
    } from "./ball-sim/runner.mjs";
    import {
      Renderer
    } from "./ball-sim/renderer.mjs";
    import {
      setupDragging
    } from "./ball-sim/dragging.mjs";
    import {
      createProcessPhysicsFunc
    } from "./ball-sim/process-physics.mjs";
    import {
      createDecorations
    } from "./ball-sim/decorations/decorations.mjs";
    import {
      NoopStrat
    } from "./ball-sim/collision-strats/noop-strat.mjs";
    import {
      PairwiseStrat
    } from "./ball-sim/collision-strats/pairwise-strat.mjs";
    import {
      SimpleSweepAndPruneStrat
    } from "./ball-sim/collision-strats/simple-sap-strat.mjs";
    import {
      SweepAndPruneStrat
    } from "./ball-sim/collision-strats/sap-strat.mjs";
    import {
      SweepAndPruneSwapStrat
    } from "./ball-sim/collision-strats/sap-swap-strat.mjs";
    import {
      SkippingDelegateStrat
    } from "./ball-sim/collision-strats/skip-delegate-strat.mjs";
    import {
      createQuickSort
    } from "./ball-sim/sorts/quick-sort.mjs";
    import {
      createInsertionSort
    } from "./ball-sim/sorts/insertion-sort.mjs";

    customElements.define(
      "sap-demo-client",
      class SweepAndPruneDemoClient extends BaseElement {
        constructor() {
          super();

          this.visibilityListener({
            show: async () => {
              if (!this.hasInit) this.init();
              this.runner.start();
            },
            hide: async () => {
              if (this.runner) this.runner.stop();
            },
          });
        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this.cleanup();
        }

        init() {
          this.cleanup();

          const ballsAttr = this.getAttribute("balls");
          const strategyAttr = this.getAttribute("strategy");
          const isStatic = this.hasAttribute("static");
          const noBounce = this.hasAttribute("no-bounce");
          const isDraggable = this.hasAttribute("draggable");
          const labelsAttr = this.getAttribute("labels");
          const isRainbow = this.hasAttribute("rainbow");
          const decorationsAttr = this.getAttribute("decorations");
          const skipIntervalAttr = this.getAttribute("skip-interval");

          const ballSimCreator = BallSim.create(600, 400);
          if (ballsAttr?.startsWith("[")) {
            const ballsSpec = JSON.parse(ballsAttr);
            for (const [x, y, radius] of ballsSpec) {
              ballSimCreator.addBall(x, y, radius);
            }
          } else {
            const ballCount = ballsAttr?.match(/\d+/) ?
              Number.parseInt(ballsAttr) :
              5;
            ballSimCreator.addRandomBalls(ballCount, 0.06 + 0.2 / ballCount);
          }

          this.ballSim = ballSimCreator
            .setStatic(isStatic)
            .setEventTarget(this)
            .build();

          if (isRainbow) {
            const {
              balls
            } = this.ballSim;
            for (let i = 0; i < balls.length; i++) {
              const ball = balls[i];
              const h = i / balls.length;
              ball.color = `hsl(${h}turn 90% 70%)`;
            }
          }

          this.canvas = document.createElement("canvas");
          this.canvas.width = this.ballSim.width;
          this.canvas.height = this.ballSim.height;
          this.appendChild(this.canvas);

          const labelsValue = labelsAttr?.split(",") ?? [];
          this.renderer = new Renderer(
            this.ballSim,
            this.canvas,
            labelsValue,
            isDraggable
          );

          const pause = (duration) => this.runner.pause(duration);

          const {
            callbacks
          } = createDecorations(
            decorationsAttr,
            this.ballSim,
            this.renderer,
            pause
          );

          const processFunc = createProcessPhysicsFunc(
            !noBounce && !isStatic,
            callbacks
          );

          const collStrat = createCollisionStrategy(
            this.ballSim,
            this.renderer,
            processFunc,
            callbacks,
            this,
            strategyAttr,
            skipIntervalAttr
          );

          this.runner = new Runner(collStrat, this.ballSim, this.renderer);

          if (isDraggable) {
            setupDragging(this.ballSim, this.canvas, this);
          }

          this.hasInit = true;
        }

        cleanup() {
          this.replaceChildren();
          if (this.runner) this.runner.stop();
          this.canvas = undefined;
          this.renderer = undefined;
          this.ballSim = undefined;
          this.runner = undefined;
          this.hasInit = false;
        }
      }
    );

    function createCollisionStrategy(
      ballSim,
      renderer,
      processFunc,
      callbacks,
      eventTarget,
      strategyAttr,
      skipIntervalAttr
    ) {
      let collStrat;
      switch (strategyAttr) {
        case "noop":
          collStrat = new NoopStrat();
          break;
        case "pairwise":
          collStrat = new PairwiseStrat(ballSim, renderer, processFunc);
          break;
        case "simple-sap":
          collStrat = new SimpleSweepAndPruneStrat(
            ballSim,
            (arr) => arr.sort((a, b) => a.x - b.x),
            processFunc,
            callbacks,
            eventTarget
          );
          break;
        case "sap-nativesort":
          collStrat = new SweepAndPruneStrat(
            ballSim,
            (arr) => arr.sort((a, b) => a.x - b.x),
            processFunc,
            callbacks,
            eventTarget
          );
          break;
        case "sap-quicksort":
          collStrat = new SweepAndPruneStrat(
            ballSim,
            createQuickSort(callbacks),
            processFunc,
            callbacks
          );
          break;
        case "sap-insertionsort":
          collStrat = new SweepAndPruneStrat(
            ballSim,
            createInsertionSort(callbacks),
            processFunc,
            callbacks
          );
          break;
        case "sap-swap":
          collStrat = new SweepAndPruneSwapStrat(
            ballSim,
            processFunc,
            callbacks
          );
          break;
        default:
          throw new Error("Invalid strategy: " + strategyAttr);
      }

      if (skipIntervalAttr) {
        collStrat = new SkippingDelegateStrat(
          Number.parseInt(skipIntervalAttr),
          collStrat
        );
      }

      return collStrat;
    }
  </script>
  <meta charset="utf-8">
  <link rel="webmention" href="https://webmention.io/leanrada.com/webmention">
  <script async="" src="https://cdn.jsdelivr.net/gh/Kalabasa/analytics/analytics.js"></script>
  <style>
    .box-note {
      display: block;
      padding: 12px 18px;
      border-radius: 12px;
      border: solid 2px var(--clr0-dark);
      box-sizing: border-box;
    }
  </style>
  <style>
    /**
 * Modified by Kalabasa.
 * Based on:
 * a11y-dark theme for JavaScript, CSS, and HTML
 * Based on the okaidia theme: https://github.com/PrismJS/prism/blob/gh-pages/themes/prism-okaidia.css
 * @author ericwbailey
 */

    .code-block .token.comment,
    .code-block .token.prolog,
    .code-block .token.doctype,
    .code-block .token.cdata {
      color: #628b9e;
      font-style: italic;
    }

    .code-block .token.punctuation {
      color: #fefefe;
    }

    .code-block .token.property,
    .code-block .token.tag,
    .code-block .token.constant,
    .code-block .token.symbol,
    .code-block .token.deleted {
      color: #ffa07a;
    }

    .code-block .token.boolean,
    .code-block .token.number {
      color: #00e0e0;
    }

    .code-block .token.selector,
    .code-block .token.attr-name,
    .code-block .token.string,
    .code-block .token.char,
    .code-block .token.builtin,
    .code-block .token.inserted {
      color: #abe338;
    }

    .code-block .token.operator,
    .code-block .token.entity,
    .code-block .token.url,
    .code-block .token.variable {
      color: #00e0e0;
    }

    .code-block .token.atrule,
    .code-block .token.attr-value,
    .code-block .token.function {
      color: #ffd700;
    }

    .code-block .token.keyword {
      color: #00e0e0;
    }

    .code-block .token.regex,
    .code-block .token.important {
      color: #ffd700;
    }

    .code-block .token.important,
    .code-block .token.bold {
      font-weight: bold;
    }

    .code-block .token.italic {
      font-style: italic;
    }

    .code-block .token.entity {
      cursor: help;
    }

    @media screen and (-ms-high-contrast: active) {
      .code-block .token.important {
        background: highlight;
        color: window;
        font-weight: normal;
      }

      .code-block .token.atrule,
      .code-block .token.attr-value,
      .code-block .token.function,
      .code-block .token.keyword,
      .code-block .token.operator,
      .code-block .token.selector {
        font-weight: bold;
      }

      .code-block .token.attr-value,
      .code-block .token.comment,
      .code-block .token.doctype,
      .code-block .token.function,
      .code-block .token.keyword,
      .code-block .token.operator,
      .code-block .token.property,
      .code-block .token.string {
        color: highlight;
      }

      .code-block .token.attr-value,
      .code-block .token.url {
        font-weight: normal;
      }
    }
  </style>
  <style>
    .code-block {
      margin: 0 -18px;
      /* bleed content padding */
      padding: 0 18px;
      /* bleed content padding */
      overflow-x: auto;
    }

    .code-block-code {
      display: inline-block;
      padding: 18px;
      min-width: 100%;
      box-sizing: border-box;
      border-radius: 18px;
      font-family: var(--default-font, monospace);
      font-size: 15px;
      line-height: 1.6;
      background: var(--card-clr);
      white-space: pre;
    }
  </style>
  <style>
    sap-demo-client {
      display: flex;
    }

    sap-demo-client>canvas {
      width: 100%;
      border: solid 2px #ccc;
      border-radius: 12px;
    }

    .sap-demo-draggable>canvas {
      touch-action: none;
    }
  </style>
  <style>
    .text-link {
      color: var(--clr0-light, #fff);
    }

    .text-link:visited {
      color: var(--clr0, #fff);
    }
  </style>
  <style>
    .blog-media {
      position: relative;
      text-align: center;
      /* external margin because it‚Äôs expected to be in an article */
      margin: 36px 0;
    }

    .blog-media-bleed {
      margin: 90px 0;
      max-height: 80vh;
    }

    .blog-media-element {
      display: inline-block;
      max-width: 100%;
      max-height: 80vh;
      border-radius: 18px;
      box-sizing: border-box;
    }

    .blog-media-bleed .blog-media-element {
      position: relative;
      left: 50%;
      max-width: max(min(100vw, 800px), 80vw);
      transform: translateX(-50%);
    }

    .blog-media-windowed .blog-media-element {
      border-radius: 0;
    }

    .blog-media-caption {
      display: block;
      font-size: 15px;
    }
  </style>
  <style>
    .tag-component {
      display: inline-block;
      padding: 0 3px;
      height: 16px;
      line-height: 16px;
      font-family: var(--default-font);
      font-size: 12px;
      font-weight: bold;
      background: #ccc;
      color: #444;
      border-radius: 3px;
    }
  </style>
  <style>
    .tag-row {
      font-family: var(--default-font);
      font-size: 12px;
      font-weight: bold;
    }
  </style>
  <style>
    .blog-post-info {
      margin: 24px 0;
      font-family: var(--default-font);
      font-size: 12px;
      font-weight: bold;
      text-align: center;
      color: var(--text2-clr);
    }

    .blog-post-info-hidden {
      display: none;
    }
  </style>
  <style>
    .text-with-bg-span {
      display: inline;
      margin: 0;
      padding: 0.7em;
      padding: 0.35lh;
      border-radius: 18px;
      box-decoration-break: clone;
      -webkit-box-decoration-break: clone;
      font: inherit;
      background: var(--text-with-bg-color);
    }
  </style>
  <style>
    .blog-header {
      isolation: isolate;
      margin: 90px 0 24px;
      position: relative;
      left: 50%;
      height: 600px;
      width: max(800px, 60vw);
      transform: translateX(-50%);
      box-sizing: border-box;
    }

    .blog-header-title {
      position: relative;
      max-width: 800px;
      font-family: var(--display-font);
      font-size: 36px;
      font-weight: bold;
      font-style: italic;
      text-align: left;
      z-index: 2;
    }

    .blog-header-title-inner {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    /* Wrap lines in an angle */
    .blog-header-title::before {
      content: "";
      width: 0;
      width: calc(min(50%, 120vw - 600px));
      height: 600px;
      float: right;
      shape-outside: polygon(100% 0%, 20% 30%, 0% 100%, 100% 100%, 100% 0%);
    }

    .blog-header-hero {
      position: absolute;
      inset: 1px;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 18px;
      background: gray;
      z-index: -1;
    }

    .blog-header-decor {
      position: absolute;
      inset: 0;
      pointer-events: none;
      fill: var(--bg-clr);
      z-index: 1;
    }

    @media (max-width: 800px) {
      .blog-header {
        width: 100vw;
        width: 100svw;
        height: 400px;
        padding-right: 36px;
      }

      .blog-header-title {
        font-size: clamp(24px, 20px + 2vw, 36px);
      }
    }
  </style>
  <style>
    @import "/fonts/iosevka.css";
    @import "/fonts/top.css";

    :root {
      --default-font: "Iosevka Fixed SS15 Web", "Space Mono", monaco, Consolas, "Lucida Console", monospace;
      --display-font: "Space Mono", "Iosevka Fixed SS15 Web", monaco, Consolas, "Lucida Console", monospace;
      --reading-font: "Miriam Libre", Futura, "Trebuchet MS", Arial, sans-serif;

      --bg-clr: #111616;
      --card-clr: #222c2c;
      --clr0-light: #54f8c1;
      --clr0: #0ad591;
      --clr0-dark: #05b97d;
      --clr1: #df2063;

      --text-clr: #fff;
      --text2-clr: #999;

      --ease: cubic-bezier(0.8, 0, 1, 1);
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--default-font, monospace);
      font-size: 15px;
      font-display: swap;
      font-variant-ligatures: none;
      background-color: var(--bg-clr, #111);
      color: var(--text-clr, #fff);
      overflow-x: hidden;
    }

    .page-wrapper {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .page-wrapper-content {
      flex: 1 1 auto;
    }
  </style>
  <style>
    nebula-client {
      position: relative;
    }

    nebula-client>canvas {
      width: 100%;
      height: 100%;
    }

    .nebula-noise {
      position: absolute;
      inset: 0;
      background: url("/noise.png");
      /* todo: encapsulate noise.png */
      opacity: 0.1;
      animation: nebula-noise-x 0.16s steps(2, jump-start) infinite,
        nebula-noise-y 0.48s steps(3, jump-start) infinite;
    }

    @supports (mix-blend-mode: overlay) {
      .nebula-noise {
        mix-blend-mode: overlay;
        opacity: 0.2;
      }
    }

    @keyframes nebula-noise-x {
      to {
        background-position-x: 100px;
      }
    }

    @keyframes nebula-noise-y {
      to {
        background-position-y: 100px;
      }
    }
  </style>
  <style>
    .main-footer-web-link {
      text-decoration: none;
    }

    .main-footer-web-link-icon {
      width: 32px;
      height: 32px;
      image-rendering: pixelated;
    }

    .main-footer-web-link-icon:hover {
      filter: invert(1);
    }
  </style>
  <style>
    .main-footer {
      position: relative;
      display: flex;
      justify-content: space-between;
      gap: 60px;
      padding: 42px calc(max(36px, 50vw - 600px));
      font-family: var(--display-font);
      font-size: 15px;
      font-weight: bold;
      background: var(--clr0);
      color: #000;
      overflow: hidden;
      content-visibility: auto;
      contain-intrinsic-height: 200px;
    }

    .main-footer-links-heading {
      margin: 18px 0;
      font-size: inherit;
    }

    .main-footer-line {
      margin: 18px 0;
    }

    .main-footer-link {
      color: #000;
    }

    .main-footer-link:hover {
      color: #000;
    }

    .main-footer-webring-icon {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
    }

    .main-footer-signature {
      width: 64px;
      height: 64px;
      image-rendering: pixelated;
      vertical-align: middle;
    }

    .main-footer-content-part {
      z-index: 1;
    }

    .main-footer-nebula {
      position: absolute;
      left: -30%;
      top: -30%;
      width: 160%;
      height: 160%;
      z-index: 0;
    }

    .main-footer-top-btn {
      display: block;
      z-index: 2;
      position: absolute;
      right: 0;
      top: 0;
      width: 72px;
      height: 36px;
      padding-right: 9px;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
      border: none;
      border-bottom-left-radius: 18px;
      background: var(--bg-clr);
      text-decoration: none;
      color: var(--clr0-light);
      font: inherit;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
    }

    .main-footer-top-btn:hover {
      color: var(--clr1);
    }

    .main-footer-top-btn::before {
      content: "";
      position: absolute;
      right: 0;
      top: 0;
      width: 36px;
      height: 18px;
      border-top-right-radius: 18px;
      transform: translateX(-72px);
      box-shadow: 18px 0 0 var(--bg-clr);
    }

    @media (max-width: 700px) {
      .main-footer {
        flex-direction: column-reverse;
      }
    }
  </style>
  <style>
    .main-header {
      position: sticky;
      top: 0;
      width: 100%;
      height: 60px;
      padding: 0 calc(25% - 150px);
      z-index: 100;
      box-sizing: border-box;
      pointer-events: none;
    }

    .main-header.float {
      position: fixed;
    }

    .main-header-bar {
      position: relative;
      display: flex;
      justify-content: space-evenly;
      align-items: flex-end;
      height: 100%;
    }

    .main-header-item {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 6ch;
      height: 36px;
      padding: 0 18px;
      border-radius: 18px;
      font-family: var(--display-font);
      font-size: 15px;
      font-weight: bold;
      letter-spacing: 1px;
      text-decoration: none;
      text-transform: uppercase;
      color: #fff;
      backdrop-filter: blur(8px);
      background-image: linear-gradient(60deg, #fff2 60%, transparent 60%);
      background-repeat: no-repeat;
      background-size: 220% 100%;
      background-position: 115%;
      pointer-events: all;
      transition: background-position 0.2s var(--ease);
    }

    .main-header-item:hover {
      background-image: linear-gradient(60deg,
          #fff2 50%,
          #fff 50%,
          #fff 60%,
          transparent 60%);
      background-position: 0%;
    }

    .main-header-item.select {
      background: #fff2;
    }

    .main-header-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      image-rendering: pixelated;
      object-fit: cover;
      object-position: 0 0;
      filter: invert(1);
      backdrop-filter: blur(8px) invert(1);
      pointer-events: all;
    }

    .main-header-icon:hover {
      object-position: 100% 0;
    }

    @media (max-width: 450px) {
      .main-header-icon {
        display: none;
      }
    }

    .main-header-indicator {
      position: absolute;
      width: 6px;
      height: 6px;
      left: 50%;
      top: calc(100% + 12px);
      transform: translate(-50%, -50%);
      /* border acts as extended touch area */
      border: solid 6mm transparent;
      border-left-width: 45vw;
      border-right-width: 45vw;
      border-radius: 50%;
      background: #fff;
      background-clip: padding-box;
      opacity: 0;
      transition: opacity 50ms;
    }

    .main-header.hidden .main-header-indicator {
      opacity: 0.8;
      pointer-events: all;
    }
  </style>
  <style>
    .blog-page {
      margin: auto;
      overflow: hidden;
    }

    .content {
      margin: auto;
      padding: 0 18px 60px;
      width: 100%;
      max-width: 700px;
      font-family: var(--reading-font, sans-serif);
      font-size: 16px;
      line-height: 2.2;
      letter-spacing: 0.02em;
      color: #ddd;
      box-sizing: border-box;
    }

    .markdown>h1,
    .markdown>h2,
    .markdown>h3,
    .markdown>h4,
    .markdown>h5,
    .markdown>h6 {
      margin: 48px 0 36px;
      font-family: var(--display-font);
      font-weight: normal;
      font-style: italic;
      line-height: 1.6;
      letter-spacing: 0.04em;
      text-wrap: balance;
    }

    .markdown>h1 {
      text-align: center;
      font-size: 200%;
    }

    .markdown>h2 {
      font-size: 150%;
    }

    .markdown>h3,
    .markdown>h4,
    .markdown>h5,
    .markdown>h6 {
      font-size: 120%;
      font-weight: bold;
    }

    .markdown>p {
      margin: 36px 0;
    }

    .markdown .box-note>p {
      margin: 18px 0;
    }

    .markdown .box-note>p:first-child {
      margin-top: 0;
    }

    .markdown .box-note>p:last-child {
      margin-bottom: 0;
    }

    .markdown-table {
      margin: 0 -18px;
      /* bleed content padding */
      padding: 0 18px;
      /* bleed content padding */
      overflow-x: auto;
    }

    .markdown-table>table {
      min-width: 100%;
      box-sizing: border-box;
      border-collapse: collapse;
      background-color: var(--card-clr);
      border-radius: 12px;
    }

    .markdown-table>table th,
    .markdown-table>table td {
      min-width: min(25vw, 8ch);
      box-sizing: border-box;
      text-align: start;
      padding: 9px 6px;
      padding-inline-end: 18px;
      border-bottom: solid 1px #444;
    }

    .markdown-table>table th:first-child,
    .markdown-table>table td:first-child {
      padding-left: 12px;
    }

    .markdown-table>table th:last-child,
    .markdown-table>table td:last-child {
      padding-right: 12px;
    }

    .markdown-table>table>tbody>tr:last-child>td {
      border-bottom: none;
    }

    .markdown>hr {
      width: 36px;
      margin: 90px auto;
      border: solid 1.5px #ccc;
      background: #ccc;
      border-radius: 3px;
    }

    .markdown code:not([class]):not([class]) {
      display: inline-block;
      padding: 0 6px;
      border-radius: 6px;
      font-family: var(--default-font, monospace);
      font-size: 15px;
      background: var(--card-clr);
    }

    .markdown>pre:not([class])>code:not([class]) {
      display: block;
      padding: 18px;
      border-radius: 18px;
      line-height: 1.6;
      font-size: 15px;
      overflow-x: auto;
    }

    .markdown>blockquote {
      position: relative;
      margin: 0;
      padding: 18px 24px;
      border-radius: 18px;
      border: solid 1px var(--clr0);
      font-size: 21px;
    }

    .markdown>blockquote::before {
      content: "";
      position: absolute;
      right: 100%;
      top: 0;
      height: 24px;
      width: 24px;
      border-bottom: solid 1px var(--clr0);
      box-sizing: border-box;
    }

    .markdown>blockquote::after {
      content: "";
      position: absolute;
      right: 100%;
      top: 24px;
      bottom: 18px;
      width: 24px;
      border-top-right-radius: 24px;
      border: solid var(--clr0);
      border-width: 1px 1px 0 0;
      box-shadow: 9px 0 0 var(--bg-clr), 18px 0 0 var(--bg-clr);
      box-sizing: border-box;
    }

    .markdown>blockquote> :first-child {
      margin-top: 0;
    }

    .markdown>blockquote> :last-child {
      margin-bottom: 0;
    }

    .markdown>blockquote cite {
      display: block;
      margin-top: 12px;
      font-size: 15px;
      font-style: inherit;
    }

    .markdown>blockquote cite::before {
      content: "‚Äî";
    }

    .markdown>iframe,
    .markdown>p>iframe {
      max-width: calc(100vw - 18px);
      border: none;
      border-radius: 18px;
      background: #fff;
    }

    .markdown .center {
      text-align: center;
    }

    .markdown .center-flex {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* todo? convert to component <blog-bleed>, reuse across <blog-media> */
    .markdown .bleed {
      position: relative;
      left: 50%;
      width: 100vh;
      max-width: max(min(100vw, 800px), 80vw);
      transform: translateX(-50%);
    }

    /* todo: convert to component <caption>, reuse across <blog-media> */
    .markdown .caption {
      display: block;
      font-size: 15px;
    }
  </style>
  <style>
    .demo-row {
      margin: 18px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .demo-caption {
      max-width: 600px;
    }

    .drag-hint {
      padding: 0 0.3rem;
      font-weight: bold;
      border: dashed 2px #fff7;
      border-radius: 2rem;
    }

    .pair-legend {
      display: inline-block;
      position: relative;
      top: -4px;
      margin: 0 4px;
      width: 22px;
      height: 2px;
      background: currentColor;
    }

    .pair-legend::before,
    .pair-legend::after {
      content: "";
      position: absolute;
      top: -4px;
      display: block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: currentColor;
    }

    .pair-legend::before {
      left: -2px;
    }

    .pair-legend::after {
      right: -2px;
    }

    .edges-array {
      position: relative;
      width: 100%;
      height: 20px;
    }

    .edge {
      position: absolute;
      width: 10px;
      height: 20px;
      border: solid 3px #fff;
      box-sizing: border-box;
      transition: transform 0.2s;
    }

    .edge-left {
      border-right: 0;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
    }

    .edge-right {
      border-left: 0;
      border-top-right-radius: 10px;
      border-bottom-right-radius: 10px;
    }
  </style>
  <style>
    .eq-op {
      color: var(--clr0-light);
    }

    .eq-i {
      color: #e79907;
    }

    .eq-c {
      color: var(--clr1);
    }
  </style>
</head>


<body>

  <div class="page-wrapper">
    <header class="main-header">
      <div class="main-header-bar">
        <a href="/" class="main-header-item ">Home</a>
        <a href="/wares/" class="main-header-item ">Wares</a>
        <img class="main-header-icon" src="/icons/yay_sheet.png" alt="">
        <a href="/art/" class="main-header-item ">Art</a>
        <a href="/notes/" class="main-header-item select">Notes</a>
        <div class="main-header-indicator"></div>
      </div>
    </header>
    <div class="page-wrapper-content">

      <div class="blog-page">

        <div class="content">

          <!-- prettier-ignore -->
          <div class="markdown">
            <p>
            <div class="blog-header">
              <div class="text-with-bg blog-header-title" style="--text-with-bg-color: var(--bg-clr)">
                <h1 class="text-with-bg-span blog-header-title-inner">
                  Sort, sweep, and prune: a&nbsp;collision detection algorithm
                </h1>
              </div>
              <img srcset="/notes/_sweep-and-prune/hero_800.generated.jpg 800w,/notes/_sweep-and-prune/hero_1200.generated.jpg 1200w" sizes="not (min-width:800px) 800px, 1200px" class="blog-header-hero" src="/notes/_sweep-and-prune/hero.jpg" alt="" spec="100% [800) 80%">
              <svg xmlns="http://www.w3.org/2000/svg" class="blog-header-decor">
                <path></path>
              </svg>
            </div>
            </p>
            <p>
            <div class="blog-post-info ">
              8 Aug 2023 ¬∑ 17 min read
            </div>
            </p>
            <div class="tag-row">tags:
              <span class="tag-component" title="algorithm" style="background: rgb(107,251,250); color: rgb(9,125,124)">algo</span>
              <span class="tag-component" style="background: rgb(183,234,166); color: rgb(51,105,32)">games</span>
            </div>

            <p>This post is about a neat family of algorithms for detecting collisions among multiple objects.</p>
            <p>As you may know, the problem of collision detection is pretty common in video game programming. It‚Äôs a prerequisite to the implementation of certain game mechanics or simulations.</p>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="video of mario with goombas bumping into each other">
                <source src="/notes/_sweep-and-prune/mario.mp4">
                <a href="/notes/_sweep-and-prune/mario.mp4">video of mario with goombas bumping into each other</a>
              </video><span class="blog-media-caption">Goombas colliding</span>
            </div>
            </p>
            <p>Some of these mechanics include: preventing characters from passing through each other, <a target="_blank" class="text-link " href="https://youtu.be/Ky69PjyHCqg">goombas</a> turning around when bumping into another, big cells eating smaller cells in <a target="_blank" class="text-link " href="https://agar.io/">agar.io</a>, or just about any game physics. All of these need collision detection.</p>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="video of agar.io with cells eating smaller cells">
                <source src="/notes/_sweep-and-prune/agario.mp4">
                <a href="/notes/_sweep-and-prune/agario.mp4">video of agar.io with cells eating smaller cells</a>
              </video><span class="blog-media-caption">Cells consuming smaller cells on contact</span>
            </div>
            </p>
            <p>The specific problem I‚Äôm covering here involves detecting collisions between multiple objects. I‚Äôll go over several approaches, starting with the simplest and building up to the <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Sweep_and_prune"><strong>sweep-and-prune</strong></a> algorithm.</p>
            <p>Balls.</p>
            <p>I‚Äôll use this rigid-body ball simulation as a recurring example to demonstrate the algorithms throughout the post:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" strategy="sap-nativesort"></sap-demo-client>
            </div>

            <p>Alright, let‚Äôs dive in! How do we detect these collisions?</p>
            <h2 id="naive-approach-üê•">Naive approach üê•</h2>
            <p>The straightforward solution is to test every potential pair of balls for collision. That is, <em>check every ball against every other ball</em>.</p>
            <pre class="code-block"><code class="code-block-code"><span class="token comment">// for each ball</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ball1 <span class="token operator">=</span> balls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// check each of the other balls</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ball2 <span class="token operator">=</span> balls<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// check for collision</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intersects</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">bounce</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>Note in the above code that the inner loop starts at <code>i + 1</code>. This is to prevent duplicate pairs from being counted (A-B vs B-A). Other than that, it‚Äôs a pretty simple solution.</p>
            <p>These checks are done after every time step to ensure that balls will bounce exactly when they collide.</p>
            <p>Here‚Äôs a slowed-down, highlighted simulation. This shows pairs being tested for intersection per time step:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" strategy="pairwise" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <div class="demo-caption">
                Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when being tested via <code>intersects()</code>.
              </div>
            </div>

            <p>And it works. But if we had more than just a handful of balls we would start seeing performance issues.</p>
            <h2 id="performance-or-lack-thereof">Performance, or lack thereof</h2>
            <p>This naive algorithm runs in <em><strong>O(n<sup>2</sup>)</strong></em> time in <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Big_O_notation">Big O terms</a>. That is, for an input of <em>n</em> balls, the algorithm's run time grows proportionally to the <em>square</em> of the input <em>n</em>. That's a lot! üìà</p>
            <p>This is because for <em>n</em> balls, there are around <em>(n&nbsp;*&nbsp;(n-1))/2</em> pairs to test, or <em>0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n</em>. For example, if n = 5 there would be a total of 10 pairs. For n = 10, there would be 45 pairs. For n = 15, 105 pairs (!). And so on‚Ä¶ Using Big O notation, we can simplify this information into about the algorithm‚Äôs scalability by saying ‚ÄúThis runs in <em>O(n<sup>2</sup>) time</em>.‚Äù</p>
            <p>To (painfully) demonstrate how the performance scales badly for bigger inputs, here‚Äôs a simulation with n&nbsp;=&nbsp;20:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="20" strategy="pairwise" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <div class="demo-caption">
                20 balls = 190 pairs to test
              </div>
            </div>

            <p>That‚Äôs a lot of checks per frame! Clearly, the naive solution does not scale well for large numbers of objects.</p>
            <p>How can we improve the solution?</p>
            <span class="box-note ">
              <p>The worst case run time for <em>any</em> collision detection algorithm is always <em>O(n<sup>2</sup>)</em>. That‚Äôs when all objects intersect simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions.</p>
              <p>Thus, it‚Äôs more practical to compare the average and best cases.</p>
              <p>Having said that, the naive algorithm is still <em>Œò(n<sup>2</sup>)</em> for <em>any</em> case, no matter the number of actual collisions. There is a lot of room for improvement.</p>
            </span>

            <h2 id="prologue-improving-the-solution">Prologue: Improving the solution</h2>
            <p>Usually when optimising algorithms, you wanna find <strong>redundant or unnecessary work</strong>. Then find a way to consolidate or restructure that redundancy. (That sounded corporate-ish.)</p>
            <p>A good place to start would be the <code>intersects()</code> function since it is called for every candidate pair. If we take the <a target="_blank" class="text-link " href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html">typical object intersection test</a> as its implementation, we get a bunch of these <strong>inequality checks</strong>:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">function</span> <span class="token function">intersects</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// compare objects' bounds to see if they overlap</span>
  <span class="token keyword">return</span> object1<span class="token punctuation">.</span>left <span class="token operator">&lt;</span> object2<span class="token punctuation">.</span>right
      <span class="token operator">&amp;&amp;</span> object1<span class="token punctuation">.</span>right <span class="token operator">&gt;</span> object2<span class="token punctuation">.</span>left
      <span class="token operator">&amp;&amp;</span> object1<span class="token punctuation">.</span>top <span class="token operator">&lt;</span> object2<span class="token punctuation">.</span>bottom
      <span class="token operator">&amp;&amp;</span> object1<span class="token punctuation">.</span>bottom <span class="token operator">&gt;</span> object2<span class="token punctuation">.</span>top<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Define the structure just so we‚Äôre on the same page</span>
type Object <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">left</span><span class="token operator">:</span> number<span class="token punctuation">;</span>   <span class="token comment">// x-coordinate of left edge</span>
  <span class="token literal-property property">right</span><span class="token operator">:</span> number<span class="token punctuation">;</span>  <span class="token comment">// x-coordinate of right edge</span>
  <span class="token literal-property property">top</span><span class="token operator">:</span> number<span class="token punctuation">;</span>    <span class="token comment">// y-coordinate of top edge</span>
  <span class="token literal-property property">bottom</span><span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">// y-coordinate of bottom edge</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
            <p>In the above code, the <code>intersects()</code> function checks if two objects intersect by comparing opposing bounds from the two objects, for each dimension. (Refer to <a target="_blank" class="text-link " href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb">this MDN article</a> for a better explanation.)</p>
            <p>For now, let's focus on just one dimension, say <em>x</em>. Bear with me as I further scope down the check to just one <em>direction</em>:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">function</span> <span class="token function">intersects</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> object1<span class="token punctuation">.</span>right <span class="token operator">&gt;</span> object2<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>Don't worry; this scoped-down definition is a surprise tool that can help us later.</p>
            <p>
            <div class="blog-media blog-media-default">
              <img srcset="/notes/_sweep-and-prune/surprise-tool_285.generated.jpg 285w,/notes/_sweep-and-prune/surprise-tool_664.generated.jpg 664w" sizes="not (min-width:664px) 285px, 664px" class="blog-media-element" alt="Still of a cartoon mouse saying, 'that‚Äôs a surprise tool that can help us later'" src="/notes/_sweep-and-prune/surprise-tool.jpg" spec="100% [664) 664" loading="lazy" width="100%" height="" style="aspect-ratio: 1.2127659574468086; background: #080808">
            </div>
            </p>
            <p>Ok, the reason this will work is because of the <code>&amp;&amp;</code> operator's <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit evaluation</a>. That is, if any operand is false, then the whole expression becomes false. So if two objects do not overlap in the x-axis, then we can immediately rule them out as a candidate pair.</p>
            <p>So even an optimisation in just the x dimension will be a big help. And that‚Äôs what we‚Äôre gonna do.</p>
            <p>Let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in this configuration:</p>
            <p>
            <div class="blog-media blog-media-default">
              <img srcset="/notes/_sweep-and-prune/abc_527.generated.png 527w,/notes/_sweep-and-prune/abc_664.generated.png 664w" sizes="not (min-width:664px) 527px, 664px" class="blog-media-element" alt="Three objects, from left to right: A, B, and C" src="/notes/_sweep-and-prune/abc.png" spec="100% [664) 664" loading="lazy" width="100%" height="" style="aspect-ratio: 2.034749034749035; background: #f8f8f8">
            </div>
            </p>
            <p>There are three potential pairs to be checked here: A-B, B-C, and A-C. Pretend we‚Äôre running them through the redefined <code>intersects()</code> function, like so:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// returns false</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// returns false</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// returns false</span></code></pre>
            <p>Remember, we‚Äôre trying to find redundant work. Looking closer, if we inline the <code>intersects()</code> function (scoped to one x direction) we get:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token constant">A</span><span class="token punctuation">.</span>right <span class="token operator">&gt;</span> <span class="token constant">B</span><span class="token punctuation">.</span>left <span class="token comment">// returns false</span>
<span class="token constant">B</span><span class="token punctuation">.</span>right <span class="token operator">&gt;</span> <span class="token constant">C</span><span class="token punctuation">.</span>left <span class="token comment">// returns false</span>
<span class="token constant">A</span><span class="token punctuation">.</span>right <span class="token operator">&gt;</span> <span class="token constant">C</span><span class="token punctuation">.</span>left <span class="token comment">// returns false</span></code></pre>
            <p>See any redundant work? Maybe abstractify it a little‚Ä¶</p>
            <pre class="code-block"><code class="code-block-code"><span class="token constant">A</span> <span class="token operator">&gt;</span> <span class="token constant">B</span> <span class="token comment">// returns false</span>
<span class="token constant">B</span> <span class="token operator">&gt;</span> <span class="token constant">C</span> <span class="token comment">// returns false</span>
<span class="token constant">A</span> <span class="token operator">&gt;</span> <span class="token constant">C</span> <span class="token comment">// returns false</span></code></pre>
            <p>Voil√†. Due to the <strong>transitive property of inequality</strong>, we realise that we don‚Äôt need to run the third test! <em>If we know A&nbsp;&gt;&nbsp;B and B&nbsp;&gt;&nbsp;C are false, then we don't need to compute A&nbsp;&gt;&nbsp;C.</em></p>
            <p>So in this example, we don't really need to run <code>intersects(A, C)</code>. We‚Äôve skipped one check!</p>
            <pre class="code-block"><code class="code-block-code"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// returns false</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// returns false</span>
<span class="token comment">// I know intersects(A, C) will return false</span></code></pre>
            <p>You might be wondering how this contrived example could apply to general n-body collision detection. A smart reader such as you might also have realised that this skip only works if A, B, and C are in a particular order. Try <span class="drag-hint">dragging</span> the balls below to see when the optimisation applies and when it does not:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined sap-demo-draggable" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" id="abc-demo" balls="[[200,250,50],[300,150,55],[450,275,60]]" strategy="sap-nativesort" static="" draggable="" labels="A,B,C" rainbow=""></sap-demo-client>
              <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token comment">// LIVE OUTPUT:</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// A &gt; B returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// B &gt; C returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// A &gt; C returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C), A &gt; C will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
            </div>



            <p><span class="box-note "><strong>Tip:</strong> Drag the balls so that they‚Äôre in one of these orders: C‚ÄëB‚ÄëA and A‚ÄëB‚ÄëC</span></p>
            <p>While it‚Äôs true that this skip only works when A, B, and C are ordered, remember that these labels are <em>arbitrary</em>. What if we just decide to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable! üååüß†</p>
            <p>But wait‚Ä¶ labeling objects according to a defined order is essentially ‚ú®<strong>sorting</strong>‚ú®! What if we sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?</p>
            <h2 id="chapter-1-sorting">Chapter 1. Sorting</h2>
            <p>Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free.</p>
            <p>Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in <em>O(n log n)</em> time which is certainly better than <em>O(n<sup>2</sup>)</em> of the naive solution.</p>
            <p>As hinted by the tri-object example above, sorting the list of objects merely by their x position remove ranges of potential pairs that need to be tested.</p>
            <p>However, objects aren't zero-width points! They‚Äôre <em>widthy</em>, by which I mean having a size and occupying an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one definitively sort by x position if objects span intervals in the x-axis?</p>
            <h2 id="the-naive-solution-but-sorted">The naive solution, but sorted</h2>
            <p>A quick way to improve the naive approach and a solution to sorting widthy objects is to sort them by their <strong>minimum x</strong> (their left edge‚Äôs x-coordinate).</p>
            <p>This will afford us a chance to exit the inner loop early due to the sortedness of the list. I‚Äôll explain later.</p>
            <p>First, the code:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token comment">// sort by min x</span>
<span class="token function">sortByLeft</span><span class="token punctuation">(</span>balls<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// for each ball</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ball1 <span class="token operator">=</span> balls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// check each of the other balls</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ball2 <span class="token operator">=</span> balls<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// stop when too far away</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ball2<span class="token punctuation">.</span>left <span class="token operator">&gt;</span> ball1<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token comment">// check for collision</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intersects</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">bounce</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>It‚Äôs mostly the same as the naive solution, differing only in two extra lines of code. (These two juicy lines of code yield a maximum return of investment and is unlikely to be topped by anything else in this post.)</p>
            <p>The first line, at the very top before anything else, simply sorts the list.</p>
            <p>And in the inner loop, there is now this break:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">if</span> <span class="token punctuation">(</span>ball2<span class="token punctuation">.</span>left <span class="token operator">&gt;</span> ball1<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span></code></pre>
            <p>Let‚Äôs break that down.</p>
            <p>First, we know that the list is sorted, so the condition
              <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left</code>
              holds true for any positive integer
              <code class="eq-c">c</code>.
            </p>
            <p>Therefore, when
              <code>ball2.left <span class="eq-op">&gt;</span> ball1.right</code>
              or rather
              <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
              is true, then
              <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
              will also be true.
            </p>
            <p>In that case, the current ball2,
              <code>balls[<span class="eq-i">j</span>]</code>,
              and any further ball2s,
              <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>]</code>,
              do <em>not</em> intersect ball1. So we can skip the rest of ball2s in this loop and move on to the next ball1.
            </p>
            <p>Here‚Äôs a demo:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" strategy="simple-sap" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <div class="demo-caption">
                Pairs highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when tested by <code>intersects()</code>.
              </div>
            </div>

            <p>As you can see, only pairs that overlap in the x-axis are tested, resulting in much less processing per frame! üìâ</p>
            <p>Let‚Äôs analyse the time complexity!</p>
            <p>The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would add an <em>O(n log n)</em> term.</p>
            <p>The nested loops, now with an early break, would average out to <em>O(n + m)</em> where <em>m</em> is the total number of x-overlaps. This could degenerate into n<sup>2</sup> but as I said it‚Äôs better to look at the average and best cases. At best, the nested loops would be <em>O(n)</em>, wasting no excess processing if there are no collisions at all. On average it‚Äôs <em>O(n + m)</em>.</p>
            <p><span class="box-note ">The average case refers to a world where objects are mostly evenly distributed and only a couple intersections per object is happening. I think this is a reasonable assumption for a relatively simple video game like a platformer or side-scroller. (In any case, this post is open for more detailed analyses!)</span></p>
            <p>Here‚Äôs the code with run time annotations:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token comment">// O(n log n)</span>
<span class="token function">sortByLeft</span><span class="token punctuation">(</span>balls<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// O(n + m)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ball1 <span class="token operator">=</span> balls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> balls<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ball2 <span class="token operator">=</span> balls<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ball2<span class="token punctuation">.</span>left <span class="token operator">&gt;</span> ball1<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intersects</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">bounce</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>Adding those together, <em>n&nbsp;log&nbsp;n&nbsp;+&nbsp;n&nbsp;+&nbsp;m</em> we get <em><strong>O(n log n + m)</strong></em>. A big improvement over the naive approach‚Äôs <em>O(n<sup>2</sup>)</em>.</p>
            <p>Furthermore, the choice of sorting algorithm could be improved. Yes, there‚Äôs something better than an <em>n&nbsp;log&nbsp;n</em> sort in this case; we‚Äôll look into that later in this post!</p>
            <span class="box-note ">
              If you got this far trying to find a decent collision detection algorithm, then you can now stop reading and take the above code. It is the perfect balance between programming effort and runtime performance. If you want more data structures and algorithms or are curious how this develops or just want complicated things, read on.
            </span>

            <h2 id="proper-sweep-and-prune">Proper sweep-and-prune</h2>
            <p>The above was a simplified version of a one-dimensional sweep-and-prune algorithm. I believe the simplified versions‚Äôs time complexity would be about the same as the original‚Äôs but with a much smaller constant factor. In any case, let‚Äôs see how the original tackled the problem.</p>
            <p>First, sorting widthy objects.</p>
            <p>To account for the width of objects while keeping the benefits of unambiguous sort order, we track the left and the right edges of each object as two separate points!</p>
            <p>This is done by maintaining a separate <strong>array of edge points</strong> corresponding to the objects‚Äô left &amp; right edges.</p>
            <p>See how it works by playing with this <span class="drag-hint">draggable</span> demo. The left and right edges of each ball are visualised. These edge points are stored in a sorted array shown below the box.</p>
            <div class="demo-row">
              <sap-demo-client class="undefined sap-demo-draggable" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" id="edges-demo" balls="6" strategy="sap-nativesort" static="" draggable="" rainbow="" decorations="edges"></sap-demo-client>
              Sorted array of edges:
              <div class="edges-array" data-target="#edges-demo"></div>
            </div>

            <p>With that, we now have the minimal setup needed to optimise away unnecessary pairwise tests.</p>
            <p>Remember the <code>intersects()</code> function? Here it is with only the x-axis checks:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">function</span> <span class="token function">intersects</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> object1<span class="token punctuation">.</span>left <span class="token operator">&lt;</span> object2<span class="token punctuation">.</span>right
      <span class="token operator">&amp;&amp;</span> object1<span class="token punctuation">.</span>right <span class="token operator">&gt;</span> object2<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>We can replace these x-coordinate comparisons with a new approach, one based on array indices. Since we have a sorted array of every object's left and right points, finding overlaps can be done via index-based searches rather than global pairwise testing.</p>
            <p>Take one ball for example. When you have the indices of its left and right points, you can simply run through all points in between those two edges in the array to get all x-overlapping objects. This is a very fast linear operation.</p>
            <p>Try <span class="drag-hint">dragging</span> the <span style="color:#4c8">highlighted ball</span> below and observe the enclosed edges in the array:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined sap-demo-draggable" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" id="edges-demo-one" balls="6" strategy="sap-nativesort" static="" draggable="" decorations="edges:focus:#4c8:#d88"></sap-demo-client>
              Sorted array of edges:
              <div class="edges-array" data-target="#edges-demo-one"></div>
            </div>

            <p><span class="box-note ">One minor issue with the above 1-to-n approach is that an overlap can be missed if another ball is larger than the current ball. The larger ball can overlap the smaller ball without having any edge points inside of the smaller ball‚Äôs enclosure.</span></p>
            <p>The above is a simple 1-to-n overlap detection. For n-to-n overlap detection, it turns out there is a way to find them across all objects in a single pass!</p>
            <h2 id="chapter-2-sweeping">Chapter 2. Sweeping</h2>
            <p>To generalise the above to an n-interval overlap scan, imagine a vertical line sweeping across the whole space from left to right. The sweep will scan each edge point in-order, keeping track of the objects it touches.</p>
            <p>Let‚Äôs see what that looks like without collision:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="8" no-bounce="" strategy="sap-nativesort" skip-interval="4" decorations="sweep:#f00:#d88,edges"></sap-demo-client>
              <div class="demo-caption">
                Objects touching the line are lit up in <span style="color:#d88">pink</span>.
              </div>
            </div>

            <p>Whenever it runs into an object (a left edge), the object is added to a <span style="color:#d88"><code>touching</code></span> set to indicate being in contact with it.</p>
            <p>Likewise, whenever it exits an object (right edge), that object is removed from the set.</p>
            <p>As for the implementation, the line is merely a metaphor. It‚Äôs just a visualisation of the process of iterating through the sorted list of edges. Here‚Äôs the code for the actual sweeping:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">const</span> touching <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> edge <span class="token keyword">of</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>edge<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// entering an object</span>
    touching<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// exiting an object</span>
    touching<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>The <code>touching</code> set is the set of objects currently touching the sweeping line.</p>
            <p>Once we have the sweep and the <code>touching</code> set working, detecting overlaps is easy. Whenever line sweep line enters a new object (a left edge), we can mark it as overlapping with each of the current objects <code>touching</code> the line.</p>
            <p>Watch closely whenever the line enters a ball with a non-empty <code>touching</code>. Detected overlaps are highlighted:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="8" no-bounce="" strategy="sap-nativesort" skip-interval="6" decorations="sweep:#f00:#d88,edges,checks:#4bf:600"></sap-demo-client>
              <div class="demo-caption">
                X-overlapping pairs are highlighted <span aria-label="a connecting green line" style="color:#4bf" class="pair-legend"></span> as the line sweeps.
              </div>
            </div>

            <p>Here‚Äôs the updated code for detecting and reporting overlaps:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">const</span> touching <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> edge <span class="token keyword">of</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>edge<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// entering an object</span>
    
    <span class="token comment">// the new object is overlapping with the existing ones</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> other <span class="token keyword">of</span> touching<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onOverlapX</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    touching<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// exiting an object</span>
    touching<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <h2 id="chapter-3-pruning">Chapter 3. Pruning</h2>
            <p>So far we have an <code>onOverlapX()</code> that is called whenever two balls are overlapping in the x dimension. What about the other dimension, <em>y</em>? What if we‚Äôre working with 3D, how about <em>z</em>?</p>
            <p>Don‚Äôt worry; the sweep is just the broad-phase test, a way to <em>prune</em> candidate pairs in bulk. There will be a narrow-phase test, a more exact intersection test for each of the remaining pairs.</p>
            <p>What <code>onOverlapX()</code> is for is to hook up an exact intersection test like the full <code>intersects()</code> function earlier. Or, since we already know that the argument pair overlaps in x, we can just check y.</p>
            <pre class="code-block"><code class="code-block-code"><span class="token function-variable function">onOverlapX</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>object1<span class="token punctuation">.</span>top <span class="token operator">&lt;</span> object2<span class="token punctuation">.</span>bottom
   <span class="token operator">&amp;&amp;</span> object1<span class="token punctuation">.</span>bottom <span class="token operator">&gt;</span> object2<span class="token punctuation">.</span>top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">collide</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>While the above formula works for most games, a more precise and time-consuming check could be done at this level since most candidates have already been pruned. Our ball example would work better with the following circle intersection test using the <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance formula</a>:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token function-variable function">onOverlapX</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> distance <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>
      Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>object1<span class="token punctuation">.</span>x <span class="token operator">-</span> object2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>object1<span class="token punctuation">.</span>y <span class="token operator">-</span> object2<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;</span> object1<span class="token punctuation">.</span>radius <span class="token operator">+</span> object2<span class="token punctuation">.</span>radius<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bounce</span><span class="token punctuation">(</span>object1<span class="token punctuation">,</span> object2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>Finally, implement <code>bounce()</code> using physically-based physics, and we get a pretty fast ball simulation:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="6" strategy="sap-nativesort" skip-interval="2" decorations="checks:#4c8"></sap-demo-client>
              <div class="demo-caption">
                Ball sim using sweep-and-prune. <code>onOverlapX()</code> calls highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
              </div>
            </div>

            <p>A nice and elegant algorithm, it is.</p>
            <p><span class="box-note ">The sweep-and-prune algorithm is also known as sort-and-sweep.</span></p>
            <h3 id="note-for-3d">Note for 3D</h3>
            <p>There is a variant which performs the sweep for each axis, not just the x. It maintains <em>separate</em> sorted lists of edges, <strong>one for each axis</strong>. Indeed, this is how the full sweep-and-prune implementation works as described in the <a target="_blank" class="text-link " href="https://ecommons.cornell.edu/handle/1813/7115">original paper by D. Baraff</a>. Object pairs are then flagged for overlaps in each dimension separately. Then, pairs flagged thrice would be considered intersecting in 3D. In the case of 2D, pairs flagged twice are intersecting.</p>
            <p>You can even mix it up with respect to the broad-phase and narrow-phase split. Say you have a 3D world, you can do sweeps in the x- and z-axes, then perform exact tests in y.
              l
              This is how the full sweep-and-prune version gets an advantage over the simplified ‚Äúsorted pairwise‚Äù version. It can prune in multiple dimensions!</p>
            <h2 id="performance-of-sweep-and-prune">Performance of sweep-and-prune</h2>
            <p>Here‚Äôs side-by-side comparison of every strategy we‚Äôve covered so far! Observe the amount of intersection checks required per frame.</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="6" strategy="pairwise" skip-interval="2" decorations="checks:#cbb:30"></sap-demo-client>
              <div class="demo-caption">Global pairwise</div>
            </div>

            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="6" strategy="simple-sap" skip-interval="2" decorations="checks:#bcb:30"></sap-demo-client>
              <div class="demo-caption">Simplified sweep and prune, ‚Äúsorted pairwise‚Äù</div>
            </div>

            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="6" strategy="sap-nativesort" skip-interval="2" decorations="checks:#bcb:30"></sap-demo-client>
              <div class="demo-caption">1D sweep and prune</div>
            </div>

            <p>Let‚Äôs analyse the time complexity!</p>
            <p>The sort step, again, is <em>O(n log n)</em>.</p>
            <p>The sweep, which is a linear pass with an inner loop for overlaps, should be <em>O(n&nbsp;+&nbsp;m)</em> in the average case. Again, <em>m</em> is the number of overlaps.</p>
            <pre class="code-block"><code class="code-block-code"><span class="token keyword">function</span> <span class="token function">sweepAndPrune</span><span class="token punctuation">(</span><span class="token parameter">edges</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// O(n log n)</span>
  <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> touching <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// O(n)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> edge <span class="token keyword">of</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>edge<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// zero at best; some constant on average; O(n) at worst</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> other <span class="token keyword">of</span> touching<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onOverlapX</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      touching<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      touching<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
            <p>This means sweep-and-prune is <em>O(n log n + m)</em> on average.</p>
            <p>That‚Äôs great, but it‚Äôs the same as simplified ‚Äúsorted pairwise‚Äù sweep-and-prune but with more code and state to keep tabs on. <em>Can we improve this?</em></p>
            <h2 id="small-detail-big-improvement">Small detail, big improvement</h2>
            <p>Again, let's ask the question: Where is redundant work being done here?</p>
            <p>Let‚Äôs look at the sort step, which is the bottleneck of the algorithm according to the analysis.</p>
            <p>The following is a visualisation of the sorting of the edges array, using an optimised <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a> (n&nbsp;log&nbsp;n):</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]" no-bounce="" strategy="sap-quicksort" skip-interval="3" decorations="edges:array:#f00:#0cf"></sap-demo-client>
              <div class="demo-caption">
                Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted. The fixed lines at the top are edge array positions, connected to actual ball edge x positions below. Line crossings signal incorrect order.
              </div>
            </div>

            <p>You can see that most of the time, the sort does nothing at all! The list is almost always <strong>already sorted from the previous frame</strong>.</p>
            <p>Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one step.</p>
            <p>Fortunately, the subject of sorting algorithms is well-researched. We‚Äôre dealing with a special state here, the state of being <em>nearly-sorted</em>. And one great choice for sorting nearly-sorted lists is <a target="_blank" class="text-link " href="https://en.wikipedia.org/wiki/Insertion_sort"><strong>insertion sort</strong></a>!</p>
            <p>Insertion sort has a run time of <em>O(n)</em> at best when the list is already sorted or nearly-sorted, and <em>O(n<sup>2</sup>)</em> at worst when the list is in reverse. We can argue that the average case is <strong>O(n)</strong> and that we almost never reach the worst case, since the list is almost always sorted due to the previous frame‚Äôs sort.</p>
            <p>Here‚Äôs insertion sort in action:</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]" no-bounce="" strategy="sap-insertionsort" skip-interval="3" decorations="edges:array:#f00:#0cf"></sap-demo-client>
              <div class="demo-caption">
                Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
              </div>
            </div>

            <p>By switching to insertion sort, we‚Äôve reduced the overall average run time of sweep-and-prune to <em>O(n + m)</em>. Note that this also applies to the simplified version, having a sort step as well.</p>
            <span class="box-note ">
              Due to the sweeping mechanism and the insertion sort, it‚Äôs important to consider the primary axis of sweep-and-prune. It should be the axis where objects are most widely distributed to minimize swaps and overlaps.
            </span>

            <h2 id="sweeps-and-swaps">Sweeps and swaps</h2>
            <p>There is yet another way to optimise this algorithm! In the insertion sort example above, you can observe that <span style="color:#f00">swaps</span> happen when and only when an edge point passes through another.</p>
            <p>An edge point passing through another can mean one of four things:</p>
            <div class="markdown-table">
              <table>
                <thead>
                  <tr>
                    <th>Case</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>R)‚Üî(L</code></td>
                    <td>R edge from the left swaps with a L edge from the right.</td>
                  </tr>
                  <tr>
                    <td><code>(L‚ÜîR)</code></td>
                    <td>L edge from the left swaps with a R edge from the right.</td>
                  </tr>
                  <tr>
                    <td><code>(L‚Üî(L</code></td>
                    <td>Edges of the same side L swap.</td>
                  </tr>
                  <tr>
                    <td><code>R)‚ÜîR)</code></td>
                    <td>Edges of the same side R swap.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>Each swap scenario can mean something significant. Let‚Äôs look into each one more closely. </p>
            <h3 id="case-r‚Üîl">case R)‚Üî(L</h3>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="Animation of a R edge swapping with a L edge">
                <source src="/notes/_sweep-and-prune/swap-rl.mp4">
                <a href="/notes/_sweep-and-prune/swap-rl.mp4">Animation of a R edge swapping with a L edge</a>
              </video>
            </div>
            </p>
            <p>When a right edge from the left swaps with a left edge from the right, we can infer that the corresponding balls are <strong>initiating an overlap</strong>.</p>
            <h3 id="case-l‚Üîr">case (L‚ÜîR)</h3>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="Animation of a L edge swapping with a R edge">
                <source src="/notes/_sweep-and-prune/swap-lr.mp4">
                <a href="/notes/_sweep-and-prune/swap-lr.mp4">Animation of a L edge swapping with a R edge</a>
              </video>
            </div>
            </p>
            <p>Conversely, when a left edge from the left swaps with a right edge from the right, the corresponding balls <strong>cease to overlap</strong>.</p>
            <h3 id="cases-l‚Üîl-and-r‚Üîr">cases (L‚Üî(L and R)‚ÜîR)</h3>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="Animation of a L edge swapping with a L edge">
                <source src="/notes/_sweep-and-prune/swap-ll.mp4">
                <a href="/notes/_sweep-and-prune/swap-ll.mp4">Animation of a L edge swapping with a L edge</a>
              </video>
            </div>
            </p>
            <p>Edges of the same polarity can swap without affecting the overlappedness of their corresponding balls. We can ignore these ones.</p>
            <p>Based on these swap events, we can reframe the mechanics of sweep-and-prune in a different perspective. Think of the <strong>sweep line</strong> and the <strong><code>touching</code></strong> set in a bottom-up way centred around swaps.</p>
            <p>A fun way to think about it is to pretend that a right edge is equivalent to a <em>local</em> version of the sweep line. In that sense, the right edge <em>is</em> the line sweeping over these other left edges.</p>
            <p>
            <div class="blog-media blog-media-default">
              <video class="blog-media-element" muted="" autoplay="" loop="" aria-label="Animation a line sweep vs animation of an edge swap">
                <source src="/notes/_sweep-and-prune/swap-as-sweep.mp4">
                <a href="/notes/_sweep-and-prune/swap-as-sweep.mp4">Animation a line sweep vs animation of an edge swap</a>
              </video><span class="blog-media-caption">An edge can be thought of as a local sweep line.</span>
            </div>
            </p>
            <p>Just as in a global sweep, where any left edge encountered will mark the ball as ‚Äútouching‚Äù; in right-edge-as-a-local-sweep version, any left edge <em>swapped</em> will mark its ball as overlapping with the right edge‚Äôs ball.</p>
            <p>In the global sweep, there is a global <code>touching</code> set keeping track of which balls are in contact with the sweep line. In local swaps, we keep track of overlaps <em>per ball</em>.</p>
            <p>Lastly, in the global sweep, a right edge means the end of contact with a ball that promptly gets removed from the <code>touching</code> set. In a local swap, a left edge passing over a right edge means the same thing and the corresponding balls are unmarked from being overlapping.</p>
            <p>Essentially, instead of a global sweep line, we do small local ‚Äúsweeps‚Äù around each ball. Swaps become mini-sweeps.</p>
            <p>Thus we arrive at the one-dimensional sweep-and-prune‚Äôs final form:</p>
            <pre class="code-block"><code class="code-block-code"><span class="token comment">// Insertion sort</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> edges<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token comment">// Swap</span>
    <span class="token punctuation">[</span>edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>edges<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>

    <span class="token comment">// --- Code up until this point is plain insertion sort ---</span>

    <span class="token comment">// These two edges have just swapped places, process it...</span>
    <span class="token keyword">const</span> edge1 <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> edge2 <span class="token operator">=</span> edges<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>edge1<span class="token punctuation">.</span>isLeft <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>edge2<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// case R-L ‚Üí L-R</span>
      <span class="token comment">// Mark as overlapping</span>
      overlapping<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">key</span><span class="token punctuation">(</span>edge1<span class="token punctuation">,</span> edge2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>edge1<span class="token punctuation">.</span>ball<span class="token punctuation">,</span> edge2<span class="token punctuation">.</span>ball<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>edge1<span class="token punctuation">.</span>isLeft <span class="token operator">&amp;&amp;</span> edge2<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// case L-R ‚Üí R-L</span>
      <span class="token comment">// Unmark as overlapping</span>
      overlapping<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token function">key</span><span class="token punctuation">(</span>edge1<span class="token punctuation">,</span> edge2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Report overlaps</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">]</span> <span class="token keyword">of</span> overlapping<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">onOverlapX</span><span class="token punctuation">(</span>ball1<span class="token punctuation">,</span> ball2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>It‚Äôs essentially insertion sort with certain logic hooked up.</p>
            <p>Let‚Äôs see it in action (though what you will see here is nothing new):</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" strategy="sap-swap" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
            </div>

            <p>While it behaves the same and has the same time complexity theoretically, I think practically it‚Äôs much more efficient in terms of processing speed. In video games where every frame has a processing budget, the raw speed matters, not just the scalability. The constant factor that gets omitted by Big O notation still matters.</p>
            <h2 id="quick-comparison">Quick comparison</h2>
            <p>(todo: benchmarks)</p>
            <div class="markdown-table">
              <table>
                <thead>
                  <tr>
                    <th>Algorithm</th>
                    <th>Average</th>
                    <th>Best</th>
                    <th>Space</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Global pairwise</td>
                    <td>O(n<sup>2</sup>)</td>
                    <td>O(n<sup>2</sup>)</td>
                    <td>O(1)</td>
                  </tr>
                  <tr>
                    <td>Sorted pairwise (quicksort)</td>
                    <td>O(n log n + m)</td>
                    <td>O(n log n)</td>
                    <td>O(1)</td>
                  </tr>
                  <tr>
                    <td>Sorted pairwise (insertion)</td>
                    <td>O(n + m)</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                  </tr>
                  <tr>
                    <td>Sweep-and-prune (quicksort)</td>
                    <td>O(n log n + m)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                  </tr>
                  <tr>
                    <td>Sweep-and-prune (insertion)</td>
                    <td>O(n + m)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                  </tr>
                  <tr>
                    <td>Sweep-and-prune (final)</td>
                    <td>O(n + m)</td>
                    <td>O(n)</td>
                    <td>O(n&nbsp;+&nbsp;m)</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>n = number of balls, m = number of collisions</p>
            <p>As always, the real measure of run time lies in real measurements on real hardware!</p>
            <p><img src="https://preview.redd.it/hqs9fcbor3z61.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=8aad431aefed7b4d80bc3667ac2472764b7322ac" alt="Stop doing algorithm analysis">
              <a target="_blank" class="text-link " href="https://www.reddit.com/r/ProgrammerHumor/comments/ncb11u/stop_doing_algorithm_analysis">from r/ProgrammerHumor</a>
            </p>
            <h2 id="appendix">Appendix</h2>
            <p>Things I‚Äôve noted or realised while writing this post:</p>
            <ul>
              <li>General algorithm design insights<ul>
                  <li>Pre-sorting a list can replace a bunch of inequality checks, and unlocks:<ul>
                      <li>Some power when linearly scanning over the list</li>
                      <li>Faster range / adjacency checks</li>
                      <li>(unrelated, but good to bring up) Binary search</li>
                    </ul>
                  </li>
                  <li>Different sorting algorithms have situational strengths.</li>
                </ul>
              </li>
              <li>Big O, while useful, can only go so far.</li>
              <li>I might need a frontend framework for my blog now, at least for the interactive demos.<ul>
                  <li>Vanilla JS is starting to get scary with bigger demos like these.</li>
                  <li><code>.mjs</code> is pretty good though.</li>
                </ul>
              </li>
            </ul>
            <p>Bonus demo, 25 balls! It‚Äôs a ball party ‚öΩ‚öæüèÄüèê</p>
            <div class="demo-row">
              <sap-demo-client class="undefined" data-rss="interactive" aria-label="interactive demo of the collision detection algorithm" balls="25" rainbow="" strategy="sap-swap"></sap-demo-client>
            </div>

          </div>

        </div>
      </div>

    </div>
    <footer class="main-footer">
      <div class="main-footer-content-part">
        <p class="main-footer-line">
          <a target="_self" class="main-footer-link" href="/">Home</a> ¬∑
          <a target="_self" class="main-footer-link" href="/wares/">Software</a> ¬∑
          <a target="_self" class="main-footer-link" href="/art/">Art</a> ¬∑
          <a target="_self" class="main-footer-link" href="/notes/">Notes</a> ¬∑
          <a target="_self" class="main-footer-link" href="/misc/">Misc</a>
        </p>
        <p class="main-footer-line">
          <img class="main-footer-signature" alt="" src="/icons/laptop_user.png" loading="lazy">
          ¬∑
          <a target="_self" class="main-footer-link" href="/guestbook/">Sign my guestbook</a>
        </p>
        <p class="main-footer-line">
          (C) 2023 Lean Rada.
          <a target="_blank" class="main-footer-link" href="https://github.com/Kalabasa/kalabasa.github.io">
            Source
          </a>
        </p>
      </div>
      <div class="main-footer-content-part">
        <h2 class="main-footer-links-heading">On the web</h2>
        <a target="_blank" class="main-footer-web-link" href="https://www.linkedin.com/in/leanrada/">
          <img class="main-footer-web-link-icon" alt="LinkedIn" src="/icons/linkedin.png" loading="lazy">
        </a>
        <a target="_blank" class="main-footer-web-link" href="https://codepen.io/kalabasa">
          <img class="main-footer-web-link-icon" alt="CodePen" src="/icons/codepen.png" loading="lazy">
        </a>
        <a target="_blank" class="main-footer-web-link" href="https://stackoverflow.com/users/3144156/kalabasa">
          <img class="main-footer-web-link-icon" alt="Stack Overflow" src="/icons/stackoverflow.png" loading="lazy">
        </a>
        <a target="_blank" class="main-footer-web-link" href="https://github.com/Kalabasa" rel="me">
          <img class="main-footer-web-link-icon" alt="GitHub" src="/icons/github.png" loading="lazy">
        </a>
        <h2 class="main-footer-links-heading">Webrings</h2>
        <p class="main-footer-line">
          <img class="main-footer-webring-icon" alt="" src="/icons/planet.png" loading="lazy">
          <a target="_blank" class="main-footer-link" href="http://geekring.net/">geekring.net</a>
          [<a target="_blank" class="main-footer-link" href="http://geekring.net/site/288/previous" aria-label="Previous site">‚Üê</a>
          <a target="_blank" class="main-footer-link" href="http://geekring.net/site/288/random" aria-label="Random site">‚Åô</a>
          <a target="_blank" class="main-footer-link" href="http://geekring.net/site/288/next" aria-label="Next site">‚Üí</a>
          <a target="_blank" class="main-footer-link" href="http://geekring.net/site/288/frameset" aria-label="Frameset browsing">‚ñ£</a>]
        </p>
        <p class="main-footer-line">
          <img class="main-footer-webring-icon" alt="" src="/icons/planet.png" loading="lazy">
          <a target="_blank" class="main-footer-link" href="https://cs.sjoy.lol/">CSS JOY</a>
          [<a target="_blank" class="main-footer-link" href="https://webri.ng/webring/cssjoy/previous?via=https%3A%2F%2Fleanrada.com" aria-label="Previous site">‚Üê</a>
          <a target="_blank" class="main-footer-link" href="https://webri.ng/webring/cssjoy/random?via=https%3A%2F%2Fleanrada.com" aria-label="Random site">‚Åô</a>
          <a target="_blank" class="main-footer-link" href="https://webri.ng/webring/cssjoy/next?via=https%3A%2F%2Fleanrada.com" aria-label="Next site">‚Üí</a>]
        </p>
      </div>
      <nebula-client class="main-footer-nebula" palette="#0ad591 #ff2b75 #ffb833 #0ad591 #0ad591 #4d4aff #0ad591" width="40" height="10">
        <canvas style="filter: contrast(1.5)"></canvas>
        <div class="nebula-noise"></div>
      </nebula-client>
      <a class="main-footer-top-btn" href="#top" aria-label="Back to top">^</a>
    </footer>
  </div>




  <script defer="" src="/scripts/blog-media.js"></script>
  <script defer="" src="/scripts/blog-header.js"></script>
  <script defer="" src="/scripts/main-footer-main-header.js"></script>
  <script defer="">
    const edgesArrays = document.querySelectorAll(".edges-array");

    for (const edgesArray of edgesArrays) {
      const target = document.querySelector(edgesArray.dataset.target);

      const edgeToElement = new Map();

      target.addEventListener(
        "sap-sort",
        throttle((event) => {
          const {
            edges
          } = event;
          const n = edges.length;

          if (edgeToElement.size === 0) {
            for (const edge of edges) {
              const edgeElement = document.createElement("div");
              edgeElement.classList.add("edge");
              edgeElement.classList.add(
                edge.dir < 0 ? "edge-left" : "edge-right"
              );
              edgeElement.style.display = "none";
              edgesArray.appendChild(edgeElement);
              edgeToElement.set(edge, edgeElement);
            }
          }

          const width = edgesArray.getBoundingClientRect().width;

          for (const [edge, edgeElement] of edgeToElement.entries()) {
            const index = edges.indexOf(edge);
            const x = width / 2 + 20 * (index - (n - 1) / 2);
            edgeElement.style.display = "block";
            edgeElement.style.borderColor = edge.ball.color;
            edgeElement.style.transform = `translateX(calc(${x}px - 50%))`;
          }
        })
      );
    }

    function throttle(func, ms = 100) {
      let lastTime = Date.now();
      return (...args) => {
        if (Date.now() - lastTime < ms) return;
        lastTime = Date.now();
        func(...args);
      };
    }
  </script>
  <script defer="">
    (() => {
      const abcDemo = document.querySelector("#abc-demo");
      const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
      const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
      const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
      const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
      const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");

      abcDemo.addEventListener("simulate", throttle((event) => {
        const [A, B, C] = event.balls;
        setText(intersectsAbReturn, String(A.x > B.x));
        setText(intersectsBcReturn, String(B.x > C.x));
        setText(intersectsAcReturn, String(A.x > C.x));
        const acRuns = (A.x > B.x) !== (B.x > C.x);
        setShow(intersectsAcRun, acRuns);
        setShow(intersectsAcSkip, !acRuns);
      }));

      function setText(elements, text) {
        for (const element of elements)
          if (element.textContent !== text)
            element.textContent = text;
      }

      function setShow(elements, show) {
        for (const element of elements)
          if ((element.offsetParent != null) !== show)
            element.style.display = show ? "block" : "none";
      }
    })();
  </script>
</body>
</html>