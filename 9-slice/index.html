<!DOCTYPE html>
<html>
  <title>9-slice CSS generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter&family=Nanum+Gothic+Coding&display=swap"
    rel="stylesheet"
  />
  <style>
    html {
      width: 100%;
      height: 100%;
      background: #141f2b;
      color: #ffffffdd;
      font-family: "Inter Tight", sans-serif;
      font-optical-sizing: auto;
    }
    body {
      display: grid;
      grid-template-rows: 1fr 1fr;
      grid-template-columns: 2fr 1fr;
      grid-template-areas:
        "editor preview"
        "editor code";
      width: 100%;
      height: 100%;
      margin: 0;
    }
    @media (max-width: 240mm) {
      .editor {
        min-height: 60vh;
      }
      body {
        height: auto;
        grid-template-rows: min-content min-content min-content;
        grid-template-columns: 1fr;
        grid-template-areas:
          "editor"
          "preview"
          "code";
      }
    }
    .editor {
      grid-area: editor;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      user-select: none;
    }
    .preview {
      grid-area: preview;
      display: flex;
      flex-wrap: wrap;
      align-items: start;
      align-content: start;
      background: #1a2531;
      overflow: hidden;
      user-select: none;
    }
    .code {
      grid-area: code;
      background: #1a2531;
      overflow: hidden;
    }

    .board_container {
      margin: calc(max(5mm, 30vmin - 15mm));
      flex: 1 1 auto;
      display: grid;
      place-content: center;
    }
    .board {
      position: relative;
      display: flex;
    }
    .board_image {
      image-rendering: pixelated;
      pointer-events: none;
    }

    .handle {
      width: 1px;
      height: 1px;
      position: absolute;
      background: #24ffe2;
    }
    .active_handle {
      z-index: 9999;
    }
    .handle::after {
      content: "";
      position: absolute;
      width: 10mm;
      height: 10mm;
      left: -5mm;
      top: -5mm;
      border-radius: 5mm;
      background: #24ffe2;
      opacity: 0;
    }
    .handle:hover::after {
      opacity: 0.1;
    }
    .active_handle.handle::after {
      opacity: 0.2;
      cursor: grabbing;
    }
    :root:has(.active_handle) {
      cursor: grabbing !important;
    }

    .handle_x {
      height: 100%;
      cursor: ew-resize;
    }
    .handle_x::after {
      top: -5mm;
      height: 100%;
      padding: 5mm 0;
    }

    .handle_y {
      width: 100%;
      cursor: ns-resize;
    }
    .handle_y::after {
      left: -5mm;
      width: 100%;
      padding: 0 5mm;
    }

    .preview_box_container {
      display: inline-block;
      padding: 1em;
      overflow: hidden;
      resize: both;
      max-width: 100%;
      max-height: 100%;
    }
    .preview_box {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      overflow: hidden;
      color: #fff;
      text-shadow: 0.08em 0.08em 0.04em #000;
    }

    .preview_box_container:nth-child(1),
    .preview_box_container:nth-child(2) {
      height: 15em;
    }
    .preview_box_container:nth-child(1),
    .preview_box_container:nth-child(3) {
      width: 15em;
    }

    .code_content {
      display: block;
      margin: 1em;
      padding: 1em;
      border-radius: 1em;
      box-shadow: 0 1em 1em #0002 inset;
      background: #141f2b;
      font-family: "Nanum Gothic Coding", monospace;
    }
    .code_content pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
  <body>
    <div class="editor">
      <div class="board_container">
        <div class="board">
          <img class="board_image" src="example.png" />
          <div class="handle handle_y"></div>
          <div class="handle handle_y"></div>
          <div class="handle handle_x"></div>
          <div class="handle handle_x"></div>
        </div>
      </div>
      <input class="upload_button" type="file" accept="image/*" />
    </div>
    <div class="preview">
      <div class="preview_box_container">
        <div class="preview_box">Preview</div>
      </div>
      <div class="preview_box_container">
        <div class="preview_box">Preview</div>
      </div>
      <div class="preview_box_container">
        <div class="preview_box">Preview</div>
      </div>
    </div>
    <div class="code">
      <code class="code_content"><pre></pre></code>
    </div>

    <script>
      const boardContainer = document.querySelector(".board_container");
      const boardImage = document.querySelector(".board_image");
      const handlesX = document.querySelectorAll(".handle_x");
      const handlesY = document.querySelectorAll(".handle_y");
      const previewBoxes = document.querySelectorAll(".preview_box");
      const codeContentPre = document.querySelector(".code_content pre");

      const slicesX = [...handlesX].map(() => 0);
      const slicesY = [...handlesY].map(() => 0);

      window.addEventListener("resize", resizeBoardImage);
      boardImage.addEventListener("load", () => {
        resetSlices();
        resizeBoardImage();
      });
      if (boardImage.complete) {
        resetSlices();
        resizeBoardImage();
      }

      bindSliceDrag(handlesX[0], (x, y) => (slicesX[0] = x));
      bindSliceDrag(handlesX[1], (x, y) => (slicesX[1] = x));
      bindSliceDrag(handlesY[0], (x, y) => (slicesY[0] = y));
      bindSliceDrag(handlesY[1], (x, y) => (slicesY[1] = y));

      function bindSliceDrag(handle, callback) {
        let dragState = null;

        handle.style.touchAction = "none";
        handle.addEventListener("dragstart", (event) => event.preventDefault());

        handle.addEventListener("pointerdown", (event) => {
          if (dragState) return;

          const handleRect = handle.getBoundingClientRect();
          dragState = {
            pointerID: event.pointerId,
            offsetX: handleRect.left - event.clientX,
            offsetY: handleRect.top - event.clientY,
          };

          handle.setPointerCapture(event.pointerId);
          handle.classList.add("active_handle");
        });

        const move = (event) => {
          if (!dragState) return;
          if (dragState.pointerID !== event.pointerId) return;

          const imageRect = boardImage.getBoundingClientRect();
          const x = clampRound(
            (event.clientX - imageRect.left + dragState.offsetX) *
              (boardImage.naturalWidth / boardImage.clientWidth),
            0,
            boardImage.naturalWidth
          );
          const y = clampRound(
            (event.clientY - imageRect.top + dragState.offsetY) *
              (boardImage.naturalHeight / boardImage.clientHeight),
            0,
            boardImage.naturalHeight
          );

          callback(x, y);
          renderSlices();
          recalculateResult();
        };

        const release = (event) => {
          if (!dragState) return;
          if (dragState.pointerID !== event.pointerId) return;

          dragState = null;
          handle.classList.remove("active_handle");
        };

        handle.addEventListener("pointermove", move);
        handle.addEventListener("pointerup", release);
        handle.addEventListener("pointercancel", release);
      }

      function resetSlices() {
        if (!boardImage.complete) return;

        const srcURL = new URL(boardImage.src);
        if (srcURL.pathname.split("/").pop() === "example.png") {
          slicesX[0] = 8;
          slicesX[1] = boardImage.naturalWidth - 11;
          slicesY[0] = 8;
          slicesY[1] = boardImage.naturalHeight - 11;
        } else {
          slicesX[0] = Math.ceil(boardImage.naturalWidth / 3);
          slicesX[1] = Math.floor(boardImage.naturalWidth * (2 / 3));
          slicesY[0] = Math.ceil(boardImage.naturalHeight / 3);
          slicesY[1] = Math.floor(boardImage.naturalHeight * (2 / 3));
        }

        renderSlices();
        recalculateResult();
      }

      function renderSlices() {
        if (!boardImage.complete) return;

        for (let i = 0; i < 2; i++) {
          handlesX[i].style.left =
            slicesX[i] * (boardImage.clientWidth / boardImage.naturalWidth) +
            "px";
          handlesY[i].style.top =
            slicesY[i] * (boardImage.clientHeight / boardImage.naturalHeight) +
            "px";
        }
      }

      function resizeBoardImage() {
        if (!boardImage.complete) return;

        if (
          boardImage.naturalWidth / boardImage.naturalHeight >
          boardContainer.clientWidth / boardContainer.clientHeight
        ) {
          boardImage.style.width = boardContainer.clientWidth + "px";
          boardImage.style.height =
            boardContainer.clientWidth *
              (boardImage.naturalHeight / boardImage.naturalWidth) +
            "px";
        } else {
          boardImage.style.height = boardContainer.clientHeight + "px";
          boardImage.style.width =
            boardContainer.clientHeight *
              (boardImage.naturalWidth / boardImage.naturalHeight) +
            "px";
        }

        renderSlices();
      }

      function recalculateResult() {
        const css = cssGenerator();

        const imageURL = boardImage.src;
        const borderImageSource = `url('${imageURL}')`;

        renderPreview(css(borderImageSource));
        renderCode(css("url('<image>')"));
      }

      function cssGenerator() {
        const [sliceLeftX, sliceRightX] = slicesX.toSorted(ascendingNumbers);
        const [sliceTopY, sliceBottomY] = slicesY.toSorted(ascendingNumbers);

        const sliceInsets = [
          sliceTopY,
          boardImage.naturalWidth - sliceRightX,
          boardImage.naturalHeight - sliceBottomY,
          sliceLeftX,
        ];

        const backgroundSizeFactorX =
          boardImage.naturalWidth / (sliceRightX - sliceLeftX);
        const backgroundSizeFactorY =
          boardImage.naturalHeight / (sliceBottomY - sliceTopY);

        // algebra somehow produced this formula
        const backgroundPositionTermX =
          sliceLeftX / (boardImage.naturalWidth - sliceRightX + sliceLeftX);
        const backgroundPositionTermY =
          sliceTopY / (boardImage.naturalHeight - sliceBottomY + sliceTopY);

        return (imageSource) => ({
          borderImage: [
            imageSource,
            ...sliceInsets,
            "/",
            ...sliceInsets.map((inset) => inset + "px"),
          ].join(" "),
          padding: sliceInsets.map((inset) => inset + "px").join(" "),
          background: [
            imageSource,
            cssPercentage(backgroundPositionTermX),
            cssPercentage(backgroundPositionTermY),
            "/",
            cssPercentage(backgroundSizeFactorX),
            cssPercentage(backgroundSizeFactorY),
            "border-box",
            "content-box",
            "no-repeat",
          ].join(" "),
        });
      }

      function renderPreview(css) {
        for (const box of previewBoxes) {
          Object.assign(box.style, css);
        }
      }

      function renderCode(css) {
        codeContentPre.textContent = [
          "div {",
          ...Object.entries(css).map(
            ([key, value]) => `  ${kebabCase(key)}: ${value};`
          ),
          "}",
        ].join("\n");
      }

      function clampRound(x, min, max) {
        return Math.round(Math.min(max, Math.max(min, x)));
      }

      function cssPercentage(fraction) {
        return Math.round(fraction * 100e2) / 1e2 + "%";
      }

      function kebabCase(camelCase) {
        return camelCase.replaceAll(/([a-z])([A-Z])/g, (_, a, b) =>
          `${a}-${b}`.toLocaleLowerCase()
        );
      }

      function ascendingNumbers(a, b) {
        return a - b;
      }
    </script>
  </body>
</html>
