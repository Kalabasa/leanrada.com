<div
  class="switch-sim"
  data-rss="interactive"
  alt="interactive simulation of a mechanical switch"
>
  <div class="switch-sim-render">
    <canvas />
  </div>
  <div class="switch-sim-graph">
    <canvas />
  </div>
</div>

<style>
  .switch-sim-render canvas {
    width: 100%;
    aspect-ratio: 4 / 3;
  }
</style>

<script type="module" client async defer>
  import { SwitchSim } from "/notes/_stop-using-ease-out/switch-sim/switch-sim.mjs";

  // todo WebComponent
  // todo show-forces
  // todo show-graph
  // todo timescale

  const simElements = document.querySelectorAll(".switch-sim");

  for (const simElement of simElements) {
    const switchSim = new SwitchSim();
    const renderCanvas = simElement.querySelector(".switch-sim-render canvas");
    renderCanvas.addEventListener("pointermove", (event) => {
      const side =
        event.offsetX > renderCanvas.offsetWidth * 0.5 ? "on" : "off";
      const x =
        Math.abs(event.offsetX - renderCanvas.offsetWidth * 0.5) /
        (renderCanvas.offsetWidth * 0.5);
      const y = event.offsetY / renderCanvas.offsetHeight;
      const value = x + Math.min(x * 3, y * 2);
      switchSim.presserSide = side;
      switchSim.presserValue = value;
    });
    loop(Date.now(), switchSim, renderCanvas);
  }

  /**
   * @param {number} lastTime
   * @param {SwitchSim} sim
   * @param {HTMLCanvasElement} canvas
   */
  function loop(lastTime, sim, canvas) {
    const now = Date.now();
    sim.update((now - lastTime) / 1000);
    renderSim(sim, canvas);
    requestAnimationFrame(() => {
      loop(now, sim, canvas);
    });
  }

  /**
   * @param {SwitchSim} sim
   * @param {HTMLCanvasElement} canvas
   */
  function renderSim(sim, canvas) {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    const drawSize = Math.min(canvas.width, canvas.height);
    const unit = drawSize / 6;
    const cm = unit;

    const cc = canvas.getContext("2d");

    const hinge = {
      x: canvas.width / 2,
      y: (canvas.height + (sim.switchArmLength - sim.springDistance) * cm) / 2,
    };

    cc.fillStyle = "#129";
    cc.strokeStyle = "#fff";
    cc.lineCap = "round";
    cc.lineJoin = "round";
    cc.lineWidth = 1;
    cc.fillRect(0, 0, canvas.width, canvas.height);

    // hinge
    cc.beginPath();
    cc.ellipse(hinge.x, hinge.y, unit * 0.02, unit * 0.02, 0, 0, Math.PI * 2);
    cc.stroke();

    // pads
    const padAngleOffset = Math.PI * 0.7;
    const padAngularThickness = 0.8;
    const padThickness =
      sim.switchArmLength *
      cm *
      Math.sin(padAngleOffset - padAngularThickness) *
      0.3;
    const pad1Angle = sim.switchAngle + padAngleOffset;
    const pad2Angle = sim.switchAngle - padAngleOffset;
    const pad1End = {
      angle: pad1Angle,
      x: hinge.x + sim.switchArmLength * cm * Math.sin(pad1Angle),
      y: hinge.y + sim.switchArmLength * cm * Math.cos(pad1Angle),
    };
    const pad2End = {
      angle: pad2Angle,
      x: hinge.x + sim.switchArmLength * cm * Math.sin(pad2Angle),
      y: hinge.y + sim.switchArmLength * cm * Math.cos(pad2Angle),
    };
    cc.beginPath();
    cc.moveTo(
      hinge.x - padThickness * Math.sin(sim.switchAngle),
      hinge.y - padThickness * Math.cos(sim.switchAngle)
    );
    cc.arc(
      hinge.x,
      hinge.y,
      sim.switchArmLength * cm,
      Math.PI / 2 - pad1Angle,
      Math.PI / 2 - pad1Angle + padAngularThickness
    );
    cc.arc(
      hinge.x,
      hinge.y,
      sim.switchArmLength * cm,
      Math.PI / 2 - pad2Angle - padAngularThickness,
      Math.PI / 2 - pad2Angle
    );
    cc.lineTo(
      hinge.x - padThickness * Math.sin(sim.switchAngle),
      hinge.y - padThickness * Math.cos(sim.switchAngle)
    );
    cc.stroke();

    // pin
    const pinEnd = {
      x: hinge.x + sim.pin.x * cm,
      y: hinge.y + sim.pin.y * cm,
    };
    cc.beginPath();
    cc.moveTo(hinge.x, hinge.y);
    cc.lineTo(pinEnd.x, pinEnd.y);
    cc.stroke();

    // spring base
    const springBase = {
      x: hinge.x,
      y: hinge.y + sim.springDistance * cm,
    };
    cc.beginPath();
    cc.ellipse(
      springBase.x,
      springBase.y,
      unit * 0.02,
      unit * 0.02,
      0,
      0,
      Math.PI * 2
    );
    cc.stroke();

    // spring
    cc.beginPath();
    cc.moveTo(springBase.x, springBase.y);
    const coils = Math.ceil(sim.springNaturalLength * 15) + 1;
    for (let i = 0; i < coils; i++) {
      const t = lerp(i / coils, 0.5, 0.5);
      const x = lerp(springBase.x, pinEnd.x, t);
      const y = lerp(springBase.y, pinEnd.y, t);
      const coilAngle = Math.PI * (1 + (i % 2));
      cc.ellipse(
        x,
        y,
        cm / 8,
        cm / 12,
        sim.switchAngle,
        coilAngle - Math.PI * 0.25,
        coilAngle + Math.PI * 0.5
      );
    }
    cc.lineTo(pinEnd.x, pinEnd.y);
    cc.stroke();

    // presser
    const presserRadius = 0.5 * cm;
    const pressedPad = sim.presserSide === "on" ? pad1End : pad2End;
    cc.beginPath();
    cc.moveTo(pressedPad.x - presserRadius, 0);
    cc.lineTo(
      pressedPad.x - presserRadius,
      pressedPad.y + sim.presser.yOffset * cm - presserRadius * 2
    );
    cc.arc(
      pressedPad.x,
      pressedPad.y + sim.presser.yOffset * cm - presserRadius,
      presserRadius,
      Math.PI,
      Math.PI * 2,
      true
    );
    cc.lineTo(
      pressedPad.x + presserRadius,
      pressedPad.y + sim.presser.yOffset * cm - presserRadius * 2
    );
    cc.lineTo(pressedPad.x + presserRadius, 0);
    cc.stroke();

    // case
    cc.strokeStyle = "#fff4";
    cc.beginPath();
    cc.moveTo(hinge.x - (sim.switchArmLength + 1) * cm, hinge.y);
    cc.lineTo(hinge.x + (sim.switchArmLength + 1) * cm, hinge.y);
    cc.stroke();

    // spring force
    const springDir = {
      x: pinEnd.x - springBase.x,
      y: pinEnd.y - springBase.y,
    };
    const springDirDiv = Math.hypot(springDir.x, springDir.y);
    springDir.x /= springDirDiv;
    springDir.y /= springDirDiv;
    const pinDir = {
      x: pinEnd.x - hinge.x,
      y: pinEnd.y - hinge.y,
    };
    const pinDirDiv = Math.hypot(pinDir.x, pinDir.y);
    pinDir.x /= pinDirDiv;
    pinDir.y /= pinDirDiv;
    cc.strokeStyle = "#f00";
    cc.lineWidth = 4;
    strokeArrow(
      cc,
      pinEnd.x,
      pinEnd.y,
      pinEnd.x + springDir.x * sim.springForce * unit,
      pinEnd.y + springDir.y * sim.springForce * unit,
      unit / 8
    );
    cc.strokeStyle = "#f00";
    cc.lineWidth = 2;
    cc.beginPath();
    cc.moveTo(
      pinEnd.x + springDir.x * sim.springForce * unit,
      pinEnd.y + springDir.y * sim.springForce * unit
    );
    cc.lineTo(
      pinEnd.x - pinDir.y * sim.tangentialSpringForce * unit,
      pinEnd.y + pinDir.x * sim.tangentialSpringForce * unit
    );
    cc.stroke();
    cc.strokeStyle = "#ff0";
    cc.lineWidth = 4;
    strokeArrow(
      cc,
      pinEnd.x,
      pinEnd.y,
      pinEnd.x - pinDir.y * sim.tangentialSpringForce * unit,
      pinEnd.y + pinDir.x * sim.tangentialSpringForce * unit,
      unit / 8
    );

    // presser force
    const sideFactor = sim.presserSide === "off" ? -1 : 1;
    cc.strokeStyle = "#0ff";
    cc.lineWidth = 4;
    strokeArrow(
      cc,
      pressedPad.x,
      pressedPad.y,
      pressedPad.x -
        Math.cos(pressedPad.angle) * sideFactor * sim.presserForce * unit,
      pressedPad.y +
        Math.sin(pressedPad.angle) * sideFactor * sim.presserForce * unit,
      unit / 8
    );
    // presser normal force
    cc.strokeStyle = "#ff0";
    strokeArrow(
      cc,
      pressedPad.x,
      pressedPad.y,
      pressedPad.x -
        Math.cos(pressedPad.angle) *
          sideFactor *
          -sim.presserNormalForce *
          unit,
      pressedPad.y +
        Math.sin(pressedPad.angle) *
          sideFactor *
          -sim.presserNormalForce *
          unit,
      unit / 8
    );
  }

  /**
   * @param {CanvasRenderingContext2D} cc
   */
  function strokeArrow(cc, x, y, x2, y2, headSize) {
    const dx = x2 - x;
    const dy = y2 - y;
    const d = Math.hypot(dx, dy) + 1e-12;
    const nx = dx / d;
    const ny = dy / d;
    headSize = Math.min(d / 2, headSize);
    cc.beginPath();
    cc.moveTo(x, y);
    cc.lineTo(x2, y2);
    cc.lineTo(
      x2 + (-ny * 0.5 - nx) * headSize,
      y2 + (nx * 0.5 - ny) * headSize
    );
    cc.moveTo(x2, y2);
    cc.lineTo(
      x2 + (ny * 0.5 - nx) * headSize,
      y2 + (-nx * 0.5 - ny) * headSize
    );
    cc.stroke();
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }
</script>
