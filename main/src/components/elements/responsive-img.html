<script render>
  const imgAttrs = await generateImages(attrs.src, attrs.spec);
  return html`<img {...attrs} srcset="${imgAttrs.srcset ?? ''}" sizes="${imgAttrs.sizes ?? ''}" />`;
</script>

<script static>
  const fs = require("node:fs");
  const path = require("node:path");
  const process = require("node:process");
  const sharp = require("sharp");
  const {
    getResponsiveRules,
    toMediaQuery,
  } = require("../../lib/responsive_spec.js");
  const { getImageAnalysis } = require("../../lib/image_analysis.js");

  const prod = process.env.NODE_ENV === "production";

  const intermediateStepSize = 800;
  const globalMaxImageSize = 1400;

  async function generateImages(src, spec) {
    if (!prod) return {};

    const srcFilePath = path.join(__outputDir, src);
    if (!fs.existsSync(srcFilePath)) {
      throw new Error(
        `Responsive image does not exist. src:'${src}'. Expected filePath:'${srcFilePath}'`
      );
    }

    const image = await fs.promises.readFile(srcFilePath);
    const { width: imageWidth } = await getImageAnalysis(srcFilePath, src);

    const rules = getResponsiveRules(
      spec,
      Math.min(imageWidth, globalMaxImageSize)
    );

    const srcset = [];
    const sizes = [];

    for (const rule of rules) {
      const resizedImageSrc = getResizedImageSrc(src, rule.size.value);
      srcset.push(`${resizedImageSrc} ${rule.size.value}w`);
      sizes.push(
        `${toMediaQuery(rule, sizes.length > 0)} ${rule.size.value}px`
      );
      // no await. generate images in the background
      generateImage(image, rule.size.value, src, resizedImageSrc);
    }

    return {
      srcset: srcset.join(","),
      sizes: sizes.join(","),
    };
  }

  async function generateImage(image, width, src, resizedImageSrc) {
    const srcFilePath = path.join(__outputDir, src);
    const outPath = path.join(__outputDir, resizedImageSrc);

    if (fs.existsSync(outPath)) {
      const outStats = fs.statSync(outPath);
      if (outStats.isFile()) {
        const srcStats = fs.statSync(srcFilePath);
        if (outStats.mtimeMs >= srcStats.mtimeMs) return;
      }
    }

    const sharpObj = sharp(image);
    const metadata = await sharpObj.metadata();
    const size = metadata.size * (width / metadata.width) ** 2;
    const quality = Math.round(
      clamp(map(size, 20_000, 400_000, 90, 70), 70, 90)
    );

    if (metadata.format === "jpeg") {
      sharpObj.jpeg({ mozjpeg: true, quality });
    } else if (metadata.format === "png") {
      sharpObj.png({ quality });
    }

    console.log("Resizing", src, "â†’", resizedImageSrc, `(q:${quality})`);
    await fs.promises.mkdir(path.dirname(outPath), { recursive: true });
    await sharpObj.resize(width).toFile(outPath);
  }

  function getResizedImageSrc(src, width) {
    const ext = path.extname(src);
    const baseName = path.basename(src, ext);
    return path.join(path.dirname(src), `${baseName}_${width}.generated${ext}`);
  }

  function clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  }

  function map(v, a, b, c, d) {
    return c + (d - c) * ((v - a) / (b - a));
  }
</script>
