<html lang="en">
  <page-title title="Compressing a website into a URL" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Compressing a website into a URL"
        :heroimgsrc="url('hero.png')" />

      <blog-post-info date="10 Oct 2023" read-mins="1" />

      This post explains how [**portabl.ink**](https://portabl.ink) works. Portablink is a tool that creates self-contained compressed webpages in a single link. Check [portablink project page](/wares/portabl.ink/) for more info.

      tl;dr: It uses **data URLs** containing **compressed data** along with its **decompression instructions**.

      ## Data URLs

      In case you arenâ€™t familiar with [**data URLs**](https://en.wikipedia.org/wiki/Data_URI_scheme), they are URLs whose contents are in the URL itself. They all start with `data:`. Here, let me show you with this interactive mock browser:

      <window-decor>
        <div class="browser">
          <div class="browser-bar">
            <button id="browserHomeButton" class="browser-bar-button">ðŸ›–</button>
            <input id="dataURLInput" class="browser-address" type="text" value="data:text/html,<i>Hello</i><b>World!</b>" />
            <button id="browserCopyButton" class="browser-bar-button">ðŸ“‹</button>
          </div>
          <iframe id="dataURLFrame" class="browser-viewport"></iframe>
        </div>
      </window-decor>

      _(Hint: edit the URL in the address bar!)_

      <script client async defer>
        (()=>{
          const input = document.getElementById("dataURLInput");
          const frame = document.getElementById("dataURLFrame");
          const home = document.getElementById("browserHomeButton");
          const copy = document.getElementById("browserCopyButton");
          
          input.addEventListener("focus", () => setTimeout(() => {
            const rect = frame.getBoundingClientRect();
            if (rect.bottom > window.innerHeight) {
              frame.parentElement.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          }));
          input.addEventListener("input", refresh);
          input.addEventListener("change", refresh);
          home.addEventListener("click", () => {
            input.value = input.getAttribute("value");
            refresh();
          });
          copy.addEventListener("click", async () => {
            await navigator.clipboard?.writeText(input.value);
            alert("URL copied!");
          });
          refresh();
          
          function refresh() {
            const isDataURL = input.value.startsWith("data:");

            if (!isDataURL) {
              alert("No cheating! Enter a data URL only");
              input.value = "data:text/html,";
            }

            frame.src = input.value;
          }
        })();
      </script>

      <style>
        .browser {
          display: flex;
          flex-direction: column;
          gap: 12px;
          width: 100%;
          box-sizing: border-box;
        }

        .browser-bar {
          display: flex;
          gap: 6px;
          padding: 0 6px;
        }

        .browser-bar-button {
          border: none;
          border-radius: 3px;
          font-size: 10px;
          width: 30px;
          background: none;
          color: transparent;
          text-shadow: 0 0 #fff;
          cursor: pointer;
        }
        .browser-bar-button:focus-visible,
        .browser-bar-button:hover {
          background: #fff2;
        }

        .browser-address {
          flex: 1 1 auto;
          border: none;
          border-radius: 3px;
          padding: 6px;
          background: #0004;
          color: #fff;
          font-family: system-ui;
        }
        
        .browser-viewport {
          border: none;
        }
      </style>

      When you load a data URL, the browser shows the content embedded in the URL directly.

      OK, thatâ€™s it then! Website in a URL? - Data URL! Easy!
      
      Wait, thereâ€™s more! The portablink tool does some more things than just putting your HTML in a data URL. The tool also **compresses** your content so you donâ€™t end up with humongous URLs.

      ## Compression

      Within a data URL, the tool bundles both the compressed data _and_ the instructions needed to decompress and bootstrap that data. This produces a self-contained, compressed document in a single portable link that can be decompressed and rendered by any browser.

      Hereâ€™s an example URL generated by the tool:

      <code-block class="data-url" language="html" code="
data:text/html,&lt;body onload=&quot;fetch`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68OyX8pDpSibDJhwqbGZbdrQpP/7DI7WpluDZPv8fb7Pd8dBXJqKJ3HJaJ7EBgxnyRJEi5aQhYbaIVk8dvhgEGvTdgZCqczbvV0RykHXnLazgrPdvEe2jTZQtGEmhWHCzDI7MeU4ymEjQjCs0id4Yc+GBa2At7MGQiUbkbMce9eg6AaERAuqGvRJmhIy9E3JLx7+3kB2q6nI8ZWsCqkMpXhBxZYqwN4HBZSjH04GLZbevxD6KHnu4SsbUmpdtGxUxkIrqMNaSdwbmikouggf7RhtFOSnSXeIS6CzQpuWhQ2zqfOmEnqmWM2o8S/xpFCBO3gPuSln76O7CoRDSgab0jyDusvSxhgp9k/F0fDAZtN3T24cBAuPvpGDUqlypmZacshRhFJOs9tTwZkwZZiVwHP/UgT4/3g4CfbP9ELOChMe4653rwqK4dtTPyPrl27x+NhC1nI913VSEudwhzJOtSZeV0mv67HY3YAgJ14UeUk8dsBLbnKGm57hoskZzTPc9AwXTc9onuGmJ1w8tvXoagTVBmmVEc9DUjClpCLegDODAG/xLa6wIqsIT/B0jUty8buRZg7CHrxeLj67LTZKkAg/kFxmTWW/uFFX8FW5HuB7UpNEM7OEisnG+L9IsqecKePXQ+dsm1XoN84O5i8VyMMjnkRRMMCU+DaggCT2ja/ccTcPYbi1N2XEah+Jm2NcbvnqlvWoorVvw/HVSMuK+S1J1IjdMdX6O5JQf4fboLuS1MHhcMK0ePcKszvDTMO/XBBc0Kqe99O9b/cD1UcDXQidsbVhpSRJR1Jk3P5zumRS63w4+N1yrPvNMZWVLfhPMlnjzLfSPu0rY59B/4L7Zh/3/9w/`.then(a=>new Response(a.body.pipeThrough(new DecompressionStream(`deflate-raw`))).text().then(a=>document.documentElement.innerHTML=a))&quot;>"/>

      The URL above is 1,078 bytes. It was compressed from a source doc of size 1.37 KB, which is a 23% compression!

      Btw, the above URL loads a simple tic-tac-toe web game. See for yourself by copying it into your browserâ€™s address bar.
      
      ## So, how does it work?
      
      The embedded document contains a `&lt;body>` tag with an `onload` callback. The callback itself contains the main script that will decompress and render the desired content.
      
      A small point: Why onload? Well, itâ€™s shorter than using a `&lt;script>` tag.

      <code-block language="html" code="
A: <body onload=&quot;/* code */&quot;>
B: <script>/* code */</script>
"/>

      The body tag wins by 1 character! Remember, characters - in a URL - are precious.

      OK, with that out of the way, letâ€™s break the main script down. Iâ€™ll plop the prettified code first, then explain the interesting bits.

      <code-block class="data-url" language="js" code="
/* use fetch() to convert the data into a stream */
fetch(
  /* encode the compressed HTML (which is binary) in base64 */
  `data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68OyX8pDpSibDJhwqbGZbdrQpP/7DI7WpluDZPv8fb7Pd8dBXJqKJ3HJaJ7EBgxnyRJEi5aQhYbaIVk8dvhgEGvTdgZCqczbvV0RykHXnLazgrPdvEe2jTZQtGEmhWHCzDI7MeU4ymEjQjCs0id4Yc+GBa2At7MGQiUbkbMce9eg6AaERAuqGvRJmhIy9E3JLx7+3kB2q6nI8ZWsCqkMpXhBxZYqwN4HBZSjH04GLZbevxD6KHnu4SsbUmpdtGxUxkIrqMNaSdwbmikouggf7RhtFOSnSXeIS6CzQpuWhQ2zqfOmEnqmWM2o8S/xpFCBO3gPuSln76O7CoRDSgab0jyDusvSxhgp9k/F0fDAZtN3T24cBAuPvpGDUqlypmZacshRhFJOs9tTwZkwZZiVwHP/UgT4/3g4CfbP9ELOChMe4653rwqK4dtTPyPrl27x+NhC1nI913VSEudwhzJOtSZeV0mv67HY3YAgJ14UeUk8dsBLbnKGm57hoskZzTPc9AwXTc9onuGmJ1w8tvXoagTVBmmVEc9DUjClpCLegDODAG/xLa6wIqsIT/B0jUty8buRZg7CHrxeLj67LTZKkAg/kFxmTWW/uFFX8FW5HuB7UpNEM7OEisnG+L9IsqecKePXQ+dsm1XoN84O5i8VyMMjnkRRMMCU+DaggCT2ja/ccTcPYbi1N2XEah+Jm2NcbvnqlvWoorVvw/HVSMuK+S1J1IjdMdX6O5JQf4fboLuS1MHhcMK0ePcKszvDTMO/XBBc0Kqe99O9b/cD1UcDXQidsbVhpSRJR1Jk3P5zumRS63w4+N1yrPvNMZWVLfhPMlnjzLfSPu0rY59B/4L7Zh/3/9w/`
)
.then(compressedHtml =>
  /* a Response wrapper will be used to decode data into text */
  new Response(
    /* get the compressed data stream */
    compressedHtml.body
    /* then decompress it */
    .pipeThrough(new DecompressionStream(`deflate-raw`))
  )
  /* decode data into text */
  .text()
  .then(html =>
    /* replace page with decoded html */
    document.documentElement.innerHTML = html
  )
)
"/>
      
      ### 1. fetch(\`data:;base64,fVTfb5swEH...\`)
      
      The first thing youâ€™ll notice is the huge chunk of base64-encoded data wrapped in a `fetch()` call.
      
      The encoded data is the compressed HTML which has been prepared by a complementary compression script. Since compressed data is binary, it has been encoded in a text-friendly format for it to be a valid URL. Base64, an encoding thatâ€™s native to the web, was used for this purpose.

      To decode the base64 data, instead of using the standard [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob) function, `fetch()` was used. `fetch` sees the `;base64` flag in that data URL and decodes it natively. While it accomplishes the same thing, `fetch` is slightly better.

      The primary reason for choosing `fetch()` was that it outputs a Stream, the format needed for decompression later.

      The secondary reason is code size, optimising for the total URL length. `atob()` expects the encoded data to be text but what we have is binary data, so the `atob` method requires [more massaging](https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem).
      
      Hereâ€™s a quick length comparison. A is fetch. B is atob. Below is a character ruler with markings.

      <code-block language="js" code="
A: fetch`data:;base64,dVo=`.then(a=>a.body)
B: new Blob([Uint8Array.from(atob`dVo=`,a=>a.codePointAt(0))]).stream()
                                          ^                           ^
                                          A                           B
   0        10        20        30        40        50        60       
   12345678901234567890123456789012345678901234567890123456789012345678
"/>

      The `atob()` method requires additional 28 characters!

      <box-note>
        <strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">Tagged templates</a></strong> are abused here to save a couple of characters. Instead of <code>fetch("abc")</code>, we can use <code>fetch&#96;abc&#96;</code>!
      </box-note>
  
      ### 2. body.pipeThrough(new DecompressionStream(...))

      Next thing to note is the `DecompressionStream` class. This is from the new [**Compression Streams API**](https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API) which allows browser native compression and decompression. This saves a lot of decompression code that gets bundled in the URL.

      As of writing, this API can only consume streams. Thatâ€™s why the code required streams.

      Continuing. From the earlier `fetch()` call comes a `body` stream that contains the compressed data. This is piped through the decompressor, which results in the uncompressed, original HTML string - in a _Stream_.

      To convert the HTML Stream to an HTML _String_, we can use...

      ### 3. new Response(stream).text()

      Yet another trick is to use the native [**Response**](https://developer.mozilla.org/en-US/docs/Web/API/Response=) classâ€™s `text()` function to convert a stream into a string. The Response constructor accepts a wide variety of content, including a Stream.

      `text()` decodes the Responseâ€™s content into a UTF-8 string.

      ### 4. document.documentElement.innerHTML = html
    
      Finally, the uncompressed HTML in string form is assigned to the whole document. `document.write(html)` could have been used here, but some browsers donâ€™t like this function. `innerHTML` works equivalently well.

      ## Preparing the compressed code

      The above describes the process of decompressing some base64-encoded compressed HTML. The compressed HTML is prepared by this code:

      <code-block language="js" code="
async function formatPayload(html) {
  const compressed = await new Response(
    new Blob([html])
      .stream()
      .pipeThrough(new CompressionStream('deflate-raw'))
  ).arrayBuffer();
  return btoa(String.fromCharCode(...new Uint8Array(compressed)));
}
"/>

      The result of this function will be the base64-encoded string embedded in the URL. This is called at authoring time.

      ## Demo

      This demo was made using the library from `https://portabl.ink/pack.js`.

      <textarea id="demoHTML" class="demo-area" rows="8"></textarea>
      <textarea id="demoURL" class="demo-area" rows="8" readonly></textarea>

      <script type="module" async defer>
        import pack from "https://portabl.ink/pack.js";

        const htmlTextArea = document.getElementById("demoHTML");
        const urlTextArea = document.getElementById("demoURL");

        htmlTextArea.addEventListener("input", htmlToURL);

        htmlTextArea.value = "Hello world! " + "Hello world again! ".repeat(20);
        htmlToURL();

        async function htmlToURL() {
          urlTextArea.value = await pack(htmlTextArea.value);
        }
      </script>

      <style>
        .demo-area {
          resize: vertical;
          width: 100%;
        }
      </style>

      <box-note>Note: If your input is not compressible enough, the overhead of bundling the decompression code might not be worth it. The tool may decide to use plain text, whichever is smaller.</box-note>

      Check out the full-fledged tool at [**portabl.ink**](https://portabl.ink)! Itâ€™s got a WYSIWYG editor, pretty pages, and more!

      ## Conclusion
      
      Potential improvements:

      * Use [Base122](https://github.com/kevinAlbs/Base122) for more compression. Weâ€™re not restricted to ASCII anymore. We can use a larger character set than base64. This adds a significant amount of decompression code though.

      Lessons learned:

      * Data URLs, while portable, are a poor way to share links. Browsers restrict navigation to data URLs. Social apps donâ€™t accept them. They are assumed to be malicious.
      * Buying a domain is an impulsive decision. Letâ€™s see if I get to renew this one.

      Overall, a fun hobby project.
    </markdown>
  </blog-page>
</html>

<style>
  .data-url,
  .data-url code {
    word-break: break-all;
    white-space: pre-wrap;
  }
</style>
