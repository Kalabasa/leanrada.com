<html>
  <page-title title="How I built Tic-tac-toe game AI in pure CSS" />
  <blog-page>
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="How I built Tic-tac-toe game AI in pure CSS"
        :heroimgsrc="url('hero.png')" />

      <blog-post-info date="5 May 2023" read-mins="1" />

      As a software developer, I'm always looking for new and fun ways to challenge myself. Some time ago, I decided to implement Tic-Tac-Toe with a computer-controlled enemy using only HTML and CSS. That is, no JavaScript! While I already knew the possibility of advanced interactions with CSS (e.g. fancy checkboxes), I wanted to see how far I could take it.

      Here‚Äôs a CodePen of it! Can you beat a stylesheet in a game of tic-tac-toe?
      
      <p class="codepen" data-height="700" data-theme-id="dark" data-default-tab="result" data-slug-hash="oVMOZK" data-user="kalabasa" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
        <span>See the Pen <a href="https://codepen.io/kalabasa/pen/oVMOZK">
        Pure CSS Tic Tac Toe AI</a> by Kalabasa (<a href="https://codepen.io/kalabasa">@kalabasa</a>)
        on <a href="https://codepen.io">CodePen</a>.</span>
      </p>
      <script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

      In this post, I will write about how I arrived at the solution. Let‚Äôs start with the fundamentals before working our way up to the final solution.

      Disclaimer: This is an experiment only. Never do this in real life!

      ## Building blocks

      Before starting to build anything complex, it's important to start small and think about basic elements. Unlike JavaScript, HTML and CSS are declarative languages. They don't have procedures or functions, control flow, if-statements, and the like. Instead they have markup and rules. We‚Äôll build upon these rules to create complex game logic.
      
      For starters, let‚Äôs do something that‚Äôs fairly common on the web: **custom checkbox styles**. To do this, use the `:checked` pseudo-class selector to react to the checkbox‚Äôs state and the **sibling combinator** `~` to apply the style on a separate span element that acts as a fake visual checkbox:
      
      <div class="demo-box demo1">
        <label><input type="checkbox" /><span></span> Check this out</label>
        <div><small>(these demos are interactive!)</small></div>
      </div>
      
      <code-block language="css" :code="`\
input:checked ~ span {
  background-color: blue;
  transform: rotate(45deg);
}
`" />

      You will realize that the sibling combinator applies beyond styling boxes next to inputs. We can do some action at a distance, for example:

      <div class="demo-box demo2">
        <input type="checkbox" id="demo2_input" />
        <label for="demo2_input">Is it raining?</label>
        <p>As you know, when it rains, water falls down from the sky. This may cause wetness. An umbrella is a device which shields the user from falling particles such as the aforementioned rainwater.</p>
        <fieldset class="advice">
          <legend>Advice</legend>
          <span class="take-umbrella">Take an umbrella today!</span>
          <span class="no-umbrella">No need for an umbrella!</span>
        </fieldset>
      </div>
      
      <code-block language="css" :code="`\
input:checked ~ .advice .take-umbrella {
	visibility: visible;
}
input:checked ~ .advice .no-umbrella {
	visibility: hidden;
}
`" />

      As you will see later, the sibling combinator `~` can be very useful for these CSS interactions.

      Let‚Äôs take this to the next level with a bit of CSS trickery. And with `&lt;label&gt;`‚Äôs `for` attribute enabling even more action at a distance, we can make pretty much any kind of UI we want!

      Presenting... the Weather-advise-o-matic!

      <css-rain-machine-demo demo-number="1" />

      ### OR

      A single binary input with 1:1 correspondence to outputs is not very exciting, is it? Let‚Äôs add another input and then implement an **OR** construct to determine the output. In CSS this can be easily achieved by a **selector list** (i.e., comma-separated selectors).

      <code-block language="css" :code="`\
input#raining:checked ~ .advice .take-umbrella,
input#sunny:checked ~ .advice .take-umbrella {
  visibility: visible;
}

/* General form: if [C1] or [C2] then [R]*/
[C1] ~ [R element],
[C2] ~ [R element] {
  [R effect]
}
`" />

      <css-rain-machine-demo demo-number="2" />

      ### AND

      How about **AND**? We can implement an AND construct too! This involves chaining the inputs with sibling combinators in a single selector.

      <code-block language="css" :code="`\
input#raining:checked ~ input#windy:checked ~ .advise .take-raincoat {
  visibility: visible;
}

/* General form: if [C1] and [C2] then [R]*/
[C1] ~ [C2] ~ [R element] {
  [R effect]
}
`" />

      <css-rain-machine-demo demo-number="3" />

      Another basic computing operator aside from AND and OR is the **NOT** operator. We don‚Äôt really need that here, but for the record, there‚Äôs the `:not()` pseudo-class in CSS.

      ## Prototype: Three-in-a-row

      As a proof of concept and precursor to Tic-tac-toe, let‚Äôs build a Three-in-a-row game. We‚Äôll use a 3x3 array of checkbox inputs and the AND and OR constructs.

      <css-three-in-a-row />

      Each box is numbered 1 to 9 starting from the top-left box going left-to-right line by line.

      The rules for implementing the three-in-a-row win condition would be:

      <code-block language="css" :code="`\
#1:checked ~ #2:checked ~ #3:checked ~ .win,
#4:checked ~ #5:checked ~ #6:checked ~ .win,
#7:checked ~ #8:checked ~ #9:checked ~ .win,
#1:checked ~ #4:checked ~ #7:checked ~ .win,
#2:checked ~ #5:checked ~ #8:checked ~ .win,
#3:checked ~ #6:checked ~ #9:checked ~ .win,
#1:checked ~ #5:checked ~ #9:checked ~ .win,
#3:checked ~ #5:checked ~ #7:checked ~ .win {
  visibility: visible;
}
`" />

      Yes, it‚Äôs kinda hacky, but that is to be expected when you‚Äôre forcing logic into CSS. Btw, the CSS for the real Tic-tac-toe logic is over 9000 lines. I never said it would be clean.

      Anyway, let‚Äôs take a closer look at the first line:

      <code-block language="css" :code="`\
/* if [box #1 marked] and [box #2 marked] and [box #3 marked] then [win] */
#1:checked ~ #2:checked ~ #3:checked ~ .win,
`" />

      Here we see an AND rule with 3 operands. In this particular case, the operands correspond to the three boxes in the top row (boxes #1, #2, and #3). We can conclude that this rule allows the player to win by marking the three boxes in the top row.

      But there are 8 such ways to win the game. Hence this 3-operand AND rule is repeated 8 times to cover *each possible winning combination*. They are then concatenated together into one big OR rule, as doing any one of them is sufficient to win the game.

      <code-block language="css" :code="`\
/*
 * if
 *      ([#1 marked] and [#2 marked] and [#3 marked]) // top row
 *   or ([#4 marked] and [#5 marked] and [#6 marked]) // middle row
 *   or ([#7 marked] and [#8 marked] and [#9 marked]) // bottom row
 *   .
 *   :
 *   or ([#3 marked] and [#5 marked] and [#7 marked]) // upward diagonal
 * then
 *   [win]
 */
#1:checked ~ #2:checked ~ #3:checked ~ .win,
#4:checked ~ #5:checked ~ #6:checked ~ .win,
#7:checked ~ #8:checked ~ #9:checked ~ .win,
#1:checked ~ #4:checked ~ #7:checked ~ .win,
#2:checked ~ #5:checked ~ #8:checked ~ .win,
#3:checked ~ #6:checked ~ #9:checked ~ .win,
#1:checked ~ #5:checked ~ #9:checked ~ .win,
#3:checked ~ #5:checked ~ #7:checked ~ .win {
  visibility: visible;
}
`" />

      ## Taking turns

      So far, the order of your inputs doesn't matter. You can even undo your inputs by unchecking the boxes under the hood! There's always a path to every other state in the game.

      That won‚Äôt fly in a game of Tic-tac-toe! In Tic-tac-toe, players take turns incrementally adding marks on the board. No backsies! There are also terminal states where no further input is possible, such as a win or a draw.

      To implement turns and wins, we need a way to "consume" inputs. We can do this by hiding inputs or otherwise making them unclickable. This is just a trick, of course, as we can‚Äôt really disable inputs using CSS. But it works fine for the typical mouse and touch users.

      For Tic-tac-toe, what I did was define multiple sets of the 3x3 input board, that is, one set of 3x3 inputs for each turn. They are stacked on top of each other. Each set is exclusively interactable only on its turn.

      <blog-media
        alt="input sets illustration"
        :src="url('./input_sets.mp4')" />

      <code-block language="css" :code="`\
/* Disable turn 1 inputs when turn 1 is played */
input[name=&quot;turn_1&quot;]:checked ~ input[name=&quot;turn_1&quot;] {
	pointer-events: none;
}
/* Enable next turn's inputs */
input[name=&quot;turn_1&quot;]:checked ~ input[name=&quot;turn_2&quot;] {
	pointer-events: all;
}
/* And so on... */
`" />

      And here‚Äôs a demo of sequential inputs. Note that I used `radio` type inputs here, but that‚Äôs just semantics.

      <box-note>I was only able to implement up to three turns here. And no win conditions! It has been&hellip; a little tedious. üòì</box-note>

      <css-three-in-a-row-seq demo-number="1" />

      ## Game AI

      <box-note>
        I‚Äôm using the more specific term ‚Äúgame AI‚Äù, because the term ‚ÄúAI‚Äù has come to mean some learning machine nowadays. Game AI simply means NPCs or computer-controlled agents.
      </box-note>

      First of all, understand that Tic-tac-toe is a solved game, which means there exists a perfect strategy. For every move, there is a known optimal counter move.

      This is perfect for CSS as it‚Äôs just a bunch of static declarations. We can list all of the optimal moves and directly translate them into CSS declarations!

      As a side-effect, the AI would never lose. But that‚Äôs not a bad thing at all!

      The rules are essentially a bunch of if-then statements, such as these ones:

      ### Blocking

      Example rule: _If **X(1)** and **X(2)** then **O(3)**._

      In English, if X was played at box #1 (top-left) and another X is at #2 (top-center), then block by playing O at box #3 (top-right).

      (In these exambles, X is the player and O is the AI.)

      <code-block language="css" :code="`\
input[value=&quot;1&quot;]:checked
~ input[value=&quot;2&quot;]:checked
~ .o3 {
  visibility: visible,
}
`" />

      <blog-media
        alt="blocking rule animation"
        :src="url('./blocking.mp4')" />

      ### Winning moves

      Example rule: _If **O(3)** and **O(7)** then **O(5)**._

      If O is at box #3 (top-right) and another O is at #7 (bottom-left), then win by playing O at box #5 (center).

      Now, this rule‚Äôs conditions require that we know the location of the AI‚Äôs previous moves. But we can‚Äôt really check for the current state of the game beyond the player‚Äôs inputs. There is no direct translation of **O(3)** and **O(7)** into CSS conditions. How would the AI know that a third *O* is the winning move if it can‚Äôt check the first and second *O*s?

      Well, since the AI is deterministic, we know specifically how those previous *O*s came about - those are just static responses to previous inputs which are defined in previous rules!

      <code-block language="css" :code="`\
input[value=&quot;1&quot;]:checked
~ input[value=&quot;2&quot;]:checked /* We know X(1) and X(2) produces O(3) */
~ input[value=&quot;4&quot;]:checked /* X(1) and X(4) produces O(7) */
/* Therefore, X(1) & X(2) & X(4) is equivalent to O(3) & O(7). */
/* If X(1) & X(2) & X(4) then O(5) is a winnng move! */
.o5 {
  visibility: visible,
}
`" />

      <blog-media
        alt="winning rule animation"
        :src="url('./winning.mp4')" />

      <box-note>
        ‚ö†Ô∏è Warning: I‚Äôm skipping major details in these code examples, like the existence of turn order, but it doesn‚Äôt really change the essence of these illustrations.
      </box-note>

      Alright, now that we can implement game AI rules in CSS, what are the actual rules? We know that the rules must exhaustively cover every possible move in Tic-tac-toe. Is there a list of all the optimal moves, like a cheatsheet?

      Well, there is a cheatsheet, but it‚Äôs for humans.

      <text-link href="https://xkcd.com/832/">
        <blog-media
          src="https://imgs.xkcd.com/comics/tic_tac_toe.png"
          caption="xkcd/832" />
      </text-link>

      It‚Äôs not really feasible to write CSS based on this, unless you have more than 60,480 hours to spare.

      What I did was I wrote a program that generates the rules from an exhaustive search of the game state space. It simulated all possible moves in Tic-tac-toe, recorded the ones that lead to a win or a draw, and saved those winning moves as rules.

      (pseudo-code)

      The program directly outputs CSS so there‚Äôs no need for a translation like in the examples above. This CSS output is directly used in the game.

      (Link to codepen)
    </markdown>
  </blog-page>
</html>

<style>
  .demo-box {
    border-radius: 12px;
    background-color: #eee;
    color: #000;
    padding: 12px;
    user-select: none;
  }

  .demo1 label {
    cursor: pointer;
  }
  .demo1 input {
    appearance: none;
  }
  .demo1 span {
    display: inline-block;
    width: 1ch;
    height: 1ch;
    border: solid 2px blue;
    transition: background-color 0.3s, transform 0.2s;
  }
  .demo1 input:checked ~ span {
    background-color: blue;
    transform: rotate(45deg);
  }

  .demo2 .advice {
    min-height: 2em;
    min-height: 2lh;
  }
  .demo2 .advice span {
    display: block;
    position: absolute;
  }
  .demo2 .take-umbrella {
    visibility: hidden;
  }
  .demo2 input:checked ~ .advice .take-umbrella {
    visibility: visible;
  }
  .demo2 input:checked ~ .advice .no-umbrella {
    visibility: hidden;
  }
</style>
