<sap-demo-client
  {...attrs}
  data-rss="interactive"
  aria-label="interactive demo of the collision detection algorithm"
/>

<style>
  sap-demo-client {
    display: flex;
  }
  sap-demo-client > canvas {
    width: 100%;
    border: solid 2px #ccc;
    border-radius: 12px;
    touch-action: none;
  }
</style>

<script type="module" client defer>
  import { BaseElement } from "/lib/base_element.mjs";
  // Warn: Module paths are relative to the page, not the component
  import { BallSim } from "./ball-sim/ball-sim.mjs";
  import { Runner } from "./ball-sim/runner.mjs";
  import { Renderer } from "./ball-sim/renderer.mjs";
  import { setupDragging } from "./ball-sim/dragging.mjs";
  import { createProcessPhysicsFunc } from "./ball-sim/process-physics.mjs";
  import { createDecorations } from "./ball-sim/decorations/decorations.mjs";
  import { NoopStrat } from "./ball-sim/collision-strats/noop-strat.mjs";
  import { PairwiseStrat } from "./ball-sim/collision-strats/pairwise-strat.mjs";
  import { SweepAndPruneStrat } from "./ball-sim/collision-strats/sap-strat.mjs";
  import { SkippingDelegateStrat } from "./ball-sim/collision-strats/skip-delegate-strat.mjs";
  import { createQuickSort } from "./ball-sim/sorts/quick-sort.mjs";
  import { createInsertionSort } from "./ball-sim/sorts/insertion-sort.mjs";

  customElements.define(
    "sap-demo-client",
    class SweepAndPruneDemoClient extends BaseElement {
      constructor() {
        super();

        this.visibilityListener({
          show: async () => {
            if (!this.hasInit) this.init();
            this.runner.start();
          },
          hide: async () => {
            if (this.runner) this.runner.stop();
          },
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.cleanup();
      }

      init() {
        this.cleanup();

        const ballsAttr = this.getAttribute("balls");
        const strategyAttr = this.getAttribute("strategy");
        const isStatic = this.hasAttribute("static");
        const noBounce = this.hasAttribute("no-bounce");
        const isDraggable = this.hasAttribute("draggable");
        const labelsAttr = this.getAttribute("labels");
        const isRainbow = this.hasAttribute("rainbow");
        const decorationsAttr = this.getAttribute("decorations");
        const skipIntervalAttr = this.getAttribute("skip-interval");

        const ballSimCreator = BallSim.create(600, 400);
        if (ballsAttr?.startsWith("[")) {
          const ballsSpec = JSON.parse(ballsAttr);
          for (const [x, y, radius] of ballsSpec) {
            ballSimCreator.addBall(x, y, radius);
          }
        } else {
          const ballCount = ballsAttr?.match(/\d+/)
            ? Number.parseInt(ballsAttr)
            : 5;
          ballSimCreator.addRandomBalls(ballCount, 0.06 + 0.2 / ballCount);
        }

        this.ballSim = ballSimCreator
          .setStatic(isStatic)
          .setEventTarget(this)
          .build();

        if (isRainbow) {
          const { balls } = this.ballSim;
          for (let i = 0; i < balls.length; i++) {
            const ball = balls[i];
            const h = i / balls.length;
            ball.color = `hsl(${h}turn 90% 70%)`;
          }
        }

        this.canvas = document.createElement("canvas");
        this.canvas.width = this.ballSim.width;
        this.canvas.height = this.ballSim.height;
        this.appendChild(this.canvas);

        const labelsValue = labelsAttr?.split(",") ?? [];
        this.renderer = new Renderer(this.ballSim, this.canvas, labelsValue);

        const pause = (duration) => this.runner.pause(duration);

        const { callbacks } = createDecorations(
          decorationsAttr,
          this.ballSim,
          this.renderer,
          pause
        );

        const processFunc = createProcessPhysicsFunc(
          !noBounce && !isStatic,
          callbacks
        );

        const collStrat = createCollisionStrategy(
          this.ballSim,
          this.renderer,
          processFunc,
          callbacks,
          this,
          strategyAttr,
          skipIntervalAttr
        );

        this.runner = new Runner(collStrat, this.ballSim, this.renderer);

        if (isDraggable) {
          setupDragging(this.ballSim, this.canvas, this);
        }

        this.hasInit = true;
      }

      cleanup() {
        this.replaceChildren();
        if (this.runner) this.runner.stop();
        this.canvas = undefined;
        this.renderer = undefined;
        this.ballSim = undefined;
        this.runner = undefined;
        this.hasInit = false;
      }
    }
  );

  function createCollisionStrategy(
    ballSim,
    renderer,
    processFunc,
    callbacks,
    eventTarget,
    strategyAttr,
    skipIntervalAttr
  ) {
    let collStrat;
    switch (strategyAttr) {
      case "noop":
        collStrat = new NoopStrat();
        break;
      case "pairwise":
        collStrat = new PairwiseStrat(ballSim, renderer, processFunc);
        break;
      case "sap-nativesort":
        collStrat = new SweepAndPruneStrat(
          ballSim,
          (arr) => arr.sort((a, b) => a.x - b.x),
          processFunc,
          callbacks,
          eventTarget
        );
        break;
      case "sap-quicksort":
        collStrat = new SweepAndPruneStrat(
          ballSim,
          createQuickSort(callbacks),
          processFunc,
          callbacks
        );
        break;
      case "sap-insertionsort":
        collStrat = new SweepAndPruneStrat(
          ballSim,
          createInsertionSort(callbacks),
          processFunc,
          callbacks
        );
        break;
      default:
        throw new Error("Invalid strategy: " + strategyAttr);
    }

    if (skipIntervalAttr) {
      collStrat = new SkippingDelegateStrat(
        Number.parseInt(skipIntervalAttr),
        collStrat
      );
    }

    return collStrat;
  }
</script>
