<html lang="en">
  <page-title title="Sweep and prune algorithm for collision detection" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sweep and prune algorithm for collision detection"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="1 Aug 2023" read-mins="17" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      Here‚Äôs a neat algorithm for detecting collisions among multiple objects.
      
      As you may know, the problem of collision detection is pretty common in video game programming as it‚Äôs a prerequisite to the implementation of certain game mechanics or simulations.
      
      Some of those mechanics include: preventing characters from passing through each other, [goombas](https://youtu.be/Ky69PjyHCqg) turning around when bumping into another, or any game physics in general. All of these need collision detection.

      The specific problem I‚Äôm going to cover here is detecting intersections between multiple objects over (discrete) time steps. I will go over multiple approaches starting with the simplest one and build up to the **sweep-and-prune** algorithm. 

      Balls.
      
      I‚Äôll use this rigid-body ball simulation as a recurring example throughout this post:

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      In this sim there are multiple balls, each of which can potentially collide with any other ball. This interaction requires a *multi-object* collision detection algorithm.

      How do we implement the detection of such n-body collisions?

      ##  Naive approach üê•

      The naive solution is to check every potential pair of objects for collision. Continuing with the ball example, this means *checking every ball against every other ball*.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Just pointing out in the code that the inner loop starts at `i + 1`. This is to prevent duplicate pairs (A-B vs B-A) from being counted. Other than that, it‚Äôs a pretty straightforward solution.

      These checks are done on every frame or on every physics step to ensure that balls will bounce exactly when they collide.

      The following visualisation shows a slowed-down simulation highlighting all of the possible pairs being tested for intersection per time interval:

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when being tested via <code>intersects()</code>.
        </div>
      </div>

      It works. For a couple of objects. More than a handful and we will encounter performance issues.

      ## Performance, or lack thereof

      The naive algorithm runs in **O(n<sup>2</sup>)** time in [Big O terms](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of n balls, the algorithm's run time grows proportionally to the *square* of the input n. That's a lot! üìà

      This is because for n balls, there are around __(n&nbsp;*&nbsp;(n-1))/2__ pairs to check, or __0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n__. For example, if n = 5 there would be a total of 10 pairs. For n = 10, there would be 45 pairs. For n = 15, 105 pairs (!). And so on&hellip; All of this information about the algorithm‚Äôs scalability can be simplified using Big O notation to just __‚ÄúO(n<sup>2</sup>)‚Äù__.

      The following painfully demonstrates how the performance scales badly for bigger inputs, here n&nbsp;=&nbsp;20:

      <div class="demo-row">
        <sap-demo
          balls="20"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          20 balls = 190 pairs to check
        </div>
      </div>

      That‚Äôs a lot of checks per frame! Clearly, the naive solution does not scale well for large numbers of objects.
 
      <box-note>Before anything else, note that the worst case for *any* collision detection algorithm is always __O(n<sup>2</sup>)__. That happens when all objects are intersecting simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions. Thus, it‚Äôs more practical to compare the average and best cases. You can also consider [expressing run time in terms of output](https://en.wikipedia.org/wiki/Output-sensitive_algorithm).</box-note>

      Having said that, the naive algorithm is still **Œò(n<sup>2</sup>)** for _any_ case, no matter the number of actual collisions. There is a lot of room to improve the solution.

      ## Prologue: Improving the solution

      <box-note>
        There are many ways to optimise collision detection, like spatial hashing and space partitioning trees. But this post in particular is about one algorithm and some of its variants.
      </box-note>

      Usually when optimising algorithms, you wanna find **redundant or unnecessary work**. Surely there is something wasteful in checking every object against every other object!

      Let‚Äôs dig into the `intersects()` check, the one performed for every candidate pair. If we take the [typical object intersection check](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html), we get a bunch of inequality checks:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
      && object1.right > object2.left
      && object1.top < object2.bottom
      && object1.bottom > object2.top;
}

// Define the structure just so we‚Äôre on the same page
type Object = {
  left: number;   // x-coordinate of left edge
  right: number;  // x-coordinate of right edge
  top: number;    // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      In the above code, the `intersects()` function checks if the two objects‚Äô bounds overlap by comparing opposing edges from the two objects. (Refer to [this nice MDN article about overlapping bounding boxes](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb) for a better explanation.)

      For now, let's focus on just one dimension, say *x*. Bear with me as I further scope down the check to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don't worry; this scoped-down definition is a surprise tool that can help us later.

      <blog-media
        alt="Still of a cartoon mouse saying, 'that‚Äôs a surprise tool that can help us later'"
        :src="url('surprise-tool.jpg')" />

      Ok, the reason this will work is because of the `&&` operator's [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation). That is, if any of the operands is false, then the whole expression becomes false. So if two objects do not overlap in the x-axis, then we can immediately rule them out as a candidate pair. 

      Thus, even doing an optimisation in just the x dimension will be a big help.

      Now, let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in the specific configuration illustrated:

      <blog-media
        alt="Three objects, from left to right: A, B, and C"
        :src="url('abc.png')" />

      There are three potential pairs to be checked here: A-B, B-C, and A-C. If we run them through the redefined `intersects()` function, then

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Remember, we‚Äôre trying to find redundant work. Looking closer, if we inline the `intersects()` function we get:

      <code-block :code="`\
A.right > B.left // returns false
B.right > C.left // returns false
A.right > C.left // returns false`" />

      See any redundant work? Maybe abstractify it a little&hellip;

      <code-block :code="`\
A > B // returns false
B > C // returns false
A > C // returns false`" />

      In this form, unnecessary work is revealed! Due to the transitive property of inequality, we realise that we don‚Äôt need to compute the third check! *If we know A&nbsp;>&nbsp;B and B&nbsp;>&nbsp;C are false, then we don't need to calculate A&nbsp;>&nbsp;C.*

      So in this example, we don't really need to check `intersects(A, C)`. We‚Äôve skipped one check!

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// I know intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to general n-body collision detection. A smart reader such as you might also have realised that this skip only works if A, B, and C are in a particular order. Try <span class="drag-hint">dragging</span> the balls below to see when the optimisation applies and when it does not:

      <div class="demo-row">
        <sap-demo
          id="abc-demo"
          balls="[[200,250,50],[300,150,55],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token comment">// LIVE OUTPUT:</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// A > B returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// B > C returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// A > C returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C), A > C will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
      </div>

      <script client defer>
        (()=> {
          const abcDemo = document.querySelector("#abc-demo");
          const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
          const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
          const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
          const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
          const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");
          
          abcDemo.addEventListener("simulate", throttle((event) => {
            const [A, B, C] = event.balls;
            setText(intersectsAbReturn, String(A.x > B.x));
            setText(intersectsBcReturn, String(B.x > C.x));
            setText(intersectsAcReturn, String(A.x > C.x));
            const acRuns = (A.x > B.x) !== (B.x > C.x);
            setShow(intersectsAcRun, acRuns);
            setShow(intersectsAcSkip, !acRuns);
          }));

          function setText(elements, text) {
            for (const element of elements)
              if (element.textContent !== text)
                element.textContent = text;
          }

          function setShow(elements, show) {
            for (const element of elements)
              if ((element.offsetParent != null) !== show)
                element.style.display = show ? "block" : "none";
          }
        })();
      </script>

      <box-note>Tip: Drag the balls such that they‚Äôre in one of these orders (left-to-right): C&#8209;B&#8209;A and A&#8209;B&#8209;C</box-note>

      While it‚Äôs true that this principle only works when A, B, and C are ordered, remember that these labels are *arbitrary*. What if we just decide to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable! üß†
      
      Hang on&hellip; labeling objects according to a defined order is essentially ‚ú®**sorting**‚ú®! What if we sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?

      ## Chapter 1. Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free.
      
      Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in O(n log n) time which is certainly better than O(n<sup>2</sup>) of the naive solution.

      As hinted by the tri-object example above, sorting the list of objects merely by their x position can help remove ranges of potential pairs that need to be checked.
      
      However, objects aren't zero-width points! They‚Äôre *widthy*, by which I mean having a size and occupying an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one sort by x position if objects span across intervals in the x-axis?

      ## The naive solution but better

      A quick way to improve the naive approach and a solution to sorting widthy objects is to sort them by their **minimum x** (their left edge‚Äôs x-coordinate).
      
      This will give us a chance to exit the inner loop early due to the sortedness of the list. I‚Äôll explain later.

      First, the code:

      <code-block :code="`\
// sort by min x
balls.sort((a,b) => a.left - b.left);

// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];

    // stop if too far
    if (ball2.left > ball1.right) break;

    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      It‚Äôs mostly similar to the naive solution having two-level nested loops, except we‚Äôre sorting the list beforehand and there is now a break in the inner loop:

<code-block :code="`\
// stop if too far
if (ball2.left > ball1.right) break;`" />

      Let‚Äôs break that down.
      
      First, we know that the list is sorted, so
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left</code>
      for any positive integer
      <code class="eq-c">c</code>.
      
      Therefore, when
      <code>ball2.left <span class="eq-op">&gt;</span> ball1.right</code>
      or rather
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      is true, then
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      will also be true.
      
      In that case, the current `ball2`,
      <code>balls[<span class="eq-i">j</span>]</code>,
      and any further `ball2`s,
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>]</code>,
      are *not* intersecting `ball1`. Thus it allows us to skip the rest and move on to the next `ball1`.

      Here‚Äôs a demo:

      <div class="demo-row">
        <sap-demo
          strategy="simple-sap"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when tested by <code>intersects()</code>.
        </div>
      </div>

      As you can see, only pairs which overlap in the x-axis are checked, resulting in much less processing per frame. The only cost would be the additional sorting which would be O(n log n), but it‚Äôs much better than O(n<sup>2</sup>) of the naive solution. The overall algorithm on average becomes **O(n log n + m)**, where _n&nbsp;log&nbsp;n_ is whatever the sort‚Äôs run time is, and _m_ is the number of collisions. Additionally, the choice of sorting algorithm could be improved; we‚Äôll look at that later in this post.

      Here‚Äôs a one-liner that summarises the inner loop‚Äôs pre-`intersects()` condition:

      <center><code>balls[<span class="eq-i">i</span>].right <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span>].left <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left</code></center>
      
      <style>
        .eq-op {
          color: var(--clr0-light);
        }
        .eq-i {
          color: #e79907;
        }
        .eq-c {
          color: var(--clr1); 
        }
      </style>

      If you got this far trying to find a good algorithm that is balanced between programming effort and runtime performance, then you can stop reading now and take the above code. If you want more data structures and algorithms or are curious how this develops, read on.

      ## Proper sweep-and-prune

      The above was a ‚Äúshortcut‚Äù version of a one-dimensional sweep-and-prune algorithm. I believe the runtime would be the same as the real one, but let‚Äôs see how the original tackled the problem of sorting widthy objects.
      
      To account for the width of objects while keeping the benefits of unambiguous sort order, we can track the left and the right edges of each object as two separate points!

      This is done by maintaining a separate array of edge points corresponding to the objects‚Äô left & right edges.

      See how it might work by playing with this <span class="drag-hint">draggable</span> demo. The left and right edges of each ball are visualised. These edge points are stored in a sorted array shown below the box.

      <div class="demo-row">
        <sap-demo
          id="edges-demo"
          balls="6"
          strategy="sap-nativesort"
          static draggable rainbow
          decorations="edges" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo"></div>
      </div>

      This is the setup we can use to minimise our `intersects()` calls. If you remember the `intersects()` function, here it is with only the x-axis checks:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
      && object1.right > object2.left;
}`" />

      We can replace these x-coordinate comparisons with a different approach based on array indices. Since we have a sorted list of every object's left and right points, finding overlaps via index-based searches would be faster than global pairwise testing.

      Take one ball for example. When you have the indices of its left and right points, you can simply run through all points in-between those two edges in the array to get all overlapping objects. This is a very fast linear operation.

      Try <span class="drag-hint">dragging</span> the <span style="color:#4c8">highlighted ball</span> below and observe the enclosed edges:

      <div class="demo-row">
        <sap-demo
          id="edges-demo-one"
          balls="6"
          strategy="sap-nativesort" 
          static draggable
          decorations="edges:focus:#4c8:#d88" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo-one"></div>
      </div>

      <box-note>One minor issue with the above 1-to-n approach is that an overlap can be missed if another ball is larger than the current ball. The larger ball can overlap the smaller ball without having any edge points inside of the smaller ball‚Äôs enclosure.</box-note>

      The above is a simple 1-to-n overlap detection. For n-to-n overlap detection, it turns out there is a way to find them across all objects in a single pass!

      ## Chapter 2. Sweeping

      To generalise the above to an n-interval overlap scan, imagine a vertical line sweeping across the whole space from left to right. The sweep will scan each edge point in order and keep track of the objects it touches.

      Whenever it encounters an object (a left edge), the object is added to an <span style="color:#d88">`inside`</span> set.
      
      Whenever it exits an object (right edge), the object is removed from the set. For now, let‚Äôs see what that looks like without collision:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges" />
        <div class="demo-caption">
          <code style="color:#d88">inside</code> objects are lit up in <span style="color:#d88">pink</span>.
        </div>
      </div>

      The <span style="color:#d88">`inside`</span> set tracks the set of objects that are currently touching the line.
      
      Of course, the line is merely a metaphor for iterating through the sorted list of edges. Here‚Äôs the code for the actual sweeping:

      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      Once we have a working `inside` set, detecting overlaps is easy. Whenever we‚Äôre entering a new object (a left edge), we can mark it as overlapping with each of the current objects `inside` the set.

      Another way to put it is, objects that have been `inside` the set simultaneously must be x-overlapping.

      Here‚Äôs the updated code for detecting and reporting overlaps:
      
      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    
    // the new object is overlapping with the existing ones
    for (const other of inside) {
      onOverlap(other, edge.object);
    }
    
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      Watch closely as the line enters a ball while having existing `inside` balls:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="6"
          decorations="sweep:#f00:#d88,edges,checks:#4c8:600" />
        <div class="demo-caption">
          X-overlapping pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> as the line sweeps.
        </div>
      </div>

      <box-note>The sweep-and-prune algorithm is also known sort-and-sweep.</box-note>

      ## Chapter 3. Pruning

      Sorting and sweeping only work in a single dimension. But balls aren't unidimensional objects! We‚Äôve gone from having abstract zero-dimensional point balls, to 1D balls as intervals in the x-axis. How do we account for the other dimension, y? This is the final frontier, as any such technique could be applied to z (or higher dimensions if you‚Äôre into that).

      One option is to perform a second sweep for the y-axis. That is, we maintain separate sorted lists of edges for each axis. Indeed, this is how the full sweep-and-prune implementation works as described in the [original paper by D. Baraff](https://ecommons.cornell.edu/handle/1813/7115). Object pairs are then flagged for overlaps in each dimension. In the case of 2D, pairs flagged twice (x-overlap && y-overlap) are intersecting.

      <box-note>
        The "prune" in sweep-and-prune refers to the elimination of candidate pairs during the sweeps in each dimension.
      </box-note>

      However, there is a simpler solution that is easier to implement and generalise. Do the sweep check in the x-axis as usual. Then, for the x-overlapping pairs, do a real check for intersection using the rest of the dimensions, like y and possibly z if 3D.

      Recall the above code which calls `onOverlap` on the pairs that passed pruning. This is the callback where we can check for the y dimension, e.g.:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  if (object1.top < object2.bottom && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      While the above formula generally works for game objects with an upright hitbox, a more precise and time-consuming check could be done at this level since most of the candidates have already been pruned. Our ball example works better with the following exact intersection check for circles:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  const distance = Math.sqrt(Math.pow(object1.x - object2.x, 2) + Math.pow(object1.y - object2.y, 2));
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      This multi-level checking is split into what is called broad-phase and narrow-phase detection. The broad-phase is the 1D sweep-and-prune which eliminates most candidate pairs, while the narrow-phase is the exact circle intersection test.

      Finally, implementing `bounce()` using physically-based physics, the result is this:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Ball sim using sweep-and-prune. <code>onOverlap()</code> calls highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      Notice the minimised number of pairs needed to be checked in the sweep-and-prune version. It‚Äôs a simple and elegant algorithm!

      ## Performance of sweep-and-prune

      Compared to the naive algorithm (global pairwise checking), the sweep-and-prune algorithm results in much less checks performed per frame, but it‚Äôs the same as the sorted pairwise checking.
      
      Look at the following side-by-side comparison and observe the amount of intersection checks required per frame:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="pairwise"
          skip-interval="2"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Global pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="simple-sap"
          skip-interval="2"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sorted pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sweep and prune</div>
      </div>

      Let‚Äôs analyse the time complexity!
      
      A run of sweep-and-prune consists of a sort and a sweep.
      
      The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would be **O(n log n)**.
      
      The sweep, which is a linear pass with an inner loop for overlaps, should be **O(n)** in the average case.
 
      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const inside = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      // zero at best; some constant on average; O(n) at worst
      for (const other of inside) {
        onOverlap(other, edge.object);
      }
      inside.add(edge.object);
    } else {
      inside.delete(edge.object);
    }
  }
}`" />

      This means sweep-and-prune is **O(n log n)** on average, a big improvement over the naive approach‚Äôs O(n<sup>2</sup>)!

      That‚Äôs great, but it‚Äôs the same as sorted pairwise with a lot more code. *Can we do better?*

      ## A small detail, big improvement

      Again, let's ask the question: Where is redundant work being done here?

      We can start by looking at the sort step, the bottleneck of the algorithm according to the analysis.
      
      The following is a visualisation of the sorting of the edges array, using an optimised [quicksort](https://en.wikipedia.org/wiki/Quicksort):

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-quicksort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      As you can see most of the time, the sort does nothing at all! The list is almost always already sorted from the previous frame.
      
      Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one frame.

      Fortunately, the subject of sorting algorithms is well-researched. We‚Äôre dealing with a special state, the state of being *almost sorted*. And one great choice for sorting almost-sorted lists is [**insertion sort**](https://en.wikipedia.org/wiki/Insertion_sort)!

      Insertion sort has a run time of O(n) at best when the list is already sorted or almost sorted, and O(n<sup>2</sup>) at worst. We can argue that the average case is **O(n)**, since the list is almost always sorted due to the previous frame‚Äôs sort.

      Here‚Äôs insertion sort in action:

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-insertionsort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      <box-note>
        Due to the sweeping mechanism and the insertion sort, it‚Äôs important to consider the primary axis of the sweep-and-prune algorithm. It should be the axis where objects are most widely distributed to minimize swaps and overlaps. In a side-scroller for example, the primary axis should be horizontal.
      </box-note>

      ## Another improvement

      There is yet another optimisation that could be made. In the insertion sort example above, you can observe that <span style="color:#f00">swaps</span> happen when an edge point passes through another.

      An edge point passing through another can mean one of these four things:

      ### case R ‚Üî L

      (todo: animation closeup)

      When a right edge from the left swaps with a left edge from the right, we can infer that the left object is starting to intersect the right object.

      ### case L ‚Üî R

      Conversely, when a left edge from the left swaps with a right edge from the right, the corresponding objects cease to intersect.

      ### case L ‚Üî L, R ‚Üî R

      Edges of the same polarity can swap without affecting the state of intersection of their corresponding objects.

      Thus we arrive at the one-dimensional sweep-and-prune‚Äôs final form:

      (todo: code here)

      ## Run time comparison

      | Algorithm                   | Worst case       | Average case     | Best case        | 
      |-----------------------------|------------------|------------------|------------------|
      | Global pairwise             | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
      | Sorted pairwise (quicksort) | O(n<sup>2</sup>) | O(n log n + m)   | O(n log n)       |
      | Sorted pairwise (insertion) | O(n<sup>2</sup>) | O(n + m)         | O(n)             |
      | Sweep-and-prune (final)     | O(n<sup>2</sup>) | O(n + m)         | O(n)             |

      n = number of balls, m = number of collisions

      ## Pros & cons

      Sorted pairwise
      No extra storage

      ## Appendix

      Things I‚Äôve noted or realised while writing this post:
      
      * General algorithm design insights
        * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
          * Some power when linearly scanning over the list
          * Faster range / adjacency checks
          * (unrelated, but good to bring up) Binary search
        * Different sorting algorithms have situational strengths.
      * I might need a frontend framework for my blog now, at least for the interactive demos.
        * Vanilla JS is starting to get scary with bigger demos like these.
        * `.mjs` is pretty good though.

      Bonus demo, 25 balls! It‚Äôs a ball party ‚öΩ‚öæüèÄüèê
      <div class="demo-row">
        <sap-demo balls="25" rainbow strategy="sap-nativesort" />
      </div>
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .demo-caption {
    max-width: 600px;
  }

  .drag-hint {
    font-weight: bold;
    border: dashed 2px #fff8;
    border-radius: 6px;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }

  .edges-array {
    position: relative;
    width: 100%;
    height: 20px;
  }
  .edge {
    position: absolute;
    width: 10px;
    height: 20px;
    background: #fff;
    transition: transform 0.2s;
  }
  .edge-left {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .edge-right {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
</style>

<script client defer>
  const edgesArrays = document.querySelectorAll(".edges-array");

  for (const edgesArray of edgesArrays) {
    const target = document.querySelector(edgesArray.dataset.target);

    const edgeToElement = new Map();

    target.addEventListener(
      "sap-sort",
      throttle((event) => {
        const { edges } = event;
        const n = edges.length;

        if (edgeToElement.size === 0) {
          for (const edge of edges) {
            const edgeElement = document.createElement("div");
            edgeElement.classList.add("edge");
            edgeElement.classList.add(
              edge.dir < 0 ? "edge-left" : "edge-right"
            );
            edgeElement.style.display = "none";
            edgesArray.appendChild(edgeElement);
            edgeToElement.set(edge, edgeElement);
          }
        }

        const width = edgesArray.getBoundingClientRect().width;

        for (const [edge, edgeElement] of edgeToElement.entries()) {
          const index = edges.indexOf(edge);
          const x = width / 2 + 20 * (index - (n - 1) / 2);
          edgeElement.style.display = "block";
          edgeElement.style.backgroundColor = edge.ball.color;
          edgeElement.style.transform = `translateX(calc(${x}px - 50%))`;
        }
      })
    );
  }

  function throttle(func, ms = 100) {
    let lastTime = Date.now();
    return (...args) => {
      if (Date.now() - lastTime < ms) return;
      lastTime = Date.now();
      func(...args);
    };
  }
</script>
