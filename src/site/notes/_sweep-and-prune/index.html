<html lang="en">
  <page-title title="Sweep and prune algorithm for collision detection" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sweep and prune algorithm for collision detection"
        :heroimgsrc="url('hero.png')" />

      <blog-post-info date="1 Jan 1970" read-mins="1" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      In video game programming, detecting collisions between objects is a common requirement. Consider the following ball simulation as a basic example. In this sim, multiple physics objects interact with each other. This requires a multi-object collision detection algorithm.

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      Each ball can potentially interact with *any other ball*. How do we implement the detection of such n-to-n collisions?

      ## Naive solution

      The naive solution is to check every potential pair of objects for collision. Continuing with the ball example, this means checking every ball for intersection with each of the other balls.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j]
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      This is done every frame to ensure balls bounce when they collide.

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          <span style="color:#4c8" class="pair-legend"></span> <code>intersects</code> calls are highlighted
        </div>
      </div>

      ## Performance

      The naive algorithm runs in **O(n<sup>2</sup>)** time in [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of n balls, the algorithm's run time grows proportionally to the *square* of the input n. That's a lot!

      This is because for n balls, there are around __(n&nbsp;*&nbsp;(n-1))/2__ pairs to check, or __0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n__. This is simplified to O(n<sup>2</sup>).

      <div class="demo-row">
        <sap-demo
          balls="10"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          With just 12 balls, the checks have grown to an unacceptable number!
        </div>
      </div>

      Clearly, the naive solution does not scale well for large numbers of objects. How can we improve this?
 
      Before anything else, note that the worst case for any collision detection algorithm is always O(n<sup>2</sup>). The worst case is when all objects are intersecting simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions. For collision detection, it’s more practical to compare the average and best cases.

      Having said that, the naive algorithm above is still **O(n<sup>2</sup>)** for any case, no matter the number of actual collisions.

      ## Improving the solution

      One common thought process when optimising algorithms is to find **redundant or unnecessary work**.

      <box-note>
        <p>There are many ways to optimise collision detection, like spatial hashing and space partitioning trees. But this post is about just one particular algorithm - the <strong>sweep and prune</strong> algorithm.</p>
        <p><strong>Disclaimer:</strong> The following is merely my attempt at rationalising the thinking behind the sweep-and-prune algorithm.</p>
      </box-note>

      Let's start with our [typical object intersection check](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html), the one performed for every candidate pair of objects. It's essentially a bunch of inequality checks:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
    && object1.right > object2.left
    && object1.top < object2.bottom
    && object1.bottom > object2.top;
}

// Define the structure just so we’re on the same page
type Object = {
  left: number; // x-coordinate of left edge
  right: number; // x-coordinate of right edge
  top: number; // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      For now, let's focus on just one dimension, say *x*. Bear with me as I further scope down the check to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don't worry; this scoped-down definition is a surprise tool that can help us later in understanding the rationale behind the algorithm.

      (mickey meme)

      Okay, more seriously, one reason it works is because of the AND operator's (`&&`) short-circuit evaluation. If any one of the operands is false, then the whole expression becomes false. This can be reworded into the [separating axis theorem](https://www.sevenson.com.au/programming/sat/), which states that if there exists an axis where two objects' don't overlap, then they don't intersect at all. Thus even if we just did an optimisation in one dimension, it will still significantly reduce the amount of checks. So for now, let's just deal with the x axis.

      Now, let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - as illustrated below.

      (illustration)

      There are three potential pairs to be checked here: A-B, B-C, and A-C. Let's run them through the function:

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Inlining the scoped-down `intersects` function:

      <code-block :code="`\
A.right > B.left // false
B.right > C.left // false
A.right > C.left // false`" />

      See any redundant work? Maybe simplify it a little more to an abstract level&hellip;

      <code-block :code="`\
A > B // false
B > C // false
A > C // false`" />

      There it is. The meat of the idea is that: if we know that A > B is false and B > C is false, then we don't need to calculate A > C to know that it too is false.

      Backing up to the function level. This means we don't need to check `intersects(A, C)` anymore. We skipped 1 check.

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to collision detection in general. Well, it’s true that this only works if A, B, and C are in a particular order. Try moving the balls below to see when the optimisation applies.

      <div class="demo-row">
        <sap-demo
          balls="[[100,250,50],[250,150,40],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        ```
        // todo: live output of interactive controls below
        intersects(A, B)
        intersects(B, C)
        intersects(A, C)
        ```
      </div>

      todo: draggable indicator

      However, these labels are arbitrary&hellip; What if we just called the leftmost ball A, the middle ball B, and the rightmost C, at any point in time? Then the optimisation would always be applicable! But hang on&hellip; labeling objects according to a defined order is essentially **sorting**! What if we just sorted the list every time? Would the skipped checks be worth it?

      ## Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free. Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in O(n log n) time which is certainly better than O(n<sup>2</sup>) of the naive solution.

      As hinted by the 3-object example above, sorting the list of objects merely by their x position can help remove ranges of potential pairs that need to be checked. How can we generalise this to n objects?

      First, let's unwind the simplification we did earlier. Objects aren't zero-width points! Each object has a size - a certain width. We can account for the width all while keeping the benefits of unambiguous sort order by tracking the left and the right edges of each object as two separate points.

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          static draggable rainbow
          decorations="edges"  />
        todo: linear row of deges (separate component)
      </div>


      You can probably guess where this is going. Remember the `intersects` function? This is it scoped down to the x axis:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
    && object1.right > object2.left;
}`" />

      Since we have a sorted list of every object's left and right points, it’s faster to find overlaps by doing local index-based searches rather than global pairwise testing.

      For example, take one object, when you have the indices of its left and right points, you can simply run through all points between them in the array to get its overlapping objects. There’s a problem though... (todo) when other ball encloses current ball.

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort" 
          static draggable
          decorations="edges:focus:#4c8:#d88" />
      </div>

      ## Sweeping

      (todo) Scanning from left to right and keeping track of which objects we're currently *inside of*.

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges" />
      </div>

      Here’s the code for scanning (*sweeping*) to track when we're inside which objects:

      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      At each left edge, we add the corresponding object to the *inside* list. At the same time, at a left edge, we're entering a new object - that is the definition of the left edge, an entry point. This means, if we're already inside other objects, and we enter a left edge, it follows that this edge's object intersects with the other objects.

      Here's the updated code for detecting and reporting intersections:
      
      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    
    // if still inside other objects, they must overlap the new one
    for (const other of inside) {
      onOverlap(other, edge.object);
    }
    
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges,checks:#4c8:600" />
      </div>

      ## Pruning

      The sweeping mechanism only works in a single dimension. But balls aren't one-dimensional objects! How do we account for the other dimension, y?

      One option is to perform a second sweep for the y-axis. That is, we need a separaet list of edges for the y-axis. Object pairs are then flagged for overlaps in each sweep in the x and y dimensions.

      <box-note>
        The "prune" in sweep-and-prune refers to the elimination of candidate pairs during the sweeps in each dimension.
      </box-note>

      However, there is a simpler solution that is easier to generalise. We can do the sweep check in the x-axis only to get a shortlist of object pairs with overlapping x spans. The for each shortlisted pair, we do a real check for intersection on the rest of their dimensions, like y and possibly z if 3D.

      The above code calls `onOverlap` on the object pairs that passed pruning. This is where we can check for the y dimension.

      <code-block :code="`\
onOverlap = function(object1, object2) {
  if (object1.top < object2.bottom && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      The above formula generally works for game objects with an upright hitbox. But usually a more precise and time-consuming check could be done at this level since most of the candidates have already been pruned. Our ball example works better with the following circle intersection check:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  const distance = Math.sqrt(Math.pow(object1.x - object2.x, 2) + Math.pow(object1.y - object2.y, 2));
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      Here (todo)

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#4c8" />
      </div>

      ## Performance of sweep-and-prune

      Compared to the naive algorithm, the sweep-and-prune algorithm results in much less checks performed per frame. If your intersection checks are expensive, e.g. complex 3D objects, it’s going to be a big time-saver.
      
      Look at the following side-by-side comparison and notice the number of intersection checks required per frame:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="pairwise"
          skip-interval="2"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Naive pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sweep and prune</div>
      </div>

      Let’s analyse the time complexity!
      
      A run of sweep-and-prune consists of a sort and a sweep.
      
      The sort - if we take the "fastest" sorting algorithm, mergesort or quicksort - would be O(n log n).
      
      The sweep, which is a linear pass with an inner loop for overlaps, should be O(n) in the average case. That is if the average case is a sparse world with mostly evenly-distributed object groups and a few pairs actually intersecting, which I think is a reasonable assumption.
 
      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const inside = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      // zero at best; some constant w.r.t. input size on average
      for (const other of inside) {
        onOverlap(other, edge.object);
      }
      inside.add(edge.object);
    } else {
      inside.delete(edge.object);
    }
  }
}`" />

      This means sweep-and-prune is O(n log n) at best, a big improvement over the naive O(n<sup>2</sup>)!

      <box-note>The sweep-and-prune algorithm is also known sort-and-sweep.</box-note>

      (todo: graph vs)

      (todo: check native sort (timsort) vs quicksort)

      *Can we do better?*

      ## A small change, big improvement (?)

      Again, let's ask the question: Where is redundant work being done here?

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-quicksort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
      </div>

      As you can see, sort does nothing most of the time! Most of the time, the list is already sorted from the previous frame. Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one frame.

      Luckily, the subject of sorting algorithms is well-researched. We’re dealing with a special state of lists which is the state of being almost sorted. Insertion sort is a great choice for almost-sorted lists!

      Insertion sort has a run time of O(n) at best when the list is already sorted or almost sorted, and O(n<sup>2</sup>) at worst. However, we can argue that the average case is O(n), since the list is almost always sorted due to the previous frame’s sort.

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-insertionsort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
      </div>

      With the sweeping mechanism and insertion sort in mind, it’s important to consider the primary axis of the sweep-and-prune algorithm. It should be the axis where objects are most evenly distributed to minimize swaps and overlaps. In a side-scroller for example, the primary axis should be horizontal.

      ## Less theoretical, more practical

      Forget about theory. (todo)

      Using your standard library's sort function is usually the best as it's most likely optimised for the runtime.

      (todo: check if native sort is still best)

      # Conclusion

      General algorithm design insights
      * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
        * Single linear pass over the list
        * (unrelated, but good to bring up) Binary search
      * Different sorting algorithms have situational strengths
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }
</style>
