<html lang="en">
  <page-title title="Sweep and prune algorithm for collision detection" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sweep and prune algorithm for collision detection"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="1 Aug 2023" read-mins="17" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      Here‚Äôs a neat algorithm for detecting collisions among multiple objects. As you may know, the problem of collision detection is pretty common in video games as a prerequisite to the implementation of certain game mechanics or simulations. Mechanics such as preventing characters from passing through each other, [goombas](https://youtu.be/Ky69PjyHCqg) turning around when bumping into another, or any game physics in general. All need collision detection.

      The specific problem I‚Äôm going to cover is detecting intersections between multiple objects at discrete times. Take the following rigid-body ball simulation as a basic example:

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      In this sim, we have multiple balls, each of which can potentially collide with any other ball. This requires a *multi-object* collision detection algorithm.

      How do we implement the detection of such n-body collisions?

      ##  Naive approach

      The naive solution is to check every potential pair of objects for collision. Continuing with the ball example, this means *checking every ball against every other ball*.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j]
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Note in the code that the inner loop starts at `i + 1`. This is to prevent duplicate pairs (A-B vs B-A) from being counted. Other than that, it‚Äôs a pretty straightforward solution.

      These checks are done on every frame or on every physics step to ensure that balls will bounce exactly when they collide.

      The following visualisation shows all pairs being tested for intersection per time interval:

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when being tested via <code>intersects()</code>.
        </div>
      </div>

      ## Performance, or lack thereof

      The naive algorithm runs in **O(n<sup>2</sup>)** time in [Big O terms](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of n balls, the algorithm's run time grows proportionally to the *square* of the input n. That's a lot! üìà

      This is because for n balls, there are around __(n&nbsp;*&nbsp;(n-1))/2__ pairs to check, or __0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n__. Like for n = 5, there are a total of 10 pairs. For n = 10, 45 pairs. And so on. This information about the algorithm‚Äôs scalability is simplified using Big O to just __‚ÄúO(n<sup>2</sup>)‚Äù__.

      The following quickly demonstrates how the performance scales badly for bigger inputs, here n&nbsp;=&nbsp;12:

      <div class="demo-row">
        <sap-demo
          balls="10"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          12 balls = 66 pairs to check
        </div>
      </div>

      Clearly, the naive solution does not scale well for large numbers of objects.
 
      <box-note>Before anything else, note that the worst case for *any* collision detection algorithm is always __O(n<sup>2</sup>)__. That happens when all objects are intersecting simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions. Thus, it‚Äôs more practical to compare the average and best cases. You can also consider [expressing run time in terms of output](https://en.wikipedia.org/wiki/Output-sensitive_algorithm).</box-note>

      Having said that, the naive algorithm is still **Œò(n<sup>2</sup>)** for _any_ case, no matter the number of actual collisions. There is a lot of room to improve the solution.

      ## Prologue: Improving the solution

      <box-note>
        There are many ways to optimise collision detection, like spatial hashing and space partitioning trees. But this post is about one algorithm in particular.
      </box-note>

      Usually when optimising algorithms, you wanna find **redundant or unnecessary work**. Surely there is something redundant in checking every object against every other object, right?

      Let‚Äôs dig into the `intersects()` check, the one performed for every candidate pair. If we take our [typical object intersection check](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html), we get a bunch of simple inequality checks:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
      && object1.right > object2.left
      && object1.top < object2.bottom
      && object1.bottom > object2.top;
}

// Define the structure just so we‚Äôre on the same page
type Object = {
  left: number;   // x-coordinate of left edge
  right: number;  // x-coordinate of right edge
  top: number;    // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      In the above code, the `intersects()` function checks if the two objects‚Äô bounds overlap by comparing opposing edges from the two objects. (Refer to [this nice MDN article about overlapping bounding boxes](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb) for a better explanation.)

      For now, let's focus on just one dimension, say *x*. Bear with me as I further scope down the check to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don't worry; this scoped-down definition is a surprise tool that can help us later.

      Ok, the reason this will work is because of the `&&` operator's short-circuit evaluation. That is, if any of the operands is false, then the whole expression becomes false. So if two objects do not overlap in the x-axis, then we can immediatel rule them out as a candidate pair. 

      Thus, even doing an optimisation in just the x dimension will still significantly reduce the amount of checks.

      Now, let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in the specific configuration as illustrated:

      <blog-media
        alt="Three objects, from left to right: A, B, and C"
        :src="url('abc.png')" />

      There are three potential pairs to be checked here: A-B, B-C, and A-C. If we run them through the redefined `intersects()` function,

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Remember, we‚Äôre trying to find redundant work. Looking closer, if we inline the `intersects()` function we get:

      <code-block :code="`\
A.right > B.left // returns false
B.right > C.left // returns false
A.right > C.left // returns false`" />

      See any redundant work? Maybe abstractify it a little&hellip;

      <code-block :code="`\
A > B // returns false
B > C // returns false
A > C // returns false`" />

      In this form, unnecessary work is revealed! Due to the transitive property of inequality, we realise that we don‚Äôt need to compute the third check! *If we know A&nbsp;>&nbsp;B and B&nbsp;>&nbsp;C are false, then we don't need to calculate A&nbsp;>&nbsp;C.*

      So in this example, we don't really need to check `intersects(A, C)`. We‚Äôve skipped one check!

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// I know intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to general n-body collision detection. You might also have realised that this skip only works if A, B, and C are in a particular order. üôà Try **dragging** the balls below to see when the optimisation applies and when it does not:

      <div class="demo-row">
        <sap-demo
          id="abc-demo"
          balls="[[200,250,50],[300,150,55],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// A > B returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// B > C returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// A > C returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C), A > C will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
      </div>

      <script client defer>
        (()=> {
          const abcDemo = document.querySelector("#abc-demo");
          const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
          const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
          const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
          const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
          const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");
          
          abcDemo.addEventListener("simulate", throttle((event) => {
            const [A, B, C] = event.balls;
            setText(intersectsAbReturn, String(A.x > B.x));
            setText(intersectsBcReturn, String(B.x > C.x));
            setText(intersectsAcReturn, String(A.x > C.x));
            const acRuns = (A.x > B.x) !== (B.x > C.x);
            setShow(intersectsAcRun, acRuns);
            setShow(intersectsAcSkip, !acRuns);
          }));

          function setText(elements, text) {
            for (const element of elements)
              if (element.textContent !== text)
                element.textContent = text;
          }

          function setShow(elements, show) {
            for (const element of elements)
              if ((element.offsetParent != null) !== show)
                element.style.display = show ? "block" : "none";
          }
        })();
      </script>

      While it‚Äôs true that this principle only works when A, B, and C are ordered left-to-right, remember that these labels are *arbitrary*. What if we just decide to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable!
      
      Hang on&hellip; labeling objects according to a defined order is essentially ‚ú®**sorting**‚ú®! What if we sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?

      ## Chapter 1. Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free.
      
      Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in O(n log n) time which is certainly better than O(n<sup>2</sup>) of the naive solution.

      As hinted by the tri-object example above, sorting the list of objects merely by their x position can help remove ranges of potential pairs that need to be checked.
      
      However, objects aren't zero-width points! They‚Äôre chunky, which means they have a size thus occupy an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one sort by x position if objects span across intervals in the x-axis?
 
      We can account for the width of objects while keeping the benefits of unambiguous sort order by tracking the left and the right edges of each object as two separate points!

      See how it would work by playing with this **draggable** demo. The left and right edges of each ball are visualised. These edge points are stored in a sorted array shown below the box.

      <div class="demo-row">
        <sap-demo
          id="edges-demo"
          balls="6"
          strategy="sap-nativesort"
          static draggable rainbow
          decorations="edges" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo"></div>
      </div>

      This is the setup we need to minimise our `intersects()` calls. If you remember the `intersects()` function, here it is with only the x-axis checks:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
      && object1.right > object2.left;
}`" />

      We can replace these x-coordinate comparisons with an approach based on array indices. Since we have a sorted list of every object's left and right points, finding overlaps via index-based searches would be faster than global pairwise testing.

      Take one ball for example. When you have the indices of its left and right points, you can simply run through all points in-between those two edges in the array to get all overlapping objects. This is a very fast linear operation.

      Try **dragging** the highlighted ball below and observe the enclosed edges:

      <div class="demo-row">
        <sap-demo
          id="edges-demo-one"
          balls="6"
          strategy="sap-nativesort" 
          static draggable
          decorations="edges:focus:#4c8:#d88" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo-one"></div>
      </div>

      <box-note>One minor issue with the above 1-to-n approach is that an overlap can be missed if another ball is larger than the current ball. The larger ball can overlap the smaller ball without having any edge points inside of the smaller ball‚Äôs enclosure.</box-note>

      The above is a simple 1-to-n overlap detection. For n-to-n overlap detection, it turns out there is a way to find them across all objects in a single pass!

      ## Chapter 2. Sweeping

      To generalise the above to an n-interval overlap scan, imagine a vertical line sweeping across the whole space from left to right. The sweep will scan each edge point in order and keep track of the objects it touches.

      Whenever it encounters an object (a left edge), the object is added to an <span style="color:#d88">`inside`</span> set.
      
      Whenever it exits an object (right edge), the object is removed from the set. For now, let‚Äôs see what that looks like without collision:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges" />
        <div class="demo-caption">
          <code style="color:#d88">inside</code> objects are lit up in <span style="color:#d88">pink</span>.
        </div>
      </div>

      The <span style="color:#d88">`inside`</span> set tracks the set of objects that are currently touching the line.
      
      Of course, the line is merely a metaphor for iterating through the sorted list of edges. Here‚Äôs the code for the actual sweeping:

      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      Once we have a working `inside` set, detecting overlaps is easy. Whenever we‚Äôre entering a new object (a left edge), we can mark it as overlapping with each of the current objects `inside` the set.

      Another way to put it is, objects that have been `inside` the set simultaneously must be x-overlapping.

      Here‚Äôs the updated code for detecting and reporting overlaps:
      
      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    
    // the new object is overlapping with the existing ones
    for (const other of inside) {
      onOverlap(other, edge.object);
    }
    
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      Watch closely as the line enters a ball while having existing `inside` balls:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges,checks:#4c8:600" />
        <div class="demo-caption">
          X-overlapping pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> as the line sweeps.
        </div>
      </div>

      <box-note>The sweep-and-prune algorithm is also known sort-and-sweep.</box-note>

      ## Chapter 3. Pruning

      Sorting and sweeping only work in a single dimension. But balls aren't unidimensional objects! We‚Äôve gone from having abstract zero-dimensional point balls, to 1D balls as intervals in the x-axis. How do we account for the other dimension, y? This is the final frontier, as any such technique could be applied to z (or higher dimensions if you‚Äôre into that).

      One option is to perform a second sweep for the y-axis. That is, we maintain separate sorted lists of edges for each axis. Indeed, this is how the full sweep-and-prune implementation works as described in the [original paper by D. Baraff](https://ecommons.cornell.edu/handle/1813/7115). Object pairs are then flagged for overlaps in each dimension. In the case of 2D, pairs flagged twice (x-overlap && y-overlap) are intersecting.

      <box-note>
        The "prune" in sweep-and-prune refers to the elimination of candidate pairs during the sweeps in each dimension.
      </box-note>

      However, there is a simpler solution that is easier to implement and generalise. Do the sweep check in the x-axis as usual. Then, for the x-overlapping pairs, do a real check for intersection using the rest of the dimensions, like y and possibly z if 3D.

      Recall the above code which calls `onOverlap` on the pairs that passed pruning. This is the callback where we can check for the y dimension, e.g.:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  if (object1.top < object2.bottom && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      While the above formula generally works for game objects with an upright hitbox, a more precise and time-consuming check could be done at this level since most of the candidates have already been pruned. Our ball example works better with the following exact intersection check for circles:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  const distance = Math.sqrt(Math.pow(object1.x - object2.x, 2) + Math.pow(object1.y - object2.y, 2));
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      This multi-level checking is split into what is called broad-phase and narrow-phase detection. The broad-phase is the 1D sweep-and-prune which eliminates most candidate pairs, while the narrow-phase is the exact circle intersection test.

      Finally, implementing `bounce()` using physically-based physics, the result is this:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Ball sim using sweep-and-prune. <code>onOverlap()</code> calls highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      Notice the minimised number of pairs needed to be checked in the sweep-and-prune version. It‚Äôs a simple and elegant algorithm!

      ## Performance of sweep-and-prune

      Compared to the naive algorithm, the sweep-and-prune algorithm results in much less checks performed per frame. If your intersection checks are expensive, e.g. complex 3D objects, it‚Äôs going to be a big time-saver as a broad-phase technique.
      
      Look at the following side-by-side comparison and observe the amount of intersection checks required per frame:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="pairwise"
          skip-interval="2"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Global pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sweep and prune</div>
      </div>

      Let‚Äôs analyse the time complexity!
      
      A run of sweep-and-prune consists of a sort and a sweep.
      
      The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would be **O(n log n)**.
      
      The sweep, which is a linear pass with an inner loop for overlaps, should be **O(n)** in the average case. That is if the average case is mostly evenly-distributed object groups and only a few pairs actually intersecting at a time, which I think is a reasonable assumption.
 
      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const inside = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      // zero at best; some constant on average; O(n) at worst
      for (const other of inside) {
        onOverlap(other, edge.object);
      }
      inside.add(edge.object);
    } else {
      inside.delete(edge.object);
    }
  }
}`" />

      This means sweep-and-prune is **O(n log n)** on average, a big improvement over the naive approach‚Äôs O(n<sup>2</sup>)!

      That‚Äôs great, but *can we do better?*

      ## A small detail, big improvement

      Again, let's ask the question: Where is redundant work being done here?

      We can start by looking at the sort step, the bottleneck of the algorithm as found in the time complexity analysis.
      
      The following is a visualisation of the sorting of the edges array, using an optimised [quicksort](https://en.wikipedia.org/wiki/Quicksort):

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-quicksort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      As you can see most of the time, the sort does nothing at all! The list is almost always already sorted from the previous frame.
      
      Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one frame.

      It would take a majority of fast-moving balls to significantly disrupt the sort done in the previous frame.

      Luckily, the subject of sorting algorithms is well-researched. We‚Äôre dealing with a special state, the state of being *almost sorted*. And one great choice for sorting almost-sorted lists is [**insertion sort**](https://en.wikipedia.org/wiki/Insertion_sort)!

      Insertion sort has a run time of O(n) at best when the list is already sorted or almost sorted, and O(n<sup>2</sup>) at worst. We can argue that the average case is **O(n)**, since the list is almost always sorted due to the previous frame‚Äôs sort.

      Here‚Äôs insertion sort in action:

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-insertionsort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      <box-note>
        Due to the sweeping mechanism and the insertion sort, it‚Äôs important to consider the primary axis of the sweep-and-prune algorithm. It should be the axis where objects are most widely distributed to minimize swaps and overlaps. In a side-scroller for example, the primary axis should be horizontal.
      </box-note>

      ## Another improvement

      There is yet another optimisation that could be made. In the insertion sort example above, you can observe that <span style="color:#f00">swaps</span> happen when an edge point passes through another.

      An edge point passing through another can mean one of these four things:

      ### case R ‚Üî L

      When a right edge from the left swaps with a left edge from the right, we can infer that the left object is starting to intersect the right object.

      ### case L ‚Üî R

      Conversely, when a left edge from the left swaps with a right edge from the right, the corresponding objects cease to intersect.

      ### case L ‚Üî L, R ‚Üî R

      Edges of the same polarity can swap without affecting the state of intersection of their corresponding objects.

      ## Run time comparison

      | Algorithm                   | Worst case       | Average case     | Best case        | 
      |-----------------------------|------------------|------------------|------------------|
      | Pairwise                    | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
      | Sweep-and-prune (quicksort) | O(n<sup>2</sup>) | O(n log n)       | O(n log n)       |
      | Sweep-and-prune (insertion) | O(n<sup>2</sup>) | O(n + m)         | O(n)             |

      n = number of balls, m = number of collisions

      ## Variants

      No extra storage, sort by min x, might be n^2

      ## Be practical

      Forget about theory. Forget about sorting algorithms. It was a fun exercise, but real world is different. Using your standard library's sort function is usually the best option as it's most likely optimised for the runtime environment. It‚Äôs also likely to implement [**Timsort**](https://en.wikipedia.org/wiki/Timsort) anyway, which is a sorting algorithm based on merge sort and *insertion sort*.

      But if you really wanna be practical, use a physics engine or a game engine. üòâ

      As always, run benchmarks.

      ## Appendix

      Things I‚Äôve noted or realised while writing this post:
      
      * General algorithm design insights
        * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
          * Some power when linearly scanning over the list
          * Faster range / adjacency checks
          * (unrelated, but good to bring up) Binary search
        * Different sorting algorithms have situational strengths.
      * I might need a frontend framework for my blog now, at least for the interactive demos.
        * Vanilla JS is starting to get scary with bigger demos like these.
        * `.mjs` is pretty good though.

      Bonus demo, 25 balls! It‚Äôs a ball party ‚öΩ‚öæüèÄüèê
      <div class="demo-row">
        <sap-demo balls="25" rainbow strategy="sap-nativesort" />
      </div>
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .demo-caption {
    max-width: 600px;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }

  .edges-array {
    position: relative;
    width: 100%;
    height: 20px;
  }
  .edge {
    position: absolute;
    width: 10px;
    height: 20px;
    background: #fff;
    transition: transform 0.2s;
  }
  .edge-left {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .edge-right {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
</style>

<script client defer>
  const edgesArrays = document.querySelectorAll(".edges-array");

  for (const edgesArray of edgesArrays) {
    const target = document.querySelector(edgesArray.dataset.target);

    const edgeToElement = new Map();

    target.addEventListener(
      "sap-sort",
      throttle((event) => {
        const { edges } = event;
        const n = edges.length;

        if (edgeToElement.size === 0) {
          for (const edge of edges) {
            const edgeElement = document.createElement("div");
            edgeElement.classList.add("edge");
            edgeElement.classList.add(
              edge.dir < 0 ? "edge-left" : "edge-right"
            );
            edgeElement.style.display = "none";
            edgesArray.appendChild(edgeElement);
            edgeToElement.set(edge, edgeElement);
          }
        }

        const width = edgesArray.getBoundingClientRect().width;

        for (const [edge, edgeElement] of edgeToElement.entries()) {
          const index = edges.indexOf(edge);
          const x = width / 2 + 20 * (index - (n - 1) / 2);
          edgeElement.style.display = "block";
          edgeElement.style.backgroundColor = edge.ball.color;
          edgeElement.style.transform = `translateX(calc(${x}px - 50%))`;
        }
      })
    );
  }

  function throttle(func, ms = 100) {
    let lastTime = Date.now();
    return (...args) => {
      if (Date.now() - lastTime < ms) return;
      lastTime = Date.now();
      func(...args);
    };
  }
</script>
