<html lang="en">
  <page-title title="Sweep and prune algorithm for collision detection" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sweep and prune algorithm for collision detection"
        :heroimgsrc="url('hero.png')" />

      <blog-post-info date="1 Jan 1970" read-mins="1" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      In video game programming, detecting collisions between objects is a common requirement. Consider the following ball simulation as a basic example. In this sim, multiple physics objects interact with each other. This requires a multi-object collision detection algorithm.

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      Each ball can potentially interact with *any other ball*. How do we implement the detection of such n-to-n collisions?

      ## Naive solution

      The naive solution is to check every potential pair of objects for collision. Continuing with the ball example, this means checking every ball for intersection with each of the other balls. This is done every frame to ensure balls bounce when they collide.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j]
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      <div class="demo-row">
        <sap-demo strategy="pairwise" highlight="checks" highlight-color="#4c8" skip-interval="5" />
        <div class="demo-caption">
          <span style="color:#4c8" class="pair-legend"></span> <code>intersects</code> calls are highlighted
        </div>
      </div>

      ## Performance

      The naive algorithm runs in **O(n<sup>2</sup>)** time. That is, for an input of n balls, the algorithm's run time grows proportionally to the *square* of the input n. That's a lot!

      This is because for n balls, there are around __(n&nbsp;*&nbsp;(n-1))/2__ pairs to check, or __0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n__. This translates to O(n<sup>2</sup>) in [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation).

      <div class="demo-row">
        <sap-demo balls="10" strategy="pairwise" highlight="checks" highlight-color="#4c8" skip-interval="5" />
        <div class="demo-caption">
          With just 12 balls, the checks have grown to an unacceptable number!
        </div>
      </div>

      To illustrate the scaling of the algorithm's performance, the following graph shows the number of `intersect` calls plotted against the input n.

      <!-- <sap-graph /> -->

      Clearly, the naive solution does not scale well for large numbers of objects.

      ## Improving the solution

      One common thought process when optimising algorithms is to find **redundant or unnecessary work**.

      <box-note>
        <p>There are many ways to optimise collision detection, like spatial hashing and space partitioning trees. But this post is about just one particular algorithm - the <strong>sweep and prune</strong> algorithm.</p>
        <p><strong>Disclaimer:</strong> The following is merely my attempt at rationalising the thinking behind the sweep-and-prune algorithm. I do not know how the algorithm was originally conceived.</p>
      </box-note>

      Let's start with our [typical object intersection check](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html), the one performed at each iteration of the inner loop. It's essentially a bunch of inequality checks:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
    && object1.right > object2.left
    && object1.top < object2.bottom
    && object1.bottom > object2.top;
}

// Define the structure just so we’re on the same page
type Object = {
  left: number; // x-coordinate of left edge
  right: number; // x-coordinate of right edge
  top: number; // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      For now, let's focus on just one dimension, say x. Bear with me as I further scope down the check to just one direction:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don't worry; this scoped-down definition is a surprise tool that can help us later in understanding the rationale behind the optimisation.

      (mickey meme)

      Okay, more seriously, one reason it works is because of the AND operator's (`&&`) short-circuit evaluation. If any one of the operands is false, then the whole expression becomes false. This can be reworded into the [separating axis theorem](https://www.sevenson.com.au/programming/sat/), which states that if there exists an axis where two objects' don't overlap, then they don't intersect at all. Thus even if we just did an optimisation in one dimension, it will still result less overall checks. So for now, let's just deal with the x axis.

      Now, let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - as illustrated below.

      (illustration)

      There are three potential pairs to be checked here: A-B, B-C, and A-C. Let's run them through the function:

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Digging deeper and expanding the `intersects` function:

      <code-block :code="`\
A.right > B.left // false
B.right > C.left // false
A.right > C.left // false`" />

      See any redundant work? Maybe simplify it a little more to an abstract level&hellip;

      <code-block :code="`\
A > B // false
B > C // false
A > C // false`" />

      There it is. The meat of the idea is that: if we know that A > B is false and B > C is false, then we don't need to calculate A > C to know that it too is false.

      Backing up to the function level. This means we don't need to check `intersects(A, C)` anymore. We skipped 1 check.

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to collision detection in general. Well, it’s true that this only works if A, B, and C are in a particular order. Try moving the balls below to see when the optimisation applies.

      ```
      // todo: live output of interactive controls below
      intersects(A, B)
      intersects(B, C)
      intersects(A, C)
      ```
      <sap-demo balls="[[100,250,50],[250,150,40],[450,275,60]]" labels="A,B,C" rainbow static draggable strategy="sap-nativesort" />

      todo: draggable indicator

      However, these labels are arbitrary&hellip; What if we just called the leftmost ball A, the middle ball B, and the rightmost C, at any point in time? Then the optimisation would always be applicable! But hang on&hellip; labeling objects according to a defined order is essentially **sorting**! What if we just sorted the list every time? Would the skipped checks be worth it?

      ## Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free. Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in O(n log n) time which is certainly better than O(n<sup>2</sup>) of the naive solution.

      As hinted by the 3-object example above, sorting the list of objects merely by their x position can help remove ranges of potential pairs that need to be checked. How can we generalise this to n objects?

      First, let's unwind the simplification we did earlier. Objects aren't zero-width points! Each object has a size - a certain width. We can account for the width all while keeping the benefits of unambiguous sort order by tracking the left and the right edges of each object as two separate points.

      <sap-demo balls="6" rainbow static draggable highlight="sap-edges" strategy="sap-nativesort" />

      todo: linear row of deges (separate component)

      You can probably guess where this is going. Remember the `intersects` function? This is it scoped down to the x axis:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
    && object1.right > object2.left;
}`" />

      Since we have a sorted list of every object's left and right points, it’s faster to find overlaps by doing local index-based searches rather than global pairwise testing.

      (todo) how to isolate one object without needing to pass through all items finding overlapping object2s

      <sap-demo balls="6" rainbow static draggable highlight="sap-edges" strategy="sap-nativesort" />

      ## Sweeping

      (todo) Scanning from left to right and keeping track of which objects we're currently *inside of*.

      <sap-demo highlight="sap-inside" strategy="sap-nativesort" />

      Here’s the code for scanning (*sweeping*) to track when we're inside which objects:

      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      At each left edge, we add the corresponding object to the *inside* list. At the same time, at a left edge, we're entering a new object - that is the definition of the left edge, an entry point. This means, if we're already inside other objects, and we enter a left edge, it follows that this edge's object intersects with the other objects.

      Here's the updated code for detecting and reporting intersections:
      
      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    
    // if still inside other objects, they must intersect the new one
    for (const other of inside) {
      onIntersect(other, edge.object);
    }
    
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      <sap-demo highlight="checks" strategy="sap-nativesort" />

      ## Pruning

      The above sweeping only works in a single dimension due to the previous simplification we did earlier reducing the checks down to one dimension, x. Balls aren't one-dimensional objects! How do we account for the other dimension, y?

      The thing is, sorting works best in one dimension, so we'll compromise. We'll do a sweep check in one dimension, x, to get a shortlist of object pairs with overlapping x spans. On the shortlisted pairs, we check for intersection in the rest of their dimensions, y and possibly z if 3D.

      <box-note>
        The "prune" in sweep-and-prune refers to the elimination of object pairs from the shortlist.
      </box-note>

      The above code calls `onIntersect` on the object pairs that passed pruning. This is where we can check for the y dimension.

      <code-block :code="`\
onIntersect = function(object1, object2) {
  if (object1.top < object2.bottom && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      The above formula works generally for game objects with an axis-aligned hitbox. Our ball example works better with the following circle intersection formula:

      <code-block :code="`\
onIntersect = function(object1, object2) {
  const distance = Math.sqrt(Math.pow(object1.x - object2.x, 2) + Math.pow(object1.y - object2.y, 2));
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      <sap-demo highlight="checks" strategy="sap-nativesort" />

      ## Performance of sweep-and-prune

      A run of sweep-and-prune consists of a sort and a sweep. The sweep is a linear pass on the input so it's just O(n). The sort - let's take the "fastest" sorting algorithm, mergesort or quicksort - would be O(n log n).

      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const inside = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      for (const other of inside) {
        onIntersect(other, edge.object);
      }
      inside.add(edge.object);
    } else {
      inside.delete(edge.object);
    }
  }
}`" />

      <b-x-note>The sweep-and-prune algorithm is also known sort-and-sweep.</b-x-note>

      This means sweep-and-prune is O(n log n), a big improvement over the naive O(n<sup>2</sup>)!

      (todo: graph vs)

      (todo: check native sort (timsort) vs quicksort)

      *Can we do better?*

      ## A small change, big improvement (?)

      Again, let's ask the question: Where is redundant work being done here?

      <sap-demo highlight="sort" strategy="sap-nativesort" />

      As you can see, sort does nothing most of the time! Most of the time, the list is already sorted due to the previous frame's sort. Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places from the previous frame.

      Luckily, the subject of sorting algorithms is well-researched. For almost-sorted lists, insertion sort is a good choice.

      Insertion sort has a run time of O(n) at best when the list is already sorted, and O(n<sup>2</sup> ) at worst. However, we can argue that the average case is O(n), since the list is almost always almost sorted.

      <sap-demo highlight="sort" strategy="sap-nativesort" />

      With insertion sort, it's important to consider the primary axis of the sweep-and-prune algorithm. It should be the axis where objects are most evenly distributed to minimize swaps. In a side-scroller for example, that would be the horizontal axis.

      (todo: check native sort (timsort) vs insertionsort)

      ## Less theoretical, more practical

      Forget about theory. (todo)

      Using your standard library's sort function is usually the best as it's most likely optimised for the runtime.

      (todo: check if native sort is still best)

      # Conclusion

      General algorithm design insights
      * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
        * Single linear pass over the list
        * (unrelated, but good to bring up) Binary search
      * Different sorting algorithms have situational strengths
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }
</style>
