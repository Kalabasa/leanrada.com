<html lang="en">
  <page-title title="Sweep and prune algorithm for collision detection" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sweep and prune algorithm for collision detection"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="1 Aug 2023" read-mins="17" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      In video game programming, detecting collisions between objects is a common requisite. Consider the following ball simulation as a basic example:

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      In physics simulations like this, an object can collide with any other object. This requires a multi-object collision detection algorithm.

      How do we implement the detection of such n-to-n collisions?

      ##  Naive approach

      The naive solution is to check every potential pair of objects for collision. Continuing with the ball example, this means checking every ball for intersection against each of the other balls.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j]
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Note the inner loop starts at `i + 1` to prevent duplicate pairs (A-B vs B-A). Other than that, it’s a pretty straightforward solution.

      These checks are done every frame to ensure balls bounce exactly when they collide.

      The following visualisation shows all pairs being tested for intersection per frame:

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when tested via <code>intersects()</code>.
        </div>
      </div>

      ## Performance, or lack thereof

      The naive algorithm runs in **O(n<sup>2</sup>)** time in [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of n balls, the algorithm's run time grows proportionally to the *square* of the input n. That's a lot! 📈📈📈

      This is because for n balls, there are around __(n&nbsp;*&nbsp;(n-1))/2__ pairs to check, or __0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n__. This is simplified to __O(n<sup>2</sup>)__ in Big O notation.

      The following quickly demonstrates how the performance scales badly for bigger inputs, here n&nbsp;=&nbsp;12:

      <div class="demo-row">
        <sap-demo
          balls="10"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          12 balls = 66 pairs to check
        </div>
      </div>

      Clearly, the naive solution does not scale well for large numbers of objects.
 
      <box-note>Before anything else, note that the worst case for any collision detection algorithm is always <strong>O(n<sup>2</sup>)</strong>. That is when all objects are intersecting simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions. Thus, it’s more practical to compare the average and best cases. You can also consider [expressing run time in terms of output](https://en.wikipedia.org/wiki/Output-sensitive_algorithm).</box-note>

      Having said that, the naive algorithm is still **Θ(n<sup>2</sup>)** for _any_ case, no matter the number of actual collisions. There is a lot of room to improve the solution.

      ## Prologue: Improving the solution

      One common thought process when optimising algorithms is to find **redundant or unnecessary work**.

      <box-note>
        There are many ways to optimise collision detection, like spatial hashing and space partitioning trees. But this post is about the <strong>sweep and prune</strong> algorithm.
      </box-note>

      Let's start with our [typical object intersection check](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html), the one performed for every candidate pair. It's essentially a bunch of inequality checks:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
    && object1.right > object2.left
    && object1.top < object2.bottom
    && object1.bottom > object2.top;
}

// Define the structure just so we’re on the same page
type Object = {
  left: number; // x-coordinate of left edge
  right: number; // x-coordinate of right edge
  top: number; // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      In the above code, the `intersects()` function checks if the two objects’ bounds overlap by comparing opposing sides from the two objects. (Refer to [this nice MDN article about overlapping bounding boxes](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb) for a better explanation.)

      For now, let's focus on just one dimension, say *x*. Bear with me as I further scope down the check to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don't worry; this scoped-down definition is a surprise tool that can help us later.

      One reason it works is because of the AND operator's (`&&`) short-circuit evaluation. If any of the operands is false, then the whole expression becomes false. This can be reworded into the [separating axis theorem](https://www.sevenson.com.au/programming/sat/), which states that if there exists an axis where two objects don't overlap, then it follows that they don't intersect at all. Thus, even if we did an optimisation in just one dimension, it will still significantly reduce the amount of checks. So for now, let's just deal with the x axis.

      Now, let's look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in the specific configuration as illustrated:

      <blog-media
        alt="Three objects, from left to right: A, B, and C"
        :src="url('abc.png')" />

      There are three potential pairs to be checked here: A-B, B-C, and A-C. Let's run them through the `intersects()` function:

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      If we inline the `intersects()` function (scoped down to one x direction), we get:

      <code-block :code="`\
A.right > B.left // returns false
B.right > C.left // returns false
A.right > C.left // returns false`" />

      See any redundant work? Maybe let’s abstractify it a little&hellip;

      <code-block :code="`\
A > B // returns false
B > C // returns false
A > C // returns false`" />

      In this form the unnecessary work is revealed. The point is: due to the transitive property of inequality, we don’t need to compute the third check! *If we know A > B and B > C are false, then we don't need to calculate A > C.*

      And as mentioned above, if one bounds check is false, we don’t need to calculate the full `intersects()` check.
      
      In this example, we don't need to check `intersects(A, C)` anymore. We skipped one check!

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// I know intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to collision detection in general. You might also have realised that this only works if A, B, and C are in a particular order. Try **dragging** the balls below to see when the optimisation applies:

      <div class="demo-row">
        <sap-demo
          id="abc-demo"
          balls="[[200,250,50],[300,150,55],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// A > B returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// B > C returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// A > C returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C), A > C will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
      </div>

      <script client defer>
        (()=> {
          const abcDemo = document.querySelector("#abc-demo");
          const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
          const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
          const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
          const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
          const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");
          
          abcDemo.addEventListener("simulate", throttle((event) => {
            const [A, B, C] = event.balls;
            setText(intersectsAbReturn, String(A.x > B.x));
            setText(intersectsBcReturn, String(B.x > C.x));
            setText(intersectsAcReturn, String(A.x > C.x));
            const acRuns = (A.x > B.x) !== (B.x > C.x);
            setShow(intersectsAcRun, acRuns);
            setShow(intersectsAcSkip, !acRuns);
          }));

          function setText(elements, text) {
            for (const element of elements)
              if (element.textContent !== text)
                element.textContent = text;
          }

          function setShow(elements, show) {
            for (const element of elements)
              if ((element.offsetParent != null) !== show)
                element.style.display = show ? "block" : "none";
          }
        })();
      </script>

      While it’s true that the principle only works if A, B, and C are ordered left-to-right, remember that these labels are *arbitrary*. What if we just decide to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable!
      
      Hang on&hellip; labeling objects according to a defined order is essentially ✨**sorting**✨! What if we just sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?

      ## Chapter 1. Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free.
      
      Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in O(n log n) time which is certainly better than O(n<sup>2</sup>) of the naive solution.

      As hinted by the 3-object example above, sorting the list of objects merely by their x position can help remove ranges of potential pairs that need to be checked. However, objects aren't zero-width points! Each object has a size - it occupies a certain width in the x-axis. How do we sort by x position if objects span along the x-axis?
      
      We can account for the width of objects while keeping the benefits of unambiguous sort order by tracking the left and the right edges of each object as two separate points!

      This **draggable** demo visualises the left and right edges of each ball. These edge points are stored in a sorted array shown below.

      <div class="demo-row">
        <sap-demo
          id="edges-demo"
          balls="6"
          strategy="sap-nativesort"
          static draggable rainbow
          decorations="edges" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo"></div>
      </div>

      Remember the `intersects()` function? Consider the x-axis overlap checks:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
    && object1.right > object2.left;
}`" />

      We can replace these x-coordinate comparisons with an array index-based search. Since we have a sorted list of every object's left and right points, finding overlaps would be faster via index-based searches rather than global pairwise testing.

      For example, take one object, when you have the indices of its left and right points, you can simply run through all points between them in the array to get its overlapping objects. This is a very fast linear operation.

      Try **dragging** the highlighted ball below and observe the enclosed edges:

      <div class="demo-row">
        <sap-demo
          id="edges-demo-one"
          balls="6"
          strategy="sap-nativesort" 
          static draggable
          decorations="edges:focus:#4c8:#d88" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo-one"></div>
      </div>

      <box-note>One minor issue with the above example is if another ball is larger than the current ball, an overlap can be missed. The other ball can overlap the current ball without having any edge points inside of it by enclosing the current ball in the x-axis.</box-note>

      It turns out there is a way to check for overlaps in all objects within a single pass!

      ## Chapter 2. Sweeping

      To generalise the above 1-to-n overlap search to an n-to-n overlap scan, imagine a vertical line sweeping across the whole space from left to right. Whenever it encounters an object (a left edge), the object is added to an <span style="color:#d88">`inside`</span> set.
      
      Whenever it exits an object (right edge), the object is removed from the set. For now, let’s see what that looks like without collision:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges" />
      </div>

      The <span style="color:#d88">`inside`</span> set tracks the set of objects that are currently touching the line. They’re colored <span style="color:#d88">pink</span> in the animation above
      
      Of course, there’s not really a line that would sweep through space. Iterating through the sorted list of edges is close enough. Here’s the code for sweeping🧹:

      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      At the same time, encountering a left edge means we're entering a new object. If we’re already inside other objects, the current edge’s object must overlap with the other `inside` objects as well.

      Another way to put it is, objects that have been `inside` simultaneously must be overlapping in the x-axis.

      Here’s the updated code for detecting and reporting overlaps:
      
      <code-block :code="`\
const inside = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    
    // if still inside other objects, they must overlap the new one
    for (const other of inside) {
      onOverlap(other, edge.object);
    }
    
    inside.add(edge.object);
  } else {
    // exiting an object
    inside.delete(edge.object);
  }
}`" />

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges,checks:#4c8:600" />
        <div class="demo-caption">
          X-overlapping pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      ## Chapter 3. Pruning

      The sweeping mechanism only works in a single dimension. But balls aren't one-dimensional objects! How do we account for the other dimension, y?

      One option is to perform a second sweep for the y-axis. That is, we maintain a separate list of edges for the y-axis. Object pairs are then flagged for overlaps in each sweep in the x and y dimensions. Pairs flagged twice (x-overlap && y-overlap) intersect.

      <box-note>
        The "prune" in sweep-and-prune refers to the elimination of candidate pairs during the sweeps in each dimension.
      </box-note>

      However, there is a simpler solution that is easier to implement and generalise. Do the sweep check in the x-axis as usual. Then, for the x-overlapping pairs, do a real check for intersection using the rest of the dimensions, like y and possibly z if 3D.

      Recall the above code which calls `onOverlap` on the pairs that passed pruning. This is the callback where we can check for the y dimension, e.g.:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  if (object1.top < object2.bottom && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      While the above formula generally works for game objects with an upright hitbox, a more precise and time-consuming check could be done at this level since most of the candidates have already been pruned. Our ball example works better with the following exact intersection check for circles:

      <code-block :code="`\
onOverlap = function(object1, object2) {
  const distance = Math.sqrt(Math.pow(object1.x - object2.x, 2) + Math.pow(object1.y - object2.y, 2));
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      With the `bounce()` function implemented according to physics, the result is this:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Ball sim using sweep-and-prune. <code>onOverlap()</code> calls highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      Notice the minimised number of pairs needed to be checked in the sweep-and-prune version. It’s a simple and elegant algorithm!

      ## Performance of sweep-and-prune

      Compared to the naive algorithm, the sweep-and-prune algorithm results in much less checks performed per frame. If your intersection checks are expensive, e.g. complex 3D objects, it’s going to be a big time-saver.
      
      Look at the following side-by-side comparison and observe the amount of intersection checks required per frame:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="pairwise"
          skip-interval="2"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Naive pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sweep and prune</div>
      </div>

      Let’s analyse the time complexity!
      
      A run of sweep-and-prune consists of a sort and a sweep.
      
      The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would be **O(n log n)**.
      
      The sweep, which is a linear pass with an inner loop for overlaps, should be **O(n)** in the average case. That is if the average case is mostly evenly-distributed object groups and only a few pairs actually intersecting at a time, which I think is a reasonable assumption.
 
      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const inside = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      // zero at best; some constant w.r.t. input size on average
      for (const other of inside) {
        onOverlap(other, edge.object);
      }
      inside.add(edge.object);
    } else {
      inside.delete(edge.object);
    }
  }
}`" />

      This means sweep-and-prune is **O(n log n)** on average, a big improvement over the naive approach’s O(n<sup>2</sup>)!

      <box-note>The sweep-and-prune algorithm is also known sort-and-sweep.</box-note>

      That’s great, but *can we do better?*

      ## A small detail, big improvement

      Again, let's ask the question: Where is redundant work being done here?

      We can start by looking at the sort step, the bottleneck of the algorithm as found in the time complexity analysis.
      
      The following is a visualisation of the sorting of the edges array, using an optimised [quicksort](https://en.wikipedia.org/wiki/Quicksort):

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-quicksort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      As you can see most of the time, the sort does nothing at all! The list is almost always already sorted from the previous frame.
      
      Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one frame.

      It would take a majority of fast-moving balls to significantly disrupt the sort done in the previous frame.

      Luckily, the subject of sorting algorithms is well-researched. We’re dealing with a special state, the state of being *almost sorted*. And one great choice for sorting almost-sorted lists is [**insertion sort**](https://en.wikipedia.org/wiki/Insertion_sort)!

      Insertion sort has a run time of O(n) at best when the list is already sorted or almost sorted, and O(n<sup>2</sup>) at worst. We can argue that the average case is **O(n)**, since the list is almost always sorted due to the previous frame’s sort.

      Here’s insertion sort in action:

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-insertionsort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      <box-note>
        Due to the sweeping mechanism and the insertion sort, it’s important to consider the primary axis of the sweep-and-prune algorithm. It should be the axis where objects are most widely distributed to minimize swaps and overlaps. In a side-scroller for example, the primary axis should be horizontal.
      </box-note>

      ## Run time comparison

      | Algorithm                   | Worst case       | Average case     | Best case        | 
      |-----------------------------|------------------|------------------|------------------|
      | Pairwise                    | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
      | Sweep-and-prune (quicksort) | O(n<sup>2</sup>) | O(n log n)       | O(n log n)       |
      | Sweep-and-prune (insertion) | O(n<sup>2</sup>) | O(n + m)         | O(n)             |

      n = number of balls, m = number of collisions

      ## Be practical

      Forget about theory. Forget about sorting algorithms. It was a fun exercise, but real world is different. Using your standard library's sort function is usually the best option as it's most likely optimised for the runtime environment. It’s also likely to implement [**Timsort**](https://en.wikipedia.org/wiki/Timsort) anyway, which is a sorting algorithm based on merge sort and *insertion sort*.

      But if you really wanna be practical, use a physics engine or a game engine. 😉

      As always, run benchmarks.

      ## Appendix

      Things I’ve noted or realised while writing this post:
      
      * General algorithm design insights
        * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
          * Some power when linearly scanning over the list
          * Faster range / adjacency checks
          * (unrelated, but good to bring up) Binary search
        * Different sorting algorithms have situational strengths.
      * I might need a frontend framework for my blog now, at least for the interactive demos.
        * Vanilla JS is starting to get scary with bigger demos like these.
        * `.mjs` is pretty good though.

      Bonus demo, 25 balls! It’s a ball party ⚽⚾🏀🏐
      <div class="demo-row">
        <sap-demo balls="25" rainbow strategy="sap-nativesort" />
      </div>
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .demo-caption {
    max-width: 600px;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }

  .edges-array {
    position: relative;
    width: 100%;
    height: 20px;
  }
  .edge {
    position: absolute;
    width: 10px;
    height: 20px;
    background: #fff;
    transition: transform 0.2s;
  }
  .edge-left {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .edge-right {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
</style>

<script client defer>
  const edgesArrays = document.querySelectorAll(".edges-array");

  for (const edgesArray of edgesArrays) {
    const target = document.querySelector(edgesArray.dataset.target);

    const edgeToElement = new Map();

    target.addEventListener(
      "sap-sort",
      throttle((event) => {
        const { edges } = event;
        const n = edges.length;

        if (edgeToElement.size === 0) {
          for (const edge of edges) {
            const edgeElement = document.createElement("div");
            edgeElement.classList.add("edge");
            edgeElement.classList.add(
              edge.dir < 0 ? "edge-left" : "edge-right"
            );
            edgeElement.style.display = "none";
            edgesArray.appendChild(edgeElement);
            edgeToElement.set(edge, edgeElement);
          }
        }

        const width = edgesArray.getBoundingClientRect().width;

        for (const [edge, edgeElement] of edgeToElement.entries()) {
          const index = edges.indexOf(edge);
          const x = width / 2 + 20 * (index - (n - 1) / 2);
          edgeElement.style.display = "block";
          edgeElement.style.backgroundColor = edge.ball.color;
          edgeElement.style.transform = `translateX(calc(${x}px - 50%))`;
        }
      })
    );
  }

  function throttle(func, ms = 100) {
    let lastTime = Date.now();
    return (...args) => {
      if (Date.now() - lastTime < ms) return;
      lastTime = Date.now();
      func(...args);
    };
  }
</script>
