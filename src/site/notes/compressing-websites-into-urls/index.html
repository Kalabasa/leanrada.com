<html lang="en">
  <page-title title="Compressing a website into a URL" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Compressing a website into a URL"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="10 Oct 2023" read-mins="8" />

      <!-- textlint-disable -->

      <tag-row>
        <tag>js</tag>
      </tag-row>

      <!-- textlint-enable -->

      This post explains how [**portabl.ink**](https://portabl.ink) works. Portablink is a tool that creates self-contained compressed web pages in a single link. Check [portablink project page](/wares/portabl.ink/) for more info.

      tl;dr: It uses **data URLs** containing **compressed data** which is bundled with its own **decompression instructions**.

      ## Data URLs

      In case you aren’t familiar with [**data URLs**](https://en.wikipedia.org/wiki/Data_URI_scheme), they are URLs whose contents are in the URL itself. They all start with `data:`. Here, let me show you with this interactive mock browser:

      <window-decor>
        <div class="browser" data-rss="interactive">
          <div class="browser-bar">
            <button id="browserHomeButton" class="browser-bar-button">🛖</button>
            <input id="dataURLInput" class="browser-address" type="text" value="data:text/html,<i>Hello</i><b>World!</b>" />
            <button id="browserCopyButton" class="browser-bar-button">📋</button>
          </div>
          <iframe id="dataURLFrame" class="browser-viewport"></iframe>
        </div>
      </window-decor>

      _(Hint: edit the URL in the address bar!)_

      <script client async defer>
        (()=>{
          const input = document.getElementById("dataURLInput");
          const frame = document.getElementById("dataURLFrame");
          const home = document.getElementById("browserHomeButton");
          const copy = document.getElementById("browserCopyButton");
          
          input.addEventListener("focus", () => setTimeout(() => {
            const rect = frame.getBoundingClientRect();
            if (rect.bottom > window.innerHeight) {
              frame.parentElement.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          }));
          input.addEventListener("input", refresh);
          input.addEventListener("change", refresh);
          home.addEventListener("click", () => {
            input.value = input.getAttribute("value");
            refresh();
          });
          copy.addEventListener("click", async () => {
            await navigator.clipboard?.writeText(input.value);
            alert("URL copied!");
          });
          refresh();
          
          function refresh() {
            const isDataURL = input.value.startsWith("data:");

            if (!isDataURL) {
              alert("No cheating! Enter a data URL only");
              input.value = "data:text/html,";
            }

            frame.src = input.value;
          }
        })();
      </script>

      <style>
        .browser {
          display: flex;
          flex-direction: column;
          gap: 12px;
          width: 100%;
          box-sizing: border-box;
        }

        .browser-bar {
          display: flex;
          gap: 6px;
          padding: 0 6px;
        }

        .browser-bar-button {
          border: none;
          border-radius: 3px;
          font-size: 10px;
          width: 30px;
          background: none;
          color: transparent;
          text-shadow: 0 0 #fff;
          cursor: pointer;
        }
        .browser-bar-button:focus-visible,
        .browser-bar-button:hover {
          background: #fff2;
        }

        .browser-address {
          flex: 1 1 auto;
          border: none;
          border-radius: 3px;
          padding: 6px;
          background: #0004;
          color: #fff;
          font-family: system-ui;
        }
        
        .browser-viewport {
          border: none;
          background: white;
        }
      </style>

      When you load a data URL, the browser shows the content embedded in the URL directly.

      > So, that’s it? Website in a URL? — Data URL! Easy!
      
      Wait, there’s more! The portablink tool does some more things than just putting your HTML in a data URL. The tool also **compresses** your content so you don’t end up with humongous URLs.

      ## Compression

      Within a data URL, the tool bundles both the compressed data _and_ the instructions needed to decompress and bootstrap that data. This produces a self-contained, compressed document in a single portable link that can be decompressed and rendered by any modern browser.

      Here’s an example URL generated by the tool:

      <code-block class="data-url" language="html" code="
data:text/html,&lt;body onload=&quot;fetch`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68OyX8pDpSibDJhwqbGZbdrQpP/7DI7WpluDZPv8fb7Pd8dBXJqKJ3HJaJ7EBgxnyRJEi5aQhYbaIVk8dvhgEGvTdgZCqczbvV0RykHXnLazgrPdvEe2jTZQtGEmhWHCzDI7MeU4ymEjQjCs0id4Yc+GBa2At7MGQiUbkbMce9eg6AaERAuqGvRJmhIy9E3JLx7+3kB2q6nI8ZWsCqkMpXhBxZYqwN4HBZSjH04GLZbevxD6KHnu4SsbUmpdtGxUxkIrqMNaSdwbmikouggf7RhtFOSnSXeIS6CzQpuWhQ2zqfOmEnqmWM2o8S/xpFCBO3gPuSln76O7CoRDSgab0jyDusvSxhgp9k/F0fDAZtN3T24cBAuPvpGDUqlypmZacshRhFJOs9tTwZkwZZiVwHP/UgT4/3g4CfbP9ELOChMe4653rwqK4dtTPyPrl27x+NhC1nI913VSEudwhzJOtSZeV0mv67HY3YAgJ14UeUk8dsBLbnKGm57hoskZzTPc9AwXTc9onuGmJ1w8tvXoagTVBmmVEc9DUjClpCLegDODAG/xLa6wIqsIT/B0jUty8buRZg7CHrxeLj67LTZKkAg/kFxmTWW/uFFX8FW5HuB7UpNEM7OEisnG+L9IsqecKePXQ+dsm1XoN84O5i8VyMMjnkRRMMCU+DaggCT2ja/ccTcPYbi1N2XEah+Jm2NcbvnqlvWoorVvw/HVSMuK+S1J1IjdMdX6O5JQf4fboLuS1MHhcMK0ePcKszvDTMO/XBBc0Kqe99O9b/cD1UcDXQidsbVhpSRJR1Jk3P5zumRS63w4+N1yrPvNMZWVLfhPMlnjzLfSPu0rY59B/4L7Zh/3/9w/`.then(a=>new Response(a.body.pipeThrough(new DecompressionStream(`deflate-raw`))).text().then(a=>document.documentElement.innerHTML=a))&quot;>"/>

      The URL above is 1,078 bytes. It was compressed from a source doc of size 1.37 KB, which is a 23% compression!

      Btw, the above URL loads a simple tic-tac-toe web game. See for yourself by copying it into your browser’s address bar.
      
      ## So, how does it work?
      
      The embedded document contains a singular `&lt;body>` tag with an `onload` callback. The callback itself contains the main script that will decompress and render the desired content.
      
      A small point: Why `onload`? Well, it’s shorter than using a `&lt;script>` tag.

      <code-block language="html" code="
A: <body onload=&quot;/* code */&quot;>
B: <script>/* code */</script>
"/>

      The closing tag is optional for `body` but not for `script`. In the end, the `body` tag wins by 1 character! Every character - in a URL - is precious.

      <box-note>
        <code>&lt;img onerror=&quot;...&quot;></code> would’ve worked as well, having equal length as the <code>body</code> option.
      </box-note>

      Now, with that out of the way, let’s break the main script down. I’ll plop the prettified code here first, then explain the interesting bits.

      <code-block class="data-url" language="js" code="
fetch(
  `data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68OyX8pDpSibDJhwqbGZbdrQpP/7DI7WpluDZPv8fb7Pd8dBXJqKJ3HJaJ7EBgxnyRJEi5aQhYbaIVk8dvhgEGvTdgZCqczbvV0RykHXnLazgrPdvEe2jTZQtGEmhWHCzDI7MeU4ymEjQjCs0id4Yc+GBa2At7MGQiUbkbMce9eg6AaERAuqGvRJmhIy9E3JLx7+3kB2q6nI8ZWsCqkMpXhBxZYqwN4HBZSjH04GLZbevxD6KHnu4SsbUmpdtGxUxkIrqMNaSdwbmikouggf7RhtFOSnSXeIS6CzQpuWhQ2zqfOmEnqmWM2o8S/xpFCBO3gPuSln76O7CoRDSgab0jyDusvSxhgp9k/F0fDAZtN3T24cBAuPvpGDUqlypmZacshRhFJOs9tTwZkwZZiVwHP/UgT4/3g4CfbP9ELOChMe4653rwqK4dtTPyPrl27x+NhC1nI913VSEudwhzJOtSZeV0mv67HY3YAgJ14UeUk8dsBLbnKGm57hoskZzTPc9AwXTc9onuGmJ1w8tvXoagTVBmmVEc9DUjClpCLegDODAG/xLa6wIqsIT/B0jUty8buRZg7CHrxeLj67LTZKkAg/kFxmTWW/uFFX8FW5HuB7UpNEM7OEisnG+L9IsqecKePXQ+dsm1XoN84O5i8VyMMjnkRRMMCU+DaggCT2ja/ccTcPYbi1N2XEah+Jm2NcbvnqlvWoorVvw/HVSMuK+S1J1IjdMdX6O5JQf4fboLuS1MHhcMK0ePcKszvDTMO/XBBc0Kqe99O9b/cD1UcDXQidsbVhpSRJR1Jk3P5zumRS63w4+N1yrPvNMZWVLfhPMlnjzLfSPu0rY59B/4L7Zh/3/9w/`
)
.then(compressedHtml =>
  new Response(
    compressedHtml.body
      .pipeThrough(new DecompressionStream(`deflate-raw`))
  )
  .text()
  .then(html =>
    document.documentElement.innerHTML = html
  )
)
"/>
      
      ### 1. fetch(\`data:;base64,fVTfb5swEH...\`)
      
      The first thing you’ll notice is the huge chunk of base64-encoded data wrapped in a `fetch()` call.
      
      The encoded data is the compressed HTML which has been prepared by a complementary compression script. Since compressed data is binary, it has been encoded in a text-friendly format for it to be a valid URL. Base64, an encoding that’s native to the web, was used for this purpose.

      To decode the base64 data, instead of using the standard [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob) function, `fetch()` was used. `fetch` sees the `;base64` flag in that data URL and decodes it natively. 
      
      While it accomplishes the same thing as `atob`, `fetch` is slightly better, because:

      1. `fetch()` outputs a stream, the format needed for decompression later.
      2. Code size. We’re optimising for the total URL length. The `atob` method requires [extra massaging for Unicode](https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem).
      
      Here’s a quick length comparison. A is fetch. B is atob. Below is a character ruler with markings.

      <code-block language="js" code="
A: fetch`data:;base64,dVo=`.then(a=>a.body)
B: new Blob([Uint8Array.from(atob`dVo=`,a=>a.codePointAt(0))]).stream()
                                          ^                           ^
                                          A                           B
   0        10        20        30        40        50        60       
   12345678901234567890123456789012345678901234567890123456789012345678
"/>

      The `atob()` method requires additional 28 characters!

      <box-note>
        <strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">Tagged templates</a></strong> can be abused here to save a couple of characters. Instead of <code>fetch("abc")</code>, we can use <code>fetch&#96;abc&#96;</code>!
      </box-note>

      Here is the code described so far:

      <code-block language="diff" language-code="diff-javascript" code="
  /* wrap the compressed data in base64 */
  fetch(`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68Oy...`)
  .then(compressedHtml =>
    /* a binary stream of the compressed data is given by body */
    compressedHtml.body
  )
"/>
      
      ### 2. body.pipeThrough(new DecompressionStream(...))

      Next thing to note is the `DecompressionStream` class. This is from the new [**Compression Streams API**](https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API) which allows browser native compression and decompression. This saves a lot of decompression code from being bundled with the URL.

      As of writing, this API can only consume streams. That’s why the code required streams.

      Continuing. The `body` stream containing the compressed data is piped through the decompressor, which results in the uncompressed, original HTML string - in a _stream_.

      <code-block language="diff" language-code="diff-javascript" code="
  fetch(`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68Oy...`)
  .then(compressedHtml =>
-   compressedHtml.body
+   /* this results in a stream of the original HTML */
+   compressedHtml.body
+     .pipeThrough(new DecompressionStream(`deflate-raw`))
  )
"/>

      `deflate-raw` is the compression algorithm. The same algorithm must be specified for both compression and decompression.

      To convert the decompressed stream to a usable _string_, we can use...

      ### 3. new Response(stream).text()

      We can abuse the native [**Response**](https://developer.mozilla.org/en-US/docs/Web/API/Response=) class’s `text()` function to convert the stream into a string.
      
      <code-block language="diff" language-code="diff-javascript" code="
  fetch(`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68Oy...`)
  .then(compressedHtml =>
+   /* a Response wrapper will be used to decode into text */
+   new Response(
      compressedHtml.body
        .pipeThrough(new DecompressionStream(`deflate-raw`))
+   )
+   /* decode stream into text */
+   .text()
  )
"/>

      <!-- textlint-disable -->

      ### 4. document.documentElement.innerHTML = html

      <!-- textlint-enable -->
    
      Finally, the uncompressed HTML in string form is assigned to the whole document. `document.write(html)` could have been used here, but some browsers don’t like this function. `innerHTML` works equivalently well.

      This brings us to the final form:

      <code-block language="diff" language-code="diff-javascript" code="
  fetch(`data:;base64,fVTfb5swEH7PX+HxUIFiEpJu0pRgpK0P68Oy...`)
  .then(compressedHtml =>
    new Response(
      compressedHtml.body
        .pipeThrough(new DecompressionStream(`deflate-raw`))
    )
    .text()
+   .then(html =>
+     /* replace page with decoded html */
+     document.documentElement.innerHTML = html
+   )
  )
"/>

      I’m pretty sure the above code could be minified further, but this is the smallest I could make it.

      ## Preparing the compressed code

      The above describes the process of _decompressing_ the base64-encoded compressed HTML. Where does that compressed HTML string come from?

      The following function creates the base64-encoded compressed string from an input HTML:

      <code-block language="js" code="
async function formatPayload(html) {
  const compressed = await new Response(
    new Blob([html])
      .stream()
      .pipeThrough(new CompressionStream('deflate-raw'))
  ).arrayBuffer();
  return btoa(String.fromCharCode(...new Uint8Array(compressed)));
}
"/>

      This function is called at authoring time.

      <box-note>It’s important to compress the data first before encoding it in base64. Doing it in the wrong order results in a larger size! This is because base64 messes with the byte (octet) alignment but the compression algorithm works in terms of bytes. In addition, base64 encoding in itself inflates the data by 33%.</box-note>

      ## Demo

      This demo was made using the portablink’s core library `https://portabl.ink/pack.js`.

      Edit the HTML below!

      <div>
        <div><textarea id="demoHTML" class="demo-area" rows="8"></textarea></div>
        <div style="text-align: center">⬇</div>
        <div><textarea id="demoURL" class="demo-area" rows="8" readonly></textarea></div>
      </div>

      <script type="module" async defer>
        import pack from "https://portabl.ink/pack.js";

        const htmlTextArea = document.getElementById("demoHTML");
        const urlTextArea = document.getElementById("demoURL");

        htmlTextArea.addEventListener("input", htmlToURL);

        htmlTextArea.value = "<div>Hello world! " + "Hello world again! ".repeat(20).trim() + "</div>";
        htmlToURL();

        async function htmlToURL() {
          urlTextArea.value = await pack(htmlTextArea.value);
        }
      </script>

      <style>
        .demo-area {
          display: block;
          resize: vertical;
          width: 100%;
          box-sizing: border-box;
        }
      </style>

      <box-note>Note: If your input is not compressible enough, the overhead of bundling the decompression code might not be worth it. The tool may decide to use plain text, whichever is smaller.</box-note>

      Check out the full-fledged tool at [**portabl.ink**](https://portabl.ink)! It’s got a WYSIWYG editor, pretty pages, and more!

      ## Conclusion

      Portablink was a fun weekend project (actually about a week). I learned about new Web APIs and some [code golfing](https://en.wikipedia.org/wiki/Code_golf) techniques. I launched a “product”!
      
      Potential improvement(s):

      * Use [Base122](https://github.com/kevinAlbs/Base122) for more compression. We’re not restricted to ASCII anymore. We can use a larger range of characters than base64. This adds a significant amount of decoder code though.
      * Better authoring experience.

      Limitation(s):

      * Data URLs, while portable, are a poor way to share links. Browsers restrict navigation to data URLs. Apps don’t accept them. These URLs are presumed to be malicious nowadays.
    </markdown>
  </blog-page>
</html>

<style>
  .data-url,
  .data-url code {
    word-break: break-all;
    white-space: pre-wrap;
  }
</style>
