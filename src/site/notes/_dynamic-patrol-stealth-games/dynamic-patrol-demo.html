<dynamic-patrol-demo-client {...attrs} />

<style>
  dynamic-patrol-demo-client {
    position: relative;
    left: 50%;
    transform: translateX(-50%);
    display: inline-block;
    height: 80vmin;
    width: 80vmin;
    border-radius: 12px;
    background: #cdd;
    overflow: hidden;
  }
</style>

<script type="module" client defer>
  import * as PIXI from "/lib/vendor/pixijs.min.mjs";
  import { waitFor } from "/lib/wait_for.mjs";
  import { BaseElement } from "/lib/base_element.mjs";
  // Warn: Module path is relative to the page, not the component
  import {
    DynamicPatrolDemo,
    TILE_FLOOR,
    TILE_WALL,
  } from "./dynamic-patrol-demo.mjs";

  const spriteKey = Symbol("sprite");

  PIXI.BaseTexture.defaultOptions.scaleMode = PIXI.SCALE_MODES.NEAREST;
  const floorTexture = PIXI.Texture.from("floor.png");
  const wallTexture = PIXI.Texture.from("wall.png");
  const guardTexture = PIXI.Texture.from("guard.png");
  const targetTexture = PIXI.Texture.from("target.png");

  customElements.define(
    "dynamic-patrol-demo-client",
    class DynamicPatrolDemoClient extends BaseElement {
      constructor() {
        super();
        this.inputMap = null;

        this.pixi = null;
        this.tileSize = 1;

        this.model = null;
        this.modelTickId = null;

        this.hasInit = false;
        this.isVisible = false;
      }

      connectedCallback() {
        super.connectedCallback();

        this.visibilityListener({
          show: () => {
            this.isVisible = true;
            if (!this.hasInit) this.init();
            this.pixi.start();
            this.modelTickId = setInterval(this.update, 100);
          },
          hide: () => {
            clearInterval(this.modelTickId);
            this.pixi.stop();
            this.isVisible = false;
          },
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();

        if (this.pixi) this.pixi.destroy();
        this.replaceChildren();

        this.pixi = null;
        this.model = null;
        this.hasInit = false;
      }

      init() {
        if (!this.inputMap) {
          this.inputMap = this.getAttribute("map")
            .trim()
            .split("\n")
            .map((line) => line.trim().split(""));
        }

        this.model = new DynamicPatrolDemo(
          this.inputMap[0].length,
          this.inputMap.length
        );

        this.pixi = new PIXI.Application({
          resizeTo: this,
          background: "#cdd",
        });
        this.appendChild(this.pixi.view);
        this.pixi.view.addEventListener("mousemove", this.onHover);

        // Compute optimal tileSize
        const tileSizeMultiples = 2;
        this.tileSize =
          Math.floor(
            (Math.min(this.pixi.screen.width, this.pixi.screen.height) - 24) /
              Math.max(this.model.mapWidth, this.model.mapHeight) /
              tileSizeMultiples
          ) * tileSizeMultiples;

        // Center map in screen
        this.pixi.stage.x = Math.floor(
          this.pixi.screen.width / 2 - (this.model.mapWidth / 2) * this.tileSize
        );
        this.pixi.stage.y = Math.floor(
          this.pixi.screen.height / 2 -
            (this.model.mapHeight / 2) * this.tileSize
        );

        // Layers
        const tileContainer = new PIXI.Container();
        const entityContainer = new PIXI.Container();
        this.pixi.stage.addChild(tileContainer);
        this.pixi.stage.addChild(entityContainer);

        // Process input map
        for (let x = 0; x < this.model.mapWidth; x++) {
          for (let y = 0; y < this.model.mapHeight; y++) {
            const inputTile = this.inputMap[y][x];
            const tileType = inputTile === TILE_WALL ? TILE_WALL : TILE_FLOOR;

            if (inputTile === "G") {
              const guard = this.createGuard(x, y);
              entityContainer.addChild(guard[spriteKey]);
            } else if (inputTile === "T") {
              const target = this.createTarget(x, y);
              entityContainer.addChild(target[spriteKey]);
            }

            const tileSprite = new PIXI.Sprite(
              tileType === TILE_FLOOR ? floorTexture : wallTexture
            );
            tileSprite.x = x * this.tileSize;
            tileSprite.y = y * this.tileSize;
            tileSprite.width = this.tileSize;
            tileSprite.height = this.tileSize;
            tileContainer.addChild(tileSprite);
          }
        }
      }

      createGuard(x, y) {
        const guard = this.model.addGuard(x, y);
        const sprite = (guard[spriteKey] = new PIXI.Sprite(guardTexture));
        sprite.width = this.tileSize;
        sprite.height = this.tileSize;
        this.renderGuard(guard);
        return guard;
      }

      createTarget(x, y) {
        const target = this.model.addTarget(x, y);
        const sprite = (target[spriteKey] = new PIXI.Sprite(targetTexture));
        sprite.width = this.tileSize;
        sprite.height = this.tileSize;
        this.renderTarget(target);
        return target;
      }

      onHover = (event) => {
        console.log(event);
        const { clientX, clientY } = event;
      };

      render = () => {
        for (const guard of this.model.guards) {
          this.renderGuard(guard);
        }
      };

      renderGuard(guard) {
        const sprite = guard[spriteKey];
        sprite.x = guard.x * this.tileSize;
        sprite.y = guard.y * this.tileSize;
      }

      renderTarget(target) {
        const sprite = target[spriteKey];
        sprite.x = target.x * this.tileSize;
        sprite.y = target.y * this.tileSize;
      }

      update = () => {
        this.model.update();
      };
    }
  );
</script>
