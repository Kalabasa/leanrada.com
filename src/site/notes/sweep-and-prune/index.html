<html lang="en">
  <page-title title="Sort, sweep, and prune: collision detection algorithms" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sort, sweep, and prune: collision detection algorithms"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="5 Aug 2023" read-mins="13" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      This post is about a neat family of algorithms for detecting collisions among multiple objects. I attempted to explain and demonstrate first principles, so it‚Äôs quite long and is split into two parts. I hope you take the time to read and learn from it! üòÑ

      ---

      ## Collision detection
      
      As you may know, the problem of collision detection is pretty common in video game programming. It‚Äôs a prerequisite to the implementation of certain game mechanics or simulations.

      <blog-media
        alt="video of mario with goombas bumping into each other"
        :src="url('mario.gif')"
        caption="Goombas colliding" />

      Some of these mechanics include: preventing characters from passing through each other, [goombas](https://youtu.be/Ky69PjyHCqg) turning around when bumping into another, big cells eating smaller cells in [agar.io](https://agar.io/), or just about any game physics. All of these need collision detection.

      <blog-media
        alt="video of agar.io with cells eating smaller cells"
        :src="url('agario.gif')"
        caption="Cells consuming smaller cells on contact" />

      Here I‚Äôll cover several related approaches, starting with the simplest and building up to the [**sweep-and-prune**](https://en.wikipedia.org/wiki/Sweep_and_prune) algorithm.

      Balls.
      
      I‚Äôll use this **rigid-body ball simulation** as a recurring example to demonstrate the algorithms throughout the post:

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      Alright, let‚Äôs dive in! How do we detect these collisions?

      ##  Naive approach üê•

      The straightforward solution is to test every potential pair of objects for collision. That is, *check every ball against every other ball*.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Note in the above code that the inner loop starts at `i + 1` to prevent duplicate pairs from being counted (A-B vs B-A). Other than that, it‚Äôs a pretty simple solution.

      These checks are done on every time step, ensuring that balls will bounce exactly when they collide.

      Here‚Äôs a slowed-down, highlighted simulation, showing pairs being tested for intersection per time step:

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when being tested via <code>intersects()</code>.
        </div>
      </div>

      And it works. But if we had more than just a handful of balls we would start seeing performance issues.

      ## Performance, or lack thereof

      This naive algorithm runs in ***O(n<sup>2</sup>)*** time in [Big O terms](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of *n* balls, the algorithm‚Äôs running time grows proportionally to the *square* of the input *n*. That‚Äôs a lot! üìà

      This is because for *n* balls, there are around _(n&nbsp;*&nbsp;(n-1))/2_ pairs to test, or _0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n_. For example, if n = 5 there would be a total of 10 pairs. For n = 10, there would be 45 pairs. For n = 15, 105 pairs (!). And so on&hellip; Using Big O notation, we can simplify this information into a compact expression _‚ÄúO(n<sup>2</sup>)‚Äù_

      To (painfully) demonstrate how the performance scales badly for bigger inputs, here‚Äôs a simulation with n&nbsp;=&nbsp;20:

      <div class="demo-row">
        <sap-demo
          balls="20"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          20 balls = 190 pairs to test
        </div>
      </div>

      That‚Äôs a lot of checks per frame! Clearly, the naive solution does not scale well for large numbers of objects.

      How can we improve this solution?
 
      <box-note>
        <p>The worst case running time for <em>any</em> collision detection algorithm is always <em>O(n<sup>2</sup>)</em>. That‚Äôs when all objects intersect simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions.</p>
        <p>Thus, it‚Äôs more practical to compare the average and best cases.</p>
        <p>Having said that, the naive algorithm is still <em>Œò(n<sup>2</sup>)</em> for <em>any</em> case, no matter the number of actual collisions. A lot of room for improvement!</p>
      </box-note>

      ## Prologue: Improving the solution

      Usually when optimising algorithms, you wanna find **redundant or unnecessary work**. Then find a way to consolidate that redundancy. (That sounded corporate-ish.)

      A good place to start would be the `intersects()` function since it is called for every candidate pair. If we take the [typical object intersection test](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html) to be its implementation, we get a bunch of these **inequality checks**:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
      && object1.right > object2.left
      && object1.top < object2.bottom
      && object1.bottom > object2.top;
}`" />

      In the above code, the `intersects()` function checks if two objects intersect by comparing opposing bounds from the two objects, for each dimension. (Refer to [this MDN article](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb) for a better explanation.)

      For now, let‚Äôs focus on just one dimension, say *x*. Bear with me as I further scope it down to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don‚Äôt worry; this scoped-down definition is a surprise tool that can help us later. ;)

      <blog-media
        alt="Still of a cartoon mouse saying, 'that‚Äôs a surprise tool that can help us later'"
        :src="url('surprise-tool.jpg')"
        spec="200" />

      OK, the reason this will work is because of the `&&` operator‚Äôs [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation). That is, *if any operand is false, then the whole expression becomes false*. So if two objects do not overlap in the x-axis, then we can immediately rule them out as a candidate pair.

      <box-note>It‚Äôs the same idea as the [separating axis theorem](https://personal.math.vt.edu/mrlugo/sat.html), which implies that two objects can‚Äôt collide if there is an axis where their shadows don‚Äôt overlap.</box-note>

      Therefore, an optimisation in just the x dimension can still be a big help.

      Now, let‚Äôs look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in this configuration:

      <blog-media
        alt="Three objects, from left to right: A, B, and C"
        :src="url('abc.png')" />

      There are three potential pairs to be checked here: A-B, B-C, and A-C. Pretend we‚Äôre running them through the redefined `intersects()` function, like so:

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Remember, we‚Äôre trying to find redundant work. Looking closer, if we inline the `intersects()` function (scoped to one x direction) we get:

      <code-block :code="`\
A.right > B.left // returns false
B.right > C.left // returns false
A.right > C.left // returns false`" />

      See any redundant work? Maybe abstractify it a little&hellip;

      <code-block :code="`\
A > B // returns false
B > C // returns false
A > C // returns false`" />

      Voil√†. Due to the [__transitive property of inequality__](https://www.mathwords.com/t/transitive_property_inequalities.htm), realise that we don‚Äôt need to run the third test! *If we know A&nbsp;>&nbsp;B and B&nbsp;>&nbsp;C are false, then we don‚Äôt need to compute A&nbsp;>&nbsp;C.*

      So in this example, we don‚Äôt really need to run `intersects(A, C)`. We‚Äôve skipped one check!

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// I know intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to general n-body collision detection. A smart reader such as you might also have realised that this skip only works if A, B, and C are in a particular order. Try <span class="drag-hint">dragging</span> the balls below to see when the optimisation applies and when it does not:

      <div class="demo-row">
        <sap-demo
          id="abc-demo"
          balls="[[200,250,50],[300,150,55],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token comment">// LIVE OUTPUT:</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C) will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
      </div>

      <script client defer>
        (()=> {
          const abcDemo = document.querySelector("#abc-demo");
          const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
          const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
          const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
          const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
          const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");
          
          abcDemo.addEventListener("simulate", throttle((event) => {
            const [A, B, C] = event.balls;
            setText(intersectsAbReturn, String(A.x > B.x));
            setText(intersectsBcReturn, String(B.x > C.x));
            setText(intersectsAcReturn, String(A.x > C.x));
            const acRuns = (A.x > B.x) !== (B.x > C.x);
            setShow(intersectsAcRun, acRuns);
            setShow(intersectsAcSkip, !acRuns);
          }));

          function setText(elements, text) {
            for (const element of elements)
              if (element.textContent !== text)
                element.textContent = text;
          }

          function setShow(elements, show) {
            for (const element of elements)
              if ((element.offsetParent != null) !== show)
                element.style.display = show ? "block" : "none";
          }

          function throttle(func, ms = 100) {
            let lastTime = Date.now();
            return (...args) => {
              if (Date.now() - lastTime < ms) return;
              lastTime = Date.now();
              func(...args);
            };
          }
        })();
      </script>

      <box-note>**Tip:** Drag the balls so that they‚Äôre in one of these orders: C&#8209;B&#8209;A and A&#8209;B&#8209;C</box-note>

      While it‚Äôs true that this skip only works when A, B, and C are ordered, remember that these labels are *arbitrary*! What if we just decided to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable! üååüß†
      
      But wait&hellip; labeling objects according to a defined order is essentially ‚ú®**sorting**‚ú®! What if we sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?

      ## Chapter 1. Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand.  *A sorted list allows us to exploit the transitive property of inequality en masse.*

      Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in _O(n log n)_ time which is certainly lower than _O(n<sup>2</sup>)_.

      As hinted by the tri-object example above, sorting the list of objects merely by their x position removes ranges of potential pairs that need to be tested.
      
      However, objects aren‚Äôt zero-width points. They‚Äôre *widthy*, by which I mean having a size and occupying an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one definitively sort by x position if objects span intervals in the x-axis?

      ## Sort by min x

      A solution to sorting widthy objects is to sort them by their **minimum x** (their left edge‚Äôs x-coordinate). This technique can be applied to improve the naive approach.
      
      It involves minimal modifications to the O(n<sup>2</sup>) solution. But it will result in a good chunk of checks skipped. I‚Äôll explain later.

      First, the modified code:

      <code-block language="diff" language-code="diff-javascript" :code="`\
+ // sort by min x
+ sortByLeft(balls);
+ 
  // for each ball
  for (let i = 0; i < balls.length; i++) {
    const ball1 = balls[i];
    // check each of the other balls
    for (let j = i + 1; j < balls.length; j++) {
      const ball2 = balls[j];
+ 
+     // stop when too far away
+     if (ball2.left > ball1.right) break;
+ 
      // check for collision
      if (intersects(ball1, ball2)) {
        bounce(ball1, ball2);
      }
    }
  }`" />

      It‚Äôs mostly the same as the naive solution, differing only in two extra lines of code. (These two juicy lines of code yield a maximum return of investment and is unlikely to be topped by anything else in this post.)

      The first line, `sortByLeft(edges)`, simply sorts the list. The ranking is based on the balls‚Äô left edge x-coords:

<code-block :code="`\
sortByLeft = (balls) => balls.sort((a,b) => a.left - b.left)`" />
      
      And in the inner loop, there is now this break:

<code-block :code="`\
if (ball2.left > ball1.right) break;`" />

      Let‚Äôs break that down.
      
      First, we know that the list is sorted, so the condition
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left</code>
      holds true for any positive integer
      <code class="eq-c">c</code>.
      
      Therefore, when
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      is true, then
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      will also be true.

      Because
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>.

      When that condition is true, the current ball2
      <code>balls[<span class="eq-i">j</span>]</code>,
      and any further ball2s
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>]</code>,
      do *not* intersect ball1. So we can skip the rest of ball2s in the inner loop and move on to the next ball1.

      <style>
        .eq-op {
          color: var(--clr0-light);
        }
        .eq-i {
          color: #e79907;
        }
        .eq-c {
          color: var(--clr1); 
        }
      </style>

      Here‚Äôs a demo:

      <div class="demo-row">
        <sap-demo
          strategy="simple-sap"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when tested by <code>intersects()</code>.
        </div>
      </div>

      **Observations:** Since the list is sorted, the checks are performed from left to right. More importantly, it visibly does fewer checks than the naive approach. üìâ
      
      This is due the above optimisation which limits pairs to only those that overlap in the x-axis!

      Let‚Äôs analyse the time complexity. üëì
      
      The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would add an _O(n log n)_ term.

      The two-level loop, now with an early break, would average out to _O(n&nbsp;+&nbsp;m)_ where _m_ is the total number of x-overlaps. This could degenerate into n<sup>2</sup> but as mentioned it‚Äôs more useful to look at the average and best cases. At best, the loops would be _O(n)_, wasting no excess processing if there are no collisions at all. On average it‚Äôs _O(n&nbsp;+&nbsp;m)_.

      <box-note>The average case refers to a world where objects are mostly evenly distributed and only a couple intersections per object is happening. I think this is a reasonable assumption for a relatively simple video game like a platformer or side-scroller.</box-note>

      Here‚Äôs the code with running time annotations:

      <code-block :code="`\
// O(n log n)
sortByLeft(balls);

// O(n + m)
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];
    if (ball2.left > ball1.right) break;
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Adding those together, _n&nbsp;log&nbsp;n&nbsp;+&nbsp;n&nbsp;+&nbsp;m_ we get ___O(n log n + m)___. A big improvement over the naive approach‚Äôs _O(n<sup>2</sup>)_.

      Furthermore, the choice of sorting algorithm could be improved. Yes, there‚Äôs something better than an _n&nbsp;log&nbsp;n_ sort in this case; we‚Äôll look into that in the next part!

      <box-note>
        If you got this far trying to find a decent collision detection algorithm, then you can stop reading and take the above design! It‚Äôs the perfect balance between programming effort and running time performance. If you are curious how this develops or just want to see more interactive demos, read the next part.
      </box-note>

      ## Visual comparison

      Here‚Äôs a side-by-side comparison of the strategies we‚Äôve covered so far! Observe the amount of intersection checks required per frame. üîç

      <div class="demo-row">
        <sap-demo
          balls="10"
          strategy="pairwise"
          skip-interval="1"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Global pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="10"
          strategy="sap-nativesort"
          skip-interval="1"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">Sorted pairwise</div>
      </div>

      (Not shown: the cost of sorting. Let‚Äôs assume the intersection test is sufficiently expensive.)

      Aaand that concludes the first part. Those two lines of code definitely made big impact. Could there be anything better than that?

      [Continued in part 2.](/notes/sweep-and-prune-2/)

      ---

      Bonus demo, 15 balls! What a mess!
      <div class="demo-row">
        <sap-demo balls="15" labels="üçé,üöó,üå∏,üçï,üéà,üåä,üéÆ,üöÄ,üìö,üéµ,üèÜ,üåª,üçî,‚è∞,‚≠ê" rainbow strategy="sap-swap-2d" />
      </div>

      [Continued in part 2.](/notes/sweep-and-prune-2/)
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .demo-caption {
    max-width: 600px;
  }

  .drag-hint {
    padding: 0 0.3rem;
    font-weight: bold;
    border: dashed 2px #fff7;
    border-radius: 2rem;
  }

  .abc-demo-intersects-ac-run,
  .abc-demo-intersects-ac-skip {
    animation: highlight-change 2s 0.5s both;
  }

  @keyframes highlight-change {
    from {
      background: #55440088;
    }
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }
</style>
