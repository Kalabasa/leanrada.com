<html lang="en">
  <page-title title="Sort, sweep, and prune: collision detection algorithms" />
  <blog-page header-select="/notes/">
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="Sort, sweep, and prune: collision detection algorithms"
        :heroimgsrc="url('hero.jpg')" />

      <blog-post-info date="5 Aug 2023" read-mins="27" />

      <tag-row>
        <tag>algo</tag>
        <tag>games</tag>
      </tag-row>

      This post is about a neat family of algorithms for detecting collisions among multiple objects. It‚Äôs quite a long post intended to explain and demonstrate first principles. I hope you take the time to read and learn from it! üòÑ
      
      As you may know, the problem of collision detection is pretty common in video game programming. It‚Äôs a prerequisite to the implementation of certain game mechanics or simulations.

      <blog-media
        alt="video of mario with goombas bumping into each other"
        :src="url('mario.gif')"
        caption="Goombas colliding" />

      Some of these mechanics include: preventing characters from passing through each other, [goombas](https://youtu.be/Ky69PjyHCqg) turning around when bumping into another, big cells eating smaller cells in [agar.io](https://agar.io/), or just about any game physics. All of these need collision detection.

      <blog-media
        alt="video of agar.io with cells eating smaller cells"
        :src="url('agario.gif')"
        caption="Cells consuming smaller cells on contact" />

      Here I‚Äôll cover several related approaches, starting with the simplest and building up to the [**sweep-and-prune**](https://en.wikipedia.org/wiki/Sweep_and_prune) algorithm.

      Balls.
      
      I‚Äôll use this **rigid-body ball simulation** as a recurring example to demonstrate the algorithms throughout the post:

      <div class="demo-row">
        <sap-demo strategy="sap-nativesort" />
      </div>

      Alright, let‚Äôs dive in! How do we detect these collisions?

      ##  Naive approach üê•

      The straightforward solution is to test every potential pair of objects for collision. That is, *check every ball against every other ball*.

      <code-block :code="`\
// for each ball
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  // check each of the other balls
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];
    // check for collision
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Note in the above code that the inner loop starts at `i + 1`. This is to prevent duplicate pairs from being counted (A-B vs B-A). Other than that, it‚Äôs a pretty simple solution.

      These checks are done on every time step, ensuring that balls will bounce exactly when they collide.

      Here‚Äôs a slowed-down, highlighted simulation. This shows pairs being tested for intersection per time step:

      <div class="demo-row">
        <sap-demo
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs are highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when being tested via <code>intersects()</code>.
        </div>
      </div>

      And it works. But if we had more than just a handful of balls we would start seeing performance issues.

      ## Performance, or lack thereof

      This naive algorithm runs in ***O(n<sup>2</sup>)*** time in [Big O terms](https://en.wikipedia.org/wiki/Big_O_notation). That is, for an input of *n* balls, the algorithm‚Äôs running time grows proportionally to the *square* of the input *n*. That‚Äôs a lot! üìà

      This is because for *n* balls, there are around _(n&nbsp;*&nbsp;(n-1))/2_ pairs to test, or _0.5n<sup>2</sup>&nbsp;-&nbsp;0.5n_. For example, if n = 5 there would be a total of 10 pairs. For n = 10, there would be 45 pairs. For n = 15, 105 pairs (!). And so on&hellip; Using Big O notation, we can simplify this information into about the algorithm‚Äôs scalability into one expression _‚ÄúO(n<sup>2</sup>)‚Äù_

      To (painfully) demonstrate how the performance scales badly for bigger inputs, here‚Äôs a simulation with n&nbsp;=&nbsp;20:

      <div class="demo-row">
        <sap-demo
          balls="20"
          strategy="pairwise"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          20 balls = 190 pairs to test
        </div>
      </div>

      That‚Äôs a lot of checks per frame! Clearly, the naive solution does not scale well for large numbers of objects.

      How can we improve the solution?
 
      <box-note>
        <p>The worst case running time for <em>any</em> collision detection algorithm is always <em>O(n<sup>2</sup>)</em>. That‚Äôs when all objects intersect simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions.</p>
        <p>Thus, it‚Äôs more practical to compare the average and best cases.</p>
        <p>Having said that, the naive algorithm is still <em>Œò(n<sup>2</sup>)</em> for <em>any</em> case, no matter the number of actual collisions. A lot of room for improvement!</p>
      </box-note>

      ## Prologue: Improving the solution

      Usually when optimising algorithms, you wanna find **redundant or unnecessary work**. Then find a way to consolidate that redundancy. (That sounded corporate-ish.)

      A good place to start would be the `intersects()` function since it is called for every candidate pair. If we take the [typical object intersection test](https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html) to be its implementation, we get a bunch of these **inequality checks**:

      <code-block :code="`\
function intersects(object1, object2) {
  // compare objects' bounds to see if they overlap
  return object1.left < object2.right
      && object1.right > object2.left
      && object1.top < object2.bottom
      && object1.bottom > object2.top;
}

// Define the structure just so we‚Äôre on the same page
type Object = {
  left: number;   // x-coordinate of left edge
  right: number;  // x-coordinate of right edge
  top: number;    // y-coordinate of top edge
  bottom: number; // y-coordinate of bottom edge
};`" />

      In the above code, the `intersects()` function checks if two objects intersect by comparing opposing bounds from the two objects, for each dimension. (Refer to [this MDN article](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb) for a better explanation.)

      For now, let‚Äôs focus on just one dimension, say *x*. Bear with me as I further scope it down to just one *direction*:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.right > object2.left;
}`" />

      Don‚Äôt worry; this scoped-down definition is a surprise tool that can help us later. ;)

      <blog-media
        alt="Still of a cartoon mouse saying, 'that‚Äôs a surprise tool that can help us later'"
        :src="url('surprise-tool.jpg')"
        spec="200" />

      OK, the reason this will work is because of the `&&` operator‚Äôs [short-circuit evaluation](https://en.wikipedia.org/wiki/Short-circuit_evaluation). That is, *if any operand is false, then the whole expression becomes false*. So if two objects do not overlap in the x-axis, then we can immediately rule them out as a candidate pair.

      <box-note>It‚Äôs the same idea as the [separating axis theorem](https://personal.math.vt.edu/mrlugo/sat.html), which implies that two objects can‚Äôt collide if there is an axis where their shadows don‚Äôt overlap.</box-note>

      Therefore, an optimisation in just the x dimension can still be a big help. And that‚Äôs what we‚Äôre gonna do.

      Now, let‚Äôs look at these checks in the context of multiple objects. Consider three objects - A, B, and C - in this configuration:

      <blog-media
        alt="Three objects, from left to right: A, B, and C"
        :src="url('abc.png')" />

      There are three potential pairs to be checked here: A-B, B-C, and A-C. Pretend we‚Äôre running them through the redefined `intersects()` function, like so:

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
intersects(A, C) // returns false`" />

      Remember, we‚Äôre trying to find redundant work. Looking closer, if we inline the `intersects()` function (scoped to one x direction) we get:

      <code-block :code="`\
A.right > B.left // returns false
B.right > C.left // returns false
A.right > C.left // returns false`" />

      See any redundant work? Maybe abstractify it a little&hellip;

      <code-block :code="`\
A > B // returns false
B > C // returns false
A > C // returns false`" />

      Voil√†. Due to the [__transitive property of inequality__](https://www.mathwords.com/t/transitive_property_inequalities.htm), we realise that we don‚Äôt need to run the third test! *If we know A&nbsp;>&nbsp;B and B&nbsp;>&nbsp;C are false, then we don‚Äôt need to compute A&nbsp;>&nbsp;C.*

      So in this example, we don‚Äôt really need to run `intersects(A, C)`. We‚Äôve skipped one check!

      <code-block :code="`\
intersects(A, B) // returns false
intersects(B, C) // returns false
// I know intersects(A, C) will return false`" />

      You might be wondering how this contrived example could apply to general n-body collision detection. A smart reader such as you might also have realised that this skip only works if A, B, and C are in a particular order. Try <span class="drag-hint">dragging</span> the balls below to see when the optimisation applies and when it does not:

      <div class="demo-row">
        <sap-demo
          id="abc-demo"
          balls="[[200,250,50],[300,150,55],[450,275,60]]"
          strategy="sap-nativesort"
          static draggable
          labels="A,B,C" rainbow />
        <pre class="code-block" style="width: 100%; max-width: 600px"><code class="code-block-code"><span class="token comment">// LIVE OUTPUT:</span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token comment">// A > B returns <span class="abc-demo-intersects-ab-return">false</span></span>
<span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// B > C returns <span class="abc-demo-intersects-bc-return">false</span></span>
<span class="abc-demo-intersects-ac-run" style="display: none"><span class="token function">intersects</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token comment">// A > C returns <span class="abc-demo-intersects-ac-return">false</span></span></span><span class="abc-demo-intersects-ac-skip token comment">//intersects(A, C), A > C will return <span class="abc-demo-intersects-ac-return">false</span></span></code></pre>
      </div>

      <script client defer>
        (()=> {
          const abcDemo = document.querySelector("#abc-demo");
          const intersectsAbReturn = document.querySelectorAll(".abc-demo-intersects-ab-return");
          const intersectsBcReturn = document.querySelectorAll(".abc-demo-intersects-bc-return");
          const intersectsAcReturn = document.querySelectorAll(".abc-demo-intersects-ac-return");
          const intersectsAcRun = document.querySelectorAll(".abc-demo-intersects-ac-run");
          const intersectsAcSkip = document.querySelectorAll(".abc-demo-intersects-ac-skip");
          
          abcDemo.addEventListener("simulate", throttle((event) => {
            const [A, B, C] = event.balls;
            setText(intersectsAbReturn, String(A.x > B.x));
            setText(intersectsBcReturn, String(B.x > C.x));
            setText(intersectsAcReturn, String(A.x > C.x));
            const acRuns = (A.x > B.x) !== (B.x > C.x);
            setShow(intersectsAcRun, acRuns);
            setShow(intersectsAcSkip, !acRuns);
          }));

          function setText(elements, text) {
            for (const element of elements)
              if (element.textContent !== text)
                element.textContent = text;
          }

          function setShow(elements, show) {
            for (const element of elements)
              if ((element.offsetParent != null) !== show)
                element.style.display = show ? "block" : "none";
          }
        })();
      </script>

      <box-note>**Tip:** Drag the balls so that they‚Äôre in one of these orders: C&#8209;B&#8209;A and A&#8209;B&#8209;C</box-note>

      While it‚Äôs true that this skip only works when A, B, and C are ordered, remember that these labels are *arbitrary*! What if we just decided to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable! üååüß†
      
      But wait&hellip; labeling objects according to a defined order is essentially ‚ú®**sorting**‚ú®! What if we sorted the list of objects every time? Would the number of skipped checks be worth the cost of sorting?

      ## Chapter 1. Sorting

      Sorting, inequalities, and optimisation go hand in hand in hand. Sorted lists give us implied inequalities over vast ranges for free*.

      *A sorted list allows us to exploit the transitive property of inequality en masse.*

      *Even if we had to sort the list of objects every frame, the quickest sorting algorithm in general runs in _O(n log n)_ time which is certainly lower than _O(n<sup>2</sup>)_. `n * log(n) < n * n`

      As hinted by the tri-object example above, sorting the list of objects merely by their x position removes ranges of potential pairs that need to be tested.
      
      However, objects aren‚Äôt zero-width points. They‚Äôre *widthy*, by which I mean having a size and occupying an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one definitively sort by x position if objects span intervals in the x-axis?

      ## Sort by min x

      A solution to sorting widthy objects is to sort them by their **minimum x** (their left edge‚Äôs x-coordinate). This technique can be applied to improve the naive approach.
      
      It requires minimal modifications to the O(n<sup>2</sup>) solution, but results in a good chunk of checks skipped. I‚Äôll explain later.

      First, the modified code:

      <code-block language="diff" language-code="diff-javascript" :code="`\
+ // sort by min x
+ sortByLeft(balls);
+ 
  // for each ball
  for (let i = 0; i < balls.length; i++) {
    const ball1 = balls[i];
    // check each of the other balls
    for (let j = i + 1; j < balls.length; j++) {
      const ball2 = balls[j];
+ 
+     // stop when too far away
+     if (ball2.left > ball1.right) break;
+ 
      // check for collision
      if (intersects(ball1, ball2)) {
        bounce(ball1, ball2);
      }
    }
  }`" />

      It‚Äôs mostly the same as the naive solution, differing only in two extra lines of code. (These two juicy lines of code yield a maximum return of investment and is unlikely to be topped by anything else in this post.)

      The first line, before anything else, simply sorts the list. The ranking is based on the balls‚Äô left edge‚Äôs x-coords:

<code-block :code="`\
sortByLeft = (balls) => balls.sort((a,b) => a.left - b.left)`" />
      
      And in the inner loop, there is now this break:

<code-block :code="`\
if (ball2.left > ball1.right) break;`" />

      Let‚Äôs break that down.
      
      First, we know that the list is sorted, so the condition
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&lt;</span> balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left</code>
      holds true for any positive integer
      <code class="eq-c">c</code>.
      
      Therefore, when
      <code>ball2.left <span class="eq-op">&gt;</span> ball1.right</code>
      or rather
      <code>balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      is true, then
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> ball1.right</code>
      will also be true.

      Because
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>].left <span class="eq-op">&gt;</span> balls[<span class="eq-i">j</span>].left <span class="eq-op">&gt;</span> ball1.right</code>.

      In that case, the current ball2
      <code>balls[<span class="eq-i">j</span>]</code>,
      and any further ball2s
      <code>balls[<span class="eq-i">j</span> + <span class="eq-c">c</span>]</code>,
      do *not* intersect ball1. So we can skip the rest of ball2s in this loop and move on to the next ball1.

      <style>
        .eq-op {
          color: var(--clr0-light);
        }
        .eq-i {
          color: #e79907;
        }
        .eq-c {
          color: var(--clr1); 
        }
      </style>

      Here‚Äôs a demo:

      <div class="demo-row">
        <sap-demo
          strategy="simple-sap"
          skip-interval="4"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Pairs highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span> when tested by <code>intersects()</code>.
        </div>
      </div>

      Since the list is sorted, the checks are performed from left to right. It also seems to have much less checks than the naive approach. üìâ
      
      This is because only pairs that overlap in the x-axis are tested as a result of the above optimisation!

      Let‚Äôs analyse the time complexity! üëì
      
      The sort - if we take the "fastest" sorting algorithm, like mergesort or quicksort - would add an _O(n log n)_ term.

      The loops, now with an early break, would average out to _O(n&nbsp;+&nbsp;m)_ where _m_ is the total number of x-overlaps. This could degenerate into n<sup>2</sup> but as mentioned it‚Äôs more useful to look at the average and best cases. At best, the loops would be _O(n)_, wasting no excess processing if there are no collisions at all. On average it‚Äôs _O(n&nbsp;+&nbsp;m)_.

      <box-note>The average case refers to a world where objects are mostly evenly distributed and only a couple intersections per object is happening. I think this is a reasonable assumption for a relatively simple video game like a platformer or side-scroller. (In any case, this post is open for more detailed analyses!)</box-note>

      Here‚Äôs the code with running time annotations:

      <code-block :code="`\
// O(n log n)
sortByLeft(balls);

// O(n + m)
for (let i = 0; i < balls.length; i++) {
  const ball1 = balls[i];
  for (let j = i + 1; j < balls.length; j++) {
    const ball2 = balls[j];
    if (ball2.left > ball1.right) break;
    if (intersects(ball1, ball2)) {
      bounce(ball1, ball2);
    }
  }
}`" />

      Adding those together, _n&nbsp;log&nbsp;n&nbsp;+&nbsp;n&nbsp;+&nbsp;m_ we get ___O(n log n + m)___. A big improvement over the naive approach‚Äôs _O(n<sup>2</sup>)_.

      Furthermore, the choice of sorting algorithm could be improved. Yes, there‚Äôs something better than an _n&nbsp;log&nbsp;n_ sort in this case; we‚Äôll look into that later in this post!

      <box-note>
        If you got this far trying to find a decent collision detection algorithm, then you can stop reading and take the above design! It is the perfect balance between programming effort and running time performance. If you want more data structures and algorithms or are curious how this develops or just want to see sophisticated things, read on.
      </box-note>

      ## Proper sweep-and-prune

      The above was a simplified version of a one-dimensional sweep-and-prune algorithm. I believe the simplified versions‚Äôs time complexity would be about the same as the original‚Äôs but with a much smaller constant factor. In any case, let‚Äôs see how the original tackled the problem.
      
      First, sorting widthy objects.

      To account for the width of objects while keeping the benefits of unambiguous sort order, we track the left and the right edges of each object as two separate points!

      This is done by maintaining a separate __array of edge points__ corresponding to the objects‚Äô left & right edges.

      See how it works by playing with this <span class="drag-hint">draggable</span> demo. The left and right edges of each ball are visualised. These edge points are stored in a sorted array shown below the box.

      <div class="demo-row">
        <sap-demo
          id="edges-demo"
          balls="6"
          strategy="sap-nativesort"
          static draggable rainbow
          decorations="edges" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo"></div>
      </div>

      The sorted array of edges is the minimal setup needed to optimise away unnecessary pairwise tests.
      
      Remember the `intersects()` function? Here it is with only the x-axis checks:

      <code-block :code="`\
function intersects(object1, object2) {
  return object1.left < object2.right
      && object1.right > object2.left;
}`" />

      We can replace these x-coordinate comparisons with a new approach, one based on array indices. Since we have a sorted array of every object‚Äôs left and right points, finding overlaps can be done via index-based searches rather than global pairwise testing.

      Take one ball for example. Get the indices of its left and right points, and simply run through all points in between those two points in the array to get all x-overlapping objects. This is a very fast linear operation.

      Try <span class="drag-hint">dragging</span> the <span style="color:#4c8">highlighted ball</span> below and observe the edges enclosed visually and in the sorted array:

      <div class="demo-row">
        <sap-demo
          id="edges-demo-one"
          balls="6"
          strategy="sap-nativesort" 
          static draggable
          decorations="edges:focus:#4c8:#d88" />
        Sorted array of edges:
        <div class="edges-array" data-target="#edges-demo-one"></div>
      </div>

      <box-note>One minor issue with the above 1-to-n approach is that an overlap can be missed if another ball is larger than the current ball. The larger ball can overlap the smaller ball without having any edge points inside of the smaller ball‚Äôs enclosure.</box-note>

      The above is a simple 1-to-n overlap detection. For n-to-n overlap detection, it turns out there is a way to find them across all objects in a single pass!

      ## Chapter 2. Sweeping

      To generalise the above to an n-interval overlap scan, imagine a vertical line sweeping across the whole space from left to right. The sweep will scan each edge point in-order, keeping track of the objects it touches.

      Let‚Äôs see what that looks like without collision:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="4"
          decorations="sweep:#f00:#d88,edges" />
        <div class="demo-caption">
          Objects touching the line are lit up in <span style="color:#d88">pink</span>.
        </div>
      </div>

      Whenever it runs into an object (a left edge), the object is added to a <span style="color:#d88">`touching`</span> set to indicate being in contact with it.

      Likewise, whenever it exits an object (right edge), that object is removed from the set.

      As for the implementation, the line is merely a metaphor. It‚Äôs just a visualisation of the process of iterating through the sorted list of edges. Here‚Äôs the code for the actual sweeping:

      <code-block :code="`\
sort(edges);

const touching = new Set();
for (const edge of edges) {
  if (edge.isLeft) {
    // entering an object
    touching.add(edge.object);
  } else {
    // exiting an object
    touching.delete(edge.object);
  }
}`" />

      The `touching` set is the set of objects currently touching the sweeping line.

      Once we have the sweep and the `touching` set working, detecting overlaps is easy. Whenever the sweep line enters a new object (a left edge), in addition to adding it to `touching`, we can mark it as overlapping with the rest of the objects `touching` the line.

      Watch closely whenever the line enters a ball while `touching` other balls. Detected overlaps are highlighted:

      <div class="demo-row">
        <sap-demo
          balls="8"
          no-bounce
          strategy="sap-nativesort"
          skip-interval="6"
          decorations="sweep:#f00:#d88,edges,checks:#4bf:600" />
        <div class="demo-caption">
          X-overlapping pairs are highlighted <span aria-label="a connecting green line" style="color:#4bf" class="pair-legend"></span> as the line sweeps.
        </div>
      </div>

      Here‚Äôs the updated code for detecting and reporting overlaps:
      
      <code-block language="diff" language-code="diff-javascript" :code="`\
  sort(edges);
  
  const touching = new Set();
  for (const edge of edges) {
    if (edge.isLeft) {
      // entering an object
+     
+     // the new object is overlapping with the existing ones
+     for (const other of touching) {
+       onOverlapX(other, edge.object);
+     }
+     
      touching.add(edge.object);
    } else {
      // exiting an object
      touching.delete(edge.object);
    }
  }`" />

      ## Chapter 3. Pruning

      The `onOverlapX()` that is called whenever two balls are overlapping in the x dimension. What about the other dimension, *y*? What if we‚Äôre working with 3D, how about *z*?

      Don‚Äôt worry; the sweep is just the broad-phase test, a way to _prune_ candidate pairs in bulk. There will be a narrow-phase test, a more exact intersection test for each of the remaining pairs.

      What `onOverlapX()` is for is to hook up an exact intersection test like the full `intersects()` function earlier. Or, since we already know that the argument pair overlaps in *x*, we can just check for *y*.

      <code-block :code="`\
onOverlapX = function(object1, object2) {
  if (object1.top < object2.bottom
   && object1.bottom > object2.top) {
    collide(object1, object2);
  }
}`" />

      While the above formula works for most games, a more precise and time-consuming check could be done at this level since most candidates have already been pruned. Our ball example would work better with the following circle intersection test using the [Euclidean distance formula](https://en.wikipedia.org/wiki/Euclidean_distance):

      <code-block :code="`\
onOverlapX = function(object1, object2) {
  const distance = sqrt(
      (object1.x - object2.x) ** 2
    + (object1.y - object2.y) ** 2
  );
  if (distance < object1.radius + object2.radius) {
    bounce(object1, object2);
  }
}`" />

      Finally, implement `bounce()` using physically-based physics, and we get a pretty fast ball simulation:

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="2"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          Ball sim using sweep-and-prune. <code>onOverlapX()</code> calls highlighted <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      <box-note>The sweep-and-prune algorithm is also known as sort-and-sweep.</box-note>

      ### Note for 3D

      There is a variant which performs the sweep for each axis, not just *x*. It maintains _separate_ sorted lists of edges, __one for each axis__. Indeed, this is how the full sweep-and-prune implementation works as described in the [original paper by D. Baraff](https://ecommons.cornell.edu/handle/1813/7115). Object pairs are flagged for overlaps separately per dimension. Pairs flagged in all dimensions would be considered intersecting.

      This is the advantage the full sweep-and-prune has over the simplified ‚Äúsorted pairwise‚Äù version. It can prune in multiple dimensions!

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-swap-2d"
          skip-interval="2"
          decorations="checks:#4c8" />
        <div class="demo-caption">
          2D sweep-and-prune. Only pairs with overlapping <text-link href="https://en.wikipedia.org/wiki/Bounding_volume#:~:text=axis%2Daligned%20bounding%20box">AABBs</text-link> are tested <span aria-label="a connecting green line" style="color:#4c8" class="pair-legend"></span>.
        </div>
      </div>

      ## Performance of sweep-and-prune

      Here‚Äôs side-by-side comparison of the strategies we‚Äôve covered so far! Observe the amount of intersection checks required per frame.

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="pairwise"
          skip-interval="1"
          decorations="checks:#cbb:30" />
        <div class="demo-caption">Global pairwise</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-nativesort"
          skip-interval="1"
          decorations="checks:#bcb:30" />
          <div class="demo-caption">1D sweep and prune</div>
      </div>

      <div class="demo-row">
        <sap-demo
          balls="6"
          strategy="sap-swap-2d"
          skip-interval="1"
          decorations="checks:#acb:30" />
          <div class="demo-caption">2D sweep and prune</div>
      </div>

      Let‚Äôs analyse the time complexity of 1D sweep-and-prune! üëì
      
      The sort step, again, is _O(n log n)_.
      
      The sweep, which is a linear pass with an inner loop for overlaps, should be _O(n&nbsp;+&nbsp;m)_ in the average case. Again, _m_ is the number of overlaps.
 
      <code-block :code="`\
function sweepAndPrune(edges) {
  // O(n log n)
  sort(edges);

  const touching = new Set();

  // O(n)
  for (const edge of edges) {
    if (edge.isLeft) {
      // zero at best; some constant on average; O(n) at worst
      for (const other of touching) {
        onOverlapX(other, edge.object);
      }
      touching.add(edge.object);
    } else {
      touching.delete(edge.object);
    }
  }
}`" />

      This means sweep-and-prune is _O(n log n + m)_ on average.

      That‚Äôs great, but it‚Äôs the same as simplified ‚Äúsorted pairwise‚Äù sweep-and-prune but with more code and state to keep tabs on. *Can we improve this?*

      ## Small detail, big improvement

      Again, let‚Äôs ask the question: Where is redundant work being done here?

      Let‚Äôs look at the sort step, which is the bottleneck of the algorithm according to the analysis.
      
      The following is a visualisation of the sorting of the edges array, using an optimised [quicksort](https://en.wikipedia.org/wiki/Quicksort) (n&nbsp;log&nbsp;n):

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-quicksort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted. The fixed lines at the top are edge array positions, connected to actual ball edge x positions below. Line crossings signal incorrect order.
        </div>
      </div>

      You can see that most of the time, the sort does nothing at all! The list is almost always **already sorted from the previous frame**.
      
      Even when the list becomes unsorted, it usually takes just a couple of swaps to become sorted again as only a few object boundaries would have changed places in one step.

      Fortunately, the subject of sorting algorithms is well-researched. We‚Äôre dealing with the special quality of being *nearly-sorted*. And one great choice for sorting nearly-sorted lists is [**insertion sort**](https://en.wikipedia.org/wiki/Insertion_sort)!

      <code-block :code="`\
function insertionSort(edges) {
  for (let i = 1; i < edges.length; i++) {
    for (let j = i - 1; j >= 0; j--) {
      if (edges[j].x < edges[j + 1].x) break;
      [edges[j], edges[j + 1]] = [edges[j + 1], edges[j]]
    }
  }
}`" />

      Insertion sort has a running time of _O(n)_ at best when the list is already sorted or nearly-sorted, and _O(n<sup>2</sup>)_ at worst when the list is in reverse. We can argue that the average case is **O(n)** and that we almost never reach the worst case, since the list is almost always sorted due to the previous frame‚Äôs sort.

      Here‚Äôs insertion sort in action:

      <div class="demo-row">
        <sap-demo
          balls="[[50,350,50],[100,300,30],[150,200,40],[450,350,35],[500,300,30],[550,300,40]]"
          no-bounce
          strategy="sap-insertionsort"
          skip-interval="3"
          decorations="edges:array:#f00:#0cf"/>
        <div class="demo-caption">
          Sort <span style="color:#0cf">comparisons</span> and <span style="color:#f00">swaps</span> are highlighted.
        </div>
      </div>

      By switching to insertion sort, we‚Äôve reduced the overall average running time of sweep-and-prune to _O(n + m)_!

      <box-note>
        It‚Äôs important to consider the primary axis of sweep-and-prune due to the sweeps plus the nature of insertion sort. It should be the axis where objects are most widely distributed to minimize swaps and overlaps.
      </box-note>

      The same could be applied to the simplified ‚Äúsorted pairwise‚Äù sweep-and-prune since it has a sorting step as well. *How can we ever top that?*

      ## Sweeps and swaps

      Well, there is yet another way to optimise this algorithm! Be prepared, the subject is about to get quite dense.
      
      Look at the insertion sort example above. You can observe that <span style="color:#f00">swaps</span> happen when and only **when an edge point passes through another**.

      An edge point passing through another can mean one of four things:

      | Case | Description |
      |------|-------------|
      | `R)‚Üî(L` | R edge from the left swaps with L edge from the right. |
      | `(L‚ÜîR)` | L edge from the left swaps with R edge from the right. |
      | `(L‚Üî(L` | Edges of the same side L swap. |
      | `R)‚ÜîR)` | Edges of the same side R swap. |

      Each swap scenario can mean something significant. Let‚Äôs look more closely into each case. 

      ### case R)‚Üî(L

      <blog-media
        alt="Animation of a R edge swapping with a L edge"
        :src="url('swap-rl.mp4')" />
        
      When a right edge from the left swaps with a left edge from the right, we can infer that the corresponding balls are __initiating an overlap__.

      ### case (L‚ÜîR)
      
      <blog-media
        alt="Animation of a L edge swapping with a R edge"
        :src="url('swap-lr.mp4')" />
        
      Conversely, when a left edge from the left swaps with a right edge from the right, the corresponding balls __cease to overlap__.

      ### cases (L‚Üî(L and R)‚ÜîR)
      
      <blog-media
        alt="Animation of a L edge swapping with a L edge"
        :src="url('swap-ll.mp4')" />
        
      Edges of the same polarity can swap without affecting the overlappedness of their corresponding balls. We can ignore these ones.

      Based on these swap events we can reframe the mechanics of sweep-and-prune in a new perspective, a bottom-up way centred around the swaps.

      A fun way to think about it is to pretend that a right edge is equivalent to a _local_ version of the sweep line. In that sense, the right edge _is_ the line sweeping over these other left edges.

      <blog-media
        alt="Animation a line sweep vs animation of an edge swap"
        :src="url('swap-as-sweep.mp4')"
        caption="An edge can be thought of as a local sweep line."/>

      Just as in a global sweep, passing left edges will mark the corresponding balls as ‚Äútouching‚Äù; in right-edge-as-a-local-sweep version, _swapping_ left edges will mark its ball as overlapping with the right edge‚Äôs ball.
 
      In the global sweep, there is a global `touching` set keeping track of which balls are in contact with the sweep line. In local swaps, we keep track of overlaps _per ball_. (More precisely, per pair.)

      Lastly, in the global sweep, a right edge means the end of contact with a ball. In a local swap, a left edge passing over a right edge means the same thing. The corresponding balls are unmarked as overlapping.

      Essentially, instead of a global sweep line, we do small local ‚Äúsweeps‚Äù around each ball. Swaps become mini-sweeps.

      Thus we arrive at the one-dimensional sweep-and-prune‚Äôs final form:

      <code-block :code="`\
function init() {
  overlapping = new Map()
}

function sweepAndPrune() {
  // Insertion sort
  for (let i = 1; i < edges.length; i++) {
    for (let j = i - 1; j >= 0; j--) {
      if (edges[j].x < edges[j + 1].x) break;

      // Swap
      [edges[j], edges[j + 1]] = [edges[j + 1], edges[j]]

      // --- Code up until this point is plain insertion sort ---

      // These two edges have just swapped places, process it...
      const edge1 = edges[j];
      const edge2 = edges[j + 1];

      if (edge1.isLeft && !edge2.isLeft) { // case R-L ‚Üí L-R
        // Mark as overlapping
        overlapping.set(
          key(edge1, edge2),
          [edge1.ball, edge2.ball]
        );
      } else if (!edge1.isLeft && edge2.isLeft) { // case L-R ‚Üí R-L
        // Unmark as overlapping
        overlapping.delete(key(edge1, edge2));
      }
    }
  }

  // Report overlaps
  for (const [ball1, ball2] of overlapping.values()) {
    onOverlapX(ball1, ball2);
  }
}`" />

      It‚Äôs essentially insertion sort hooked up to track overlaps.

      Let‚Äôs see it in action (though what you will see here is nothing new):

      <div class="demo-row">
        <sap-demo
          strategy="sap-swap"
          skip-interval="4"
          decorations="checks:#4c8"/>
      </div>

      While it behaves the same and has the same time complexity as the preceding variants, I think practically it‚Äôs much more efficient in terms of processing speed. In video games where every frame has a processing budget, the raw speed matters, not just the scalability. The constant factor that gets omitted by Big O notation still matters.

      ## Quick comparisons

      | Algorithm                   | Average time     | Best time        | Space |
      |-----------------------------|------------------|------------------|-------|
      | Global pairwise             | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1)  |
      | Sorted pairwise (quicksort) | O(n log n + m)   | O(n log n)       | O(1)  |
      | Sorted pairwise (insertion) | O(n + m)         | O(n)             | O(1)  |
      | Sweep-and-prune (quicksort) | O(n log n + m)   | O(n)             | O(n)  |
      | Sweep-and-prune (insertion) | O(n + m)         | O(n)             | O(n)  |
      | Sweep-and-prune (final)     | O(n + m)         | O(n)             | O(n&nbsp;+&nbsp;m)  |

      n = number of balls, m = number of collisions

      (todo: Add benchmark here. I‚Äôm a little lazy right now. üò∫)

      As always, the real measure of speed lies in real measurements on real hardware!

      ![Stop doing algorithm analysis](https://preview.redd.it/hqs9fcbor3z61.jpg?width=640&crop=smart&auto=webp&s=8aad431aefed7b4d80bc3667ac2472764b7322ac)
      [from r/ProgrammerHumor](https://www.reddit.com/r/ProgrammerHumor/comments/ncb11u/stop_doing_algorithm_analysis)

      ## Appendix

      Things I‚Äôve noted or realised while writing this post:

      * General algorithm design insights
        * Pre-sorting a list can replace a bunch of inequality checks, and unlocks:
          * Some power when linearly scanning over the list
          * Faster range / adjacency checks
          * (unrelated, but good to bring up) Binary search
        * Different sorting algorithms have situational strengths.
      * Big O, while useful, can only go so far.
      * I might need a frontend framework for my blog now, at least for the interactive demos.
        * Vanilla JS is starting to get scary with bigger demos like these.
        * `.mjs` is pretty good though.

      Bonus demo, 25 balls! It‚Äôs a ball party ‚öΩ‚öæüèÄüèê
      <div class="demo-row">
        <sap-demo balls="25" labels="üòÉ,üòÑ,üòÅ,üòÜ,üòÖ,üòÇ,ü§£,üòä,üòá,üòâ,üòå,üòç,ü•∞,üòò,üòã,üòú,ü§™,üòé,ü•≥,ü§©,ü§ó,üòè,üòí,üòî,üò¢" rainbow strategy="sap-swap-2d" />
      </div>
    </markdown>
  </blog-page>
</html>

<style>
  .demo-row {
    margin: 18px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .demo-caption {
    max-width: 600px;
  }

  .drag-hint {
    padding: 0 0.3rem;
    font-weight: bold;
    border: dashed 2px #fff7;
    border-radius: 2rem;
  }

  .pair-legend {
    display: inline-block;
    position: relative;
    top: -4px;
    margin: 0 4px;
    width: 22px;
    height: 2px;
    background: currentColor;
  }
  .pair-legend::before,
  .pair-legend::after {
    content: "";
    position: absolute;
    top: -4px;
    display: block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: currentColor;
  }
  .pair-legend::before {
    left: -2px;
  }
  .pair-legend::after {
    right: -2px;
  }

  .edges-array {
    position: relative;
    width: 100%;
    height: 20px;
  }
  .edge {
    position: absolute;
    width: 10px;
    height: 20px;
    border: solid 3px #fff;
    box-sizing: border-box;
    transition: transform 0.2s;
  }
  .edge-left {
    border-right: 0;
    border-top-left-radius: 10px;
    border-bottom-left-radius: 10px;
  }
  .edge-right {
    border-left: 0;
    border-top-right-radius: 10px;
    border-bottom-right-radius: 10px;
  }
</style>

<script client defer>
  const edgesArrays = document.querySelectorAll(".edges-array");

  for (const edgesArray of edgesArrays) {
    const target = document.querySelector(edgesArray.dataset.target);

    const edgeToElement = new Map();

    target.addEventListener(
      "sap-sort",
      throttle((event) => {
        const { edges } = event;
        const n = edges.length;

        if (edgeToElement.size === 0) {
          for (const edge of edges) {
            const edgeElement = document.createElement("div");
            edgeElement.classList.add("edge");
            edgeElement.classList.add(
              edge.dir < 0 ? "edge-left" : "edge-right"
            );
            edgeElement.style.display = "none";
            edgesArray.appendChild(edgeElement);
            edgeToElement.set(edge, edgeElement);
          }
        }

        const width = edgesArray.getBoundingClientRect().width;

        for (const [edge, edgeElement] of edgeToElement.entries()) {
          const index = edges.indexOf(edge);
          const x = width / 2 + 20 * (index - (n - 1) / 2);
          edgeElement.style.display = "block";
          edgeElement.style.borderColor = edge.ball.color;
          edgeElement.style.transform = `translateX(calc(${x}px - 50%))`;
        }
      })
    );
  }

  function throttle(func, ms = 100) {
    let lastTime = Date.now();
    return (...args) => {
      if (Date.now() - lastTime < ms) return;
      lastTime = Date.now();
      func(...args);
    };
  }
</script>
