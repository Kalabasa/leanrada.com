<html>
  <page-title title="How I built tic-tac-toe game AI in pure CSS" />
  <blog-page>
    <!-- prettier-ignore -->
    <markdown>
      <blog-header
        title="How I built tic-tac-toe game AI in pure CSS"
        :heroimgsrc="url('hero.png')" />

      <blog-post-info date="5 May 2023" read-mins="11" />

      As a software developer, I‚Äôm always looking for new and fun ways to challenge myself. Some time ago, I decided to implement tic-tac-toe with AI using only **HTML** and **CSS**. That is, no JavaScript! We already knew about the possibility of advanced CSS interactions (e.g. fancy checkboxes), but I wanted to see how far I could take it.

      Here‚Äôs a CodePen of it! Can you beat a style sheet in a game of tic-tac-toe?
      
      <p class="codepen" data-height="700" data-theme-id="dark" data-default-tab="result" data-slug-hash="oVMOZK" data-user="kalabasa" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
        <span>See the Pen <a href="https://codepen.io/kalabasa/pen/oVMOZK">
        Pure CSS Tic Tac Toe AI</a> by Kalabasa (<a href="https://codepen.io/kalabasa">@kalabasa</a>)
        on <a href="https://codepen.io">CodePen</a>.</span>
      </p>
      <script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

      In this post, I‚Äôll write about how I arrived at the solution, but let‚Äôs start with the fundamentals first.

      <box-note>
        Disclaimer: This is an experiment only. Never do this in real life!
      </box-note>

      ## Building blocks

      Before starting to build anything complex, it‚Äôs important to start small and think about the basic elements. Unlike JavaScript, HTML and CSS are declarative languages. We can‚Äôt have procedures or functions, control flow, if-statements, and the like. Instead what we have are markup and rules. We‚Äôll build upon these rules to create complex game logic.
      
      For starters, let‚Äôs do something that‚Äôs fairly common on the web: **custom checkbox styles**.
      
      <div class="demo-box demo1">
        <label><input type="checkbox" /><span></span> Check this out</label>
        <div><small>(these demos are interactive!)</small></div>
      </div>
      
      To do this, we need an extra element for the checkbox visuals, like an empty span element.
      
      <code-block language="html" :code="`
&lt;label&gt;
  &lt;input type=&quot;checkbox&quot; /&gt; &lt;span&gt;&lt;/span&gt; Check this out
&lt;/label&gt;
`" />

      On the CSS side, the real checkbox input is hidden, while the span is styled as a checkbox in its stead.

      Now here‚Äôs the important part, we‚Äôll use the `:checked` pseudo-class and the **sibling combinator** `~` to make it all  work. The checked pseudo-class selector reacts to the checkbox input‚Äôs state, while the sibling combinator makes it possible to apply the styles on the fake checkbox span element.

      <code-block language="css" :code="`
input:checked ~ span {
  background-color: red;
  transform: rotate(45deg);
}
`" />

      And that‚Äôs it, basically. Custom checkboxes!

      ### Action at a distance

      Now, the sibling combinator applies beyond styling boxes next to inputs. We can perform some ‚Äúaction at a distance‚Äù, for example:

      <div class="demo-box demo2">
        <input type="checkbox" id="demo2_input" />
        <label for="demo2_input">Is it raining?</label>
        <p>As you know, when it rains, water falls down from the sky. This may cause wetness. An umbrella is a device which shields the user from falling particles such as the aforementioned rainwater.</p>
        <fieldset class="advice">
          <legend>Advice</legend>
          <span class="take-umbrella">Take an umbrella today!</span>
          <span class="no-umbrella">No need for an umbrella!</span>
        </fieldset>
      </div>
      
      <code-block language="css" :code="`
input:checked ~ .advice .take-umbrella {
	visibility: visible;
}
input:checked ~ .advice .no-umbrella {
	visibility: hidden;
}
`" />

      As you‚Äôll see later, the sibling combinator `~` can be very useful for these types of interactions.

      ### The next level

      Let‚Äôs take this to the next level, shall we?
      
      Using the `&lt;label&gt;`‚Äôs `for` attribute, we can get event more action at a distance. We can make pretty much any kind of UI we want!

      Presenting... the weather-advice-o-matic! üåà

      <css-rain-machine-demo demo-number="1" />

      ### OR

      A single button is not very exciting, is it? Let‚Äôs add another input and implement an **OR** construct to determine the output. That is, if A or B then C.

      In CSS this can be easily achieved by using a **selector list** (i.e., comma-separated selectors).

      <code-block language="css" :code="`
input#raining:checked ~ .advice .take-umbrella,
input#sunny:checked ~ .advice .take-umbrella {
  visibility: visible;
}

/* General form: if [C1] or [C2] then [R]*/
[C1] ~ [R element],
[C2] ~ [R element] {
  [R effect]
}
`" />

      <css-rain-machine-demo demo-number="2" />

      ### AND

      How about **AND**? We can implement an AND construct too! This involves chaining the inputs together in a single selector using sibling combinators.

      <code-block language="css" :code="`
input#raining:checked ~ input#windy:checked ~ .advise .take-raincoat {
  visibility: visible;
}

/* General form: if [C1] and [C2] then [R]*/
[C1] ~ [C2] ~ [R element] {
  [R effect]
}
`" />

      <css-rain-machine-demo demo-number="3" />

      Another basic computing operator aside from AND and OR is the **NOT** operator. We don‚Äôt really need that here, but for the record, there‚Äôs the `:not()` pseudo-class in CSS.

      ## Prototype: Three-in-a-row

      As a proof of concept and precursor to tic-tac-toe, let‚Äôs look at this three-in-a-row game. 

      <css-three-in-a-row />

      This is a 3x3 array of checkbox inputs. Each box is numbered 1 to 9 starting from the top-left box going left-to-right by line.

      And here are the rules in CSS for implementing the win condition:

      <code-block language="css" :code="`
#1:checked ~ #2:checked ~ #3:checked ~ .win,
#4:checked ~ #5:checked ~ #6:checked ~ .win,
#7:checked ~ #8:checked ~ #9:checked ~ .win,
#1:checked ~ #4:checked ~ #7:checked ~ .win,
#2:checked ~ #5:checked ~ #8:checked ~ .win,
#3:checked ~ #6:checked ~ #9:checked ~ .win,
#1:checked ~ #5:checked ~ #9:checked ~ .win,
#3:checked ~ #5:checked ~ #7:checked ~ .win {
  visibility: visible;
}
`" />

      It‚Äôs kinda hacky, yes, but that is expected when you‚Äôre forcing logic into CSS. The CSS for tic-tac-toe goes over 9000 lines! I never said it would be clean.

      Anyway, these 8 rules correspond to the 8 possible ways to win the game. The 3-input AND rule (remember AND rules?) in each line covers *every possible winning combination*. Here‚Äôs the code with comments:

      <code-block language="css" :code="`
/*
 * if
 *      ([#1 marked] and [#2 marked] and [#3 marked]) // top row
 *   or ([#4 marked] and [#5 marked] and [#6 marked]) // middle row
 *   or ([#7 marked] and [#8 marked] and [#9 marked]) // bottom row
 *   .
 *   :
 *   or ([#3 marked] and [#5 marked] and [#7 marked]) // upward diagonal
 * then
 *   [win]
 */
#1:checked ~ #2:checked ~ #3:checked ~ .win,
#4:checked ~ #5:checked ~ #6:checked ~ .win,
#7:checked ~ #8:checked ~ #9:checked ~ .win,
#1:checked ~ #4:checked ~ #7:checked ~ .win,
#2:checked ~ #5:checked ~ #8:checked ~ .win,
#3:checked ~ #6:checked ~ #9:checked ~ .win,
#1:checked ~ #5:checked ~ #9:checked ~ .win,
#3:checked ~ #5:checked ~ #7:checked ~ .win {
  visibility: visible;
}
`" />

      ## Taking turns

      So far, the order of your inputs doesn‚Äôt matter. You can even undo your inputs by unchecking the boxes under the hood! That won‚Äôt fly in a game of tic-tac-toe, where we take turns incrementally marking the board. No backsies!

      We need a way to ‚Äúconsume‚Äù inputs. We can do this by hiding the inputs or otherwise making them unclickable. This is just a trick, of course, as we can‚Äôt really disable inputs using CSS. But it works fine for the typical mouse and touch users.

      So for tic-tac-toe, what I did was define multiple sets of the 3x3 input board, that is, one set of 3x3 inputs for each turn. Stacked on top of each other. Each set is only interactable on its turn.

      <blog-media
        alt="input sets illustration"
        :src="url('./input_sets.mp4')" />

      <code-block language="css" :code="`
/* Disable turn 1 inputs when turn 1 is played */
input[name=&quot;turn_1&quot;]:checked ~ input[name=&quot;turn_1&quot;] {
	pointer-events: none;
}
/* Enable next turn's inputs */
input[name=&quot;turn_1&quot;]:checked ~ input[name=&quot;turn_2&quot;] {
	pointer-events: all;
}
/* And so on... */
`" />

      Here‚Äôs little a demo of sequential inputs:

      <box-note>I was only able to implement up to three turns here. The exponential growth of rules had gotten really tedious to write!</box-note>

      <css-three-in-a-row-seq demo-number="1" />

      With the power of sequecning, we‚Äôre starting to recreate the power of state machines and procedural programming!

      <blog-media
        alt="Look What They Need To Mimic A Fraction Of Our Power meme"
        :src="url('./meme.jpg')" />

      ## Game AI

      <box-note>
        I‚Äôm referring to the more specific term ‚Äúgame AI‚Äù here, because the term ‚ÄúAI‚Äù has come to mean some learning machine nowadays. Game AI simply means NPCs or computer-controlled agents.
      </box-note>

      Tic-tac-toe is a [solved game](https://en.wikipedia.org/wiki/Solved_game), which means there exists a perfect strategy. For every move, there is a known optimal counter move.

      This is perfect for CSS as it‚Äôs just a bunch of static declarations. We can list all of the optimal moves and directly translate them into CSS declarations!

      As a side-effect, the AI would never lose. But that‚Äôs not a bad thing at all. Here, the CSS will style on you.

      The rules are essentially a bunch of if-then statements for every scenario, such as these ones:

      ### Blocking

      Example rule: _If **X(1)** and **X(2)** then **O(3)**._

      In English, if an X was played at box #1 (top-left) and another X is at #2 (top-center), then block by playing O at box #3 (top-right).

      (In these examples, X is the player and O is the AI.)

      In CSS,

      <code-block language="css" :code="`
input[value=&quot;1&quot;]:checked
~ input[value=&quot;2&quot;]:checked
~ .o3 {
  visibility: visible,
}
`" />

      <blog-media
        alt="blocking rule animation"
        :src="url('./blocking.mp4')" />

      ### Winning moves

      Another example: _If **O(3)** and **O(7)** then **O(5)**._

      If O is at box #3 (top-right) and another O is at #7 (bottom-left), then win by playing O at box #5 (center).

      Now, this rule needs knowledge of the AI‚Äôs previous moves. But we can‚Äôt really check for that as they‚Äôre not inputs. There is no direct translation of **O(3)** and **O(7)** into CSS conditions.
      
      But since the AI is deterministic, we already know how those previous *O*s came about. They‚Äôre just responses to previous inputs as defined in previous rules! So, for example, we can substitute **O(3)** with the inputs that produced it, such as **X(1)** & **X(2)**.

      <code-block language="css" :code="`
input[value=&quot;1&quot;]:checked
~ input[value=&quot;2&quot;]:checked /* We know X(1) and X(2) produces O(3) */
~ input[value=&quot;4&quot;]:checked /* X(1) and X(4) produces O(7) */
.o5 {
  visibility: visible,
}
/* Therefore, X(1) & X(2) & X(4) is equivalent to O(3) & O(7). */
/* If X(1) & X(2) & X(4) then O(5) is a winnng move! */
`" />

      <box-note>
        ‚ö†Ô∏è Warning: I‚Äôm skipping major details in these code examples, like the existence of turn order, but it doesn‚Äôt really change the essence of these illustrations.
      </box-note>

      Alright, now that we can implement game AI rules in CSS, what are the actual rules?  Is there a list of all the optimal moves, like a cheatsheet?

      Well, there is one, but it‚Äôs for humans.

      <text-link href="https://xkcd.com/832/">
        <blog-media
          src="https://imgs.xkcd.com/comics/tic_tac_toe.png"
          caption="xkcd/832" />
      </text-link>

      It‚Äôs not really feasible these rules by hand, unless you have more than 60,480 hours to spare.

      What I did was write some kind of [minimax algorithm](https://en.wikipedia.org/wiki/Minimax) to generate all the rules. The algorithm semi-exhaustively searched the game state space, while recording the moves that lead to a win or a draw, and saved those moves as rules.

      I lost the original code (trashed it after finishing the project), but here‚Äôs an untested recreation of the algorithm:

      <code-block language="javascript" :code="`
/**
 * Evaluates a game state having these parameters: last plays of player X,
 * the player who has the current turn, and the current board state.
 *
 * Along the way, prints CSS rules for O's plays.
 *
 * Returns the endgame for O: WIN, LOSS, or a DRAW. Assuming optimal play.
 */
function evaluate(xPlays: number[], currentTurn: 'X' | 'O', board: ('X' | 'O' | null)[]) {

  // checkWinner checks for a 3-in-a-row and returns the winner.
  let winner = checkWinner(board)
  if (winner == 'X') return LOSS
  else if (winner == 'O') return WIN
  else if (xPlays.length == 5) return DRAW // Board full (5 Xs implies 4 Os)


  if (currentTurn == 'O') {
    // Brute-force find the optimal play for O
    let optimal = null
    let winnable = false
    for (i = 0; i < 9; i++) {
      if (board[i]) continue

      board[i] = 'O'
      const result = evaluate(xPlays, 'X', board)
      board[i] = null

      if (result == DRAW) {
        // This play will lead to a draw. Save it for now.
        optimal = i
      } else if (result == WIN) {
        // This play will lead to a win. This is it.
        optimal = i
        winnable = true
        break
      } // No else. Discard play that would lead to LOSS.
    }

    if (optimal == null) {
      // No winning play nor draws found. All paths lead to loss.
      return LOSS
    } else {
      // Optimal play found. Print rule.
      printCSS(xPlays, optimal)
      return winnable ? WIN : DRAW
    }
  } else { // currentTurn == 'X'
    // We don't know what the player would play
    // So evaluate every possibe play
    let loseable = false
    for (i = 0; i < 9; i++) {
      if (board[i]) continue

      board[i] = 'X'
      const result = evaluate([...xPlays, i], 'O', board)
      board[i] = null

      if (result == LOSS) loseable = true
    }

    // Assume player plays optimally. If they can win from current state,
    // then immediately presume LOSS. This will factor into O's turn evaluation
    // above, where any play that leads to LOSS is discarded.
    if (loseable) return LOSS

    // Not loseable, either winnable or drawable.
    // Returning DRAW allows both paths to be evaluated.
    return DRAW
  }
}`" />

      And here‚Äôs the function that outputs CSS:

      <code-block language="javascript" :code="`
/**
 * Print CSS rule for the given game state and O's next play.
 */
function printCSS(xPlays: number[], oPlay: number) {
  css += xPlays
    .map((pos, turn) =>
        ${'`'}input[name='turn_\${turn}'][value='\${pos}']:checked${'`'})
    .join(' ~ ')
    + ${'`'} ~ .o\${oPlay}${'`'}
    + ' { visibility: visible; }'
}`" />

      The CSS output is directly used in the game. Debugging this was a pain, but luckily I only got a couple of miscalculations (if I recall correctly).

      ## Conclusion

      It was a very interesting project. I‚Äôm curious how far this could go. A JS to CSS transpiler, perhaps?
      
      This project serves as a reminder that there are always new and exciting ways to waste our time doing impractical things, and that sometimes fun solutions come from thinking outside of the (check)box.

      <text-link href="https://codepen.io/kalabasa/pen/oVMOZK">Here‚Äôs the link to the CodePen!</text-link>
    </markdown>
  </blog-page>
</html>

<style>
  .demo-box {
    border-radius: 12px;
    background-color: #eee;
    color: #000;
    padding: 12px;
    user-select: none;
  }

  .demo1 label {
    cursor: pointer;
  }
  .demo1 input {
    appearance: none;
  }
  .demo1 span {
    display: inline-block;
    width: 1ch;
    height: 1ch;
    border: solid 2px red;
    transition: background-color 0.3s, transform 0.2s;
  }
  .demo1 input:checked ~ span {
    background-color: red;
    transform: rotate(45deg);
  }

  .demo2 .advice {
    min-height: 2em;
    min-height: 2lh;
  }
  .demo2 .advice span {
    display: block;
    position: absolute;
  }
  .demo2 .take-umbrella {
    visibility: hidden;
  }
  .demo2 input:checked ~ .advice .take-umbrella {
    visibility: visible;
  }
  .demo2 input:checked ~ .advice .no-umbrella {
    visibility: hidden;
  }
</style>
