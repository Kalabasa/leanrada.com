<common />

<nebula-client :class="attrs.class" :palette="attrs.palette">
  <canvas style="filter: contrast(1.5)" />
</nebula-client>

<style>
  nebula-client > canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }
</style>

<script client defer src="https://unpkg.com/perlin-noise-3d@v0.5.4"></script>
<script client>
  customElements.define(
    "nebula-client",
    class Nebula extends BaseElement {
      constructor() {
        super();

        this.asyncCanvas = this.asyncQuerySelector("canvas");
        this.context = null;
        this.noise = null;

        this.gridSize = 30;
        this.palette = ["#ff0000", "#00ff00", "#0000ff"];

        this.lastT = 0;
        this.startT = 0;

        this.isVisible = true;
        this.visibilityListener({
          show: () => {
            this.isVisible = true;
            if (this.isConnected) this.loop();
          },
          hide: () => (this.isVisible = false),
        });
      }

      connectedCallback() {
        super.connectedCallback();

        const paletteAttr = this.getAttribute("palette");
        if (paletteAttr) {
          this.palette = paletteAttr.split(" ");
        }

        if (this.isVisible) this.loop();
      }

      async loop() {
        if (!this.isConnected && !this.isVisible) return;

        const canvas =
          this.asyncCanvas.value ?? (await this.asyncCanvas.promise);

        // initialize
        if (!this.context) {
          canvas.style.filter += ` blur(${Math.ceil(
            canvas.width / this.gridSize
          )}px)`;
          canvas.globalCompositeOperation = "overlay";
          this.context = canvas.getContext("2d");
          this.context.fillStyle = "#000";
          this.context.fillRect(0, 0, canvas.width, canvas.height);
        }

        requestAnimationFrame(() => this.loop());

        if (typeof perlinNoise3d === "undefined") return;
        if (!this.noise) {
          this.noise = initNoise();
          this.startT = getT();
        }

        this.draw(canvas, this.context);
      }

      /**
       * @param canvas {HTMLCanvasElement}
       * @param context {CanvasRenderingContext2D}
       */
      draw(canvas, context) {
        const t = getT();
        if (t <= this.lastT) return;
        this.lastT = t;

        const initTime = 16;
        const alpha =
          t <= this.startT + initTime
            ? 1 * ((this.startT + initTime - t) / initTime)
            : 0.016;

        const { noise, gridSize, palette } = this;
        const paletteLength = palette.length;
        const xScale = 0.14 + Math.sin(t * 0.03) * 0.06;
        const yScale = 0.14 + Math.cos(t * 0.05) * 0.06;

        const cellWidth = Math.ceil(canvas.width / gridSize);
        const cellHeight = Math.ceil(canvas.height / gridSize);
        const halfGridSize = gridSize / 2;

        for (let i = 0, x = 0; i < gridSize; i++, x += cellWidth) {
          for (let j = 0, y = 0; j < gridSize; j++, y += cellHeight) {
            const xy = [
              1000 + (i - halfGridSize) * xScale + Math.sin(t * 0.01) * 2,
              1000 + (j - halfGridSize) * yScale + Math.cos(t * 0.007) * 2,
            ];
            const p1 = noise.get(...xy, t * 0.03);
            const p2 = noise.get(...xy, t * 0.03 + 0.5);
            // for some reason, this library's output range is [0,0.5], so this averages to [0,1]
            const p = p1 + p2;
            const paletteIndex = Math.floor(paletteLength * p);

            const rgb = palette[paletteIndex];
            const a = Math.floor(alpha * 255)
              .toString(16)
              .padStart(2, "0");

            context.fillStyle = `${rgb}${a}`;
            context.fillRect(x, y, cellWidth, cellHeight);
          }
        }
      }
    }
  );

  function getT() {
    return Math.floor((Date.now() * 30) / 1000);
  }

  function initNoise() {
    const noise = new perlinNoise3d();
    noise.perlin_octaves = 1; // ?? defaults
    noise.perlin_amp_falloff = 1;
    return noise;
  }
</script>
